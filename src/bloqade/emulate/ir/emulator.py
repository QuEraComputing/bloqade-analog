from dataclasses import dataclass
from decimal import Decimal
from typing import Any, Dict, List, Tuple, Optional, Callable
from enum import Enum
from bloqade.ir.control.sequence import LevelCoupling
from bloqade.emulate.ir.atom_type import AtomType


class RabiOperatorType(Enum):
    RabiAsymmetric = 0
    RabiSymmetric = 1


@dataclass(frozen=True)
class RabiOperatorData:
    operator_type: RabiOperatorType
    target_atoms: Dict[int, Decimal]

    def __hash__(self):
        return hash(self.operator_type) ^ hash(frozenset(self.target_atoms.items()))


@dataclass(frozen=True)
class RabiTerm:
    operator_data: RabiOperatorData
    amplitude: Callable[[float], float]
    phase: Optional[Callable[[float], float]] = None


@dataclass(frozen=True)
class DetuningOperatorData:
    target_atoms: Dict[int, Decimal]

    def __hash__(self) -> int:
        return hash(frozenset(self.target_atoms.items()))


@dataclass(frozen=True)
class DetuningTerm:
    operator_data: DetuningOperatorData
    amplitude: Callable[[float], float]


@dataclass(frozen=True)
class LaserCoupling:
    detuning: List[DetuningTerm]
    rabi: List[RabiTerm]


@dataclass(frozen=True)
class Register:
    """This class represents the of the atoms in the system."""

    atom_type: AtomType
    positions: List[Tuple[Decimal, Decimal]]
    blockade_radius: Decimal

    def __len__(self):
        return len(self.positions)

    def __eq__(self, other: Any):
        if isinstance(other, Register):
            return (
                self.atom_type == other.atom_type
                and self.blockade_radius == other.blockade_radius
                and set(self.positions) == set(other.positions)
            )

        return False

    def __hash__(self) -> int:
        if self.blockade_radius == Decimal("0"):
            # if blockade radius is zero, then the positions are irrelevant
            # because the fock states generated by the geometry are the same
            return (
                hash(self.__class__) ^ hash(self.atom_type) ^ hash(len(self.positions))
            )
        else:
            # if blockade radius is non-zero, then the positions are relevant
            # because depending on the location of the atoms and the blockade
            # radius, the fock states generated by the geometry are different
            return (
                hash(self.__class__)
                ^ hash(self.atom_type)
                ^ hash(self.blockade_radius)
                ^ hash(frozenset(self.positions))
            )


@dataclass(frozen=True)
class EmulatorProgram:
    geometry: Register
    duration: float
    drives: Dict[LevelCoupling, LaserCoupling]


class Visitor:
    def visit_emulator_program(self, ast: EmulatorProgram) -> Any:
        raise NotImplementedError

    def visit_laser_coupling(self, ast: LaserCoupling) -> Any:
        raise NotImplementedError

    def visit_detuning_operator_data(self, ast: DetuningOperatorData) -> Any:
        raise NotImplementedError

    def visit_rabi_operator_data(self, ast: RabiOperatorData) -> Any:
        raise NotImplementedError

    def visit_detuning_term(self, ast: DetuningTerm) -> Any:
        raise NotImplementedError

    def visit_rabi_term(self, ast: RabiTerm) -> Any:
        raise NotImplementedError

    def visit_register(self, ast: Register) -> Any:
        raise NotImplementedError

    def visit(self, ast) -> Any:
        match ast:
            case EmulatorProgram():
                return self.visit_emulator_program(ast)
            case Register():
                return self.visit_register(ast)
            case LaserCoupling():
                return self.visit_laser_coupling(ast)
            case DetuningOperatorData():
                return self.visit_detuning_operator_data(ast)
            case RabiOperatorData():
                return self.visit_rabi_operator_data(ast)
            case DetuningTerm():
                return self.visit_detuning_term(ast)
            case RabiTerm():
                return self.visit_rabi_term(ast)

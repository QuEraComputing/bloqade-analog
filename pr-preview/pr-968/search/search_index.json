{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#welcome-to-bloqade-queras-neutral-atom-sdk","title":"Welcome to Bloqade: QuEra's Neutral Atom SDK","text":""},{"location":"#what-is-bloqade","title":"What is Bloqade?","text":"<p>Bloqade is a Python SDK for QuEra's neutral atom quantum computer Aquila (check out our paper!). It's designed to make writing and analyzing the results of analog quantum programs on Aquila as easy as possible. It features custom atom geometries and flexible waveform definitions in both emulation and real hardware. Bloqade interfaces with the AWS Braket cloud service where Aquila  is hosted, enabling you to submit programs as well as retrieve and analyze real hardware results all-in-one.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install the package with <code>pip</code> in your Python environment of choice via:</p> <pre><code>pip install bloqade\n</code></pre>"},{"location":"#a-glimpse-of-bloqade","title":"A Glimpse of Bloqade","text":"<p>Let's try a simple example where we drive a Rabi oscillation on a single neutral atom. Don't worry if you're unfamiliar with neutral atom physics, (you can check out our Background for more information!) the goal here is to just give you a taste of what Bloqade can do.</p> <p>We start by defining where our atoms go, otherwise known as the atom geometry. In this particular example we will use a small Honeycomb lattice:</p> <pre><code>from bloqade.atom_arrangement import Honeycomb\n\ngeometry = Honeycomb(2, lattice_spacing = 10.0)\n</code></pre> <p>We can verify what the atom geometry looks like by <code>.show()</code>'ing it: </p> <pre><code>geometry.show()\n</code></pre> <p>We now define what the time evolution looks like using a pulse sequence. The pulse sequence here is the time profile of the Rabi Drive targeting the ground-Rydberg two level transition, which causes the Rabi oscillations. We choose a constant waveform with a value of \\(\\frac{\\pi}{2} \\text{rad}/\\text{us}\\) and a duration of \\(1.0 \\,\\text{us}\\). This produces a \\(\\frac{\\pi}{2}\\) rotation on the Bloch sphere meaning our final measurements should be split 50/50 between the ground and Rydberg state.</p> <pre><code>from math import pi\nrabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .constant(value=pi/2, duration=1.0)\n)\n</code></pre> <p>Here <code>rabi.amplitude</code> means exactly what it is, the Rabi amplitude term of the Hamiltonian. <code>uniform</code> refers to applying the waveform uniformly across all the atom locations. </p> <p>We can visualize what our program looks like again with <code>.show()</code>:</p> <p>We can now run the program through Bloqade's built-in emulator to get some results. We designate that we want the program to be run and measurements performed 100 times:</p> <pre><code>emulation_results = rabi_program.bloqade.python().run(100)\n</code></pre> <p>With the results we can generate a report object that contains a number of methods for analyzing our data, including the number of counts per unique bitstring:</p> <pre><code>bitstring_counts = emulation_results.report().counts()\n</code></pre> <p>Which gives us:</p> <pre><code>[OrderedDict([('0', 55), ('1', 45)])]\n</code></pre> <p>If we want to submit our program to hardware we'll need to adjust the waveform as there is a constraint the Rabi amplitude waveform must start and end at zero.  This is easy to do as we can build off the atom geometry we saved previously but apply a piecewise linear waveform:</p> <pre><code>hardware_rabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\n\nhardware_rabi_program.show()\n</code></pre> <p>Now instead of using the built-in Bloqade emulator we submit the program to Aquila. You will need to use the AWS CLI to obtain credentials from your AWS account  or set the proper environment variables before hand. </p> <pre><code>hardware_results = hardware_rabi_program.braket.aquila.run_async(100)\n</code></pre> <p><code>.run_async</code> is a non-blocking version of the standard <code>.run</code> method, allowing you to continue work while waiting for results from Aquila. <code>.run_async</code> immediately returns an object you can query for the status of your tasks in the queue as well.</p> <p>You can do the exact same analysis you do on emulation results with hardware results too:</p> <pre><code>hardware_bitstring_counts = hardware_results.report().counts()\n</code></pre> <p>If you want to try the above at once, we collected the above steps into the snippet below:</p> <pre><code>from math import pi\nfrom bloqade.atom_arrangement import Honeycomb\n\ngeometry = Honeycomb(2, lattice_spacing = 10.0)\nrabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .constant(value=pi/2, duration=1.0)\n)\nemulation_results = rabi_program.bloqade.python().run(100) \nbitstring_counts = emulation_results.report().counts()\n\nhardware_rabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\nhardware_results = hardware_rabi_program.braket.aquila.run_async(100)\nhardware_bitstring_counts = hardware_results.report().counts()\n</code></pre> <p> </p>"},{"location":"#features","title":"Features","text":""},{"location":"#customizable-atom-geometries","title":"Customizable Atom Geometries","text":"<p>You can easily explore a number of common geometric lattices with Bloqade's <code>atom_arrangement</code>'s:</p> <pre><code>from bloqade.atom_arrangement import Lieb, Square, Chain, Kagome\n\ngeometry_1 = Lieb(3)\ngeometry_2 = Square(2)\ngeometry_3 = Chain(5)\ngeometry_4 = Kagome(3)\n</code></pre> <p>If you're not satisfied with the Bravais lattices we also allow you to modify existing Bravais lattices as follows:</p> <pre><code>geometry_5 = Kagome(3).add_position((10,11))\n</code></pre> <p>You can also build your geometry completely from scratch:</p> <pre><code>from bloqade import start\n\ngeometry = start.add_positions([(0,0), (6,0), (12,0)])\n</code></pre>"},{"location":"#flexible-pulse-sequence-construction","title":"Flexible Pulse Sequence Construction","text":"<p>Define waveforms for pulse sequences any way you like by either building (and chaining!) them immediately as part of your program:</p> <pre><code>from bloqade.atom_arrangement import Square\n\ngeometry = Square(2)\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\ncustom_rabi_amp_waveform = (\n  target_rabi_amplitude\n  .piecewise_linear(values=[0, 10, 10, 0], durations=[0.1, 3.5, 0.1])\n  .piecewise_linear(values=[0, 5, 3, 0], durations=[0.2, 2.0, 0.2])\n)\n</code></pre> <p>Or building them separately and applying them later:</p> <pre><code>from bloqade.atom_arrangement import Square, Chain\n\ngeometry_1 = Square(3)\ngeometry_2 = Chain(5)\n\ntarget_rabi_amplitude = start.rydberg.rabi.amplitude.uniform\npulse_sequence = target_rabi_amplitude.uniform.constant(value=2.0, duration=1.5).parse_sequence()\n\nprogram_1 = geometry_1.apply(pulse_sequence)\nprogram_2 = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"#hardware-and-emulation-backends","title":"Hardware and Emulation Backends","text":"<p>Go from a fast and powerful emulator:</p> <pre><code>from bloqade.atom_arrangement import Square\nfrom math import pi\n\ngeometry = Square(3, lattice_spacing = 6.5)\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nprogram = (\n  target_rabi_amplitude\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\nemulation_results = program.bloqade.python().run(100)\n</code></pre> <p>To real quantum hardware in a snap:</p> <pre><code>hardware_results = program.braket.aquila().run_async(100)\n</code></pre>"},{"location":"#simple-parameter-sweeps","title":"Simple Parameter Sweeps","text":"<p>Use variables to make parameter sweeps easy on both emulation and hardware:</p> <pre><code>from bloqade import start\nimport numpy as np\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_oscillation_program = (\n  target_rabi_amplitude\n  .piecewise_linear(durations = [0.06, \"run_time\", 0.06], values = [0, 15, 15, 0])\n)\nrabi_oscillation_job = rabi_oscillation_program.batch_assign(run_time=np.linspace(0, 3, 101))\n\nemulation_results = rabi_oscillation_job.bloqade.python().run(100)\nhardware_results = rabi_oscillation_job.braket.aquila().run(100)\n</code></pre> <pre><code>emulation_results.report().rydberg_densities()\n                0\ntask_number      \n0            0.16\n1            0.35\n2            0.59\n3            0.78\n4            0.96\n...           ...\n96           0.01\n97           0.09\n98           0.24\n99           0.49\n100          0.68\n\n[101 rows x 1 columns]\n</code></pre>"},{"location":"#quick-results-analysis","title":"Quick Results Analysis","text":"<p>Want to just see some plots of your results? <code>.show()</code> will show you the way!</p> <p><pre><code>from bloqade.atom_arrangement import Square\n\nrabi_amplitude_values = [0.0, 15.8, 15.8, 0.0]\nrabi_detuning_values = [-16.33, -16.33, 42.66, 42.66]\ndurations = [0.8, 2.4, 0.8]\n\ngeometry = Square(3, lattice_spacing=5.9)\nrabi_amplitude_waveform = (\n  geometry\n  .rydberg.rabi.amplitude.uniform.piecewise_linear(durations, rabi_amplitude_values)\n)\nprogram = (\n  rabi_amplitude_waveform\n  .detuning.uniform.piecewise_linear(durations, rabi_detuning_values)\n)\nemulation_results = program.bloqade.python().run(100)\nemulation_results.report().show()\n</code></pre> </p>"},{"location":"#contributing-to-bloqade","title":"Contributing to Bloqade","text":"<p>Bloqade is released under the Apache License, Version 2.0. If you'd like the chance to shape the future of neutral atom quantum computation, see our Contributing Guide for more info!</p>"},{"location":"blog/2023/","title":"Bloqade Blog Posts 2023","text":"<p>Sept. 21, 2023 - Introducing Bloqade SDK for Python</p>"},{"location":"blog/2023/posts/bloqade-release/","title":"Introducing Bloqade SDK for Python","text":"<p>Greetings Neutral Atom QC experts, enthusiasts, and newcomers!</p> <p>We are excited to the Rydberg state thrilled to announce the Python version of our cutting-edge SDK, Bloqade. Originally developed in Julia, Bloqade has been a game-changer in the realm of Neutral Atom quantum computing. With the introduction of the Python version, we aim to make this revolutionary technology more accessible and user-friendly than ever before.</p>"},{"location":"blog/2023/posts/bloqade-release/#why-python","title":"Why Python?","text":"<p>Python is one of the most widely used programming languages, especially in the quantum computing community and broader scientific communities. By extending Bloqade to Python, we are opening doors to a broader audience, enabling more developers, researchers, and organizations to harness the power of Neutral Atom quantum computing.</p>"},{"location":"blog/2023/posts/bloqade-release/#neutral-atom-quantum-computing","title":"Neutral Atom Quantum Computing","text":"<p>Recently, the Neutral Atom platform has come on the QC scene in the form of Analog Hamiltonian Simulators that have a broad set of use cases beyond quantum circuits. Ranging from simulating unique quantum phases of matter, solving combinatorical optimization problems, and machine learning applications, the analog mode provides strong values in solving practical, interesting problems in the near term.</p> <p>These advances are crucial milestones on the way towards scalable digital gate-based architecture using atom shuttling. This new technology and its novel applications demand a paradigm shift in the way we not only think about quantum computing, but translate those ideas to real hardware. Enter Bloqade, a next-generation SDK designed to put the power of neutral atoms at your fingertips.</p>"},{"location":"blog/2023/posts/bloqade-release/#why-bloqade","title":"Why Bloqade?","text":"<p>Bloqade is designed with the primary goal of making it easier to compose programs for QuEra\u2019s hardware and analyze results.</p> <p>We've gained valuable insights into how users have used our neutral-atom hardware and with it, their struggles with existing tools. We took advantage of this knowledge to produce a tool that could take the \"hard\" out of \"hardware\". Bloqade is precision-balanced in both flexibility to empower novices to experiment with ease and power to let experts perform cutting-edge work without breaking a sweat.</p>"},{"location":"blog/2023/posts/bloqade-release/#highlights","title":"Highlights","text":""},{"location":"blog/2023/posts/bloqade-release/#smart-documentation","title":"Smart Documentation","text":"<p>With our commitment to enabling more seamless program development, we've put the relevant documentation you need right where and when you need it.</p> <p>No more obnoxious switching between your favorite coding environment and documentation in a separate window. Let Bloqade guide you where you'd like to go:</p> <p></p>"},{"location":"blog/2023/posts/bloqade-release/#fully-parameterized-analog-programs","title":"Fully Parameterized Analog Programs","text":"<p>Parameter sweeps are a common theme of programs for analog quantum computers, where a user would like to observe differences in output results by varying a value or values in their program.</p> <p>You used to have to manually crank out variations of your program with different values and then keep track of all the individual submissions to the emulator and hardware, a mess to keep track of and process the results of afterwards.</p> <p>Bloqade eliminates this with its own support for variables that can later be assigned single values or a whole sequence of values for trivial parameter sweeping. This isn't some feature that's constrained to a certain backend, you can take your program with all its variables and submit it to your choice of emulator or our hardware directly.</p> <pre><code>from bloqade import var\nfrom bloqade.atom_arrangement import Square\n\nimport numpy as np\n\nadiabatic_durations = [0.4, 3.2, 0.4]\n\n# create variables explicitly...\nmax_detuning = var(\"max_detuning\")\n# ...or implicitly inside the program definition.\nadiabatic_program = (\n    Square(3, \"lattice_spacing\")\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=adiabatic_durations, values=[0.0, \"max_rabi\", \"max_rabi\", 0.0]\n    )\n    .detuning.uniform.piecewise_linear(\n        durations=adiabatic_durations,\n        values=[\n            -max_detuning, # scalar variables support direct arithmetic operations\n            -max_detuning,\n            max_detuning,\n            max_detuning,\n        ],\n    )\n    .assign(max_rabi=15.8, max_detuning=16.33)\n    .batch_assign(lattice_spacing=np.arange(4.0, 7.0, 0.5))\n)\n\n# Launch your program on your choice of Braket or in-house emulator...\nemu_results = adiabatic_program.braket.local_emulator().run(10000)\nfaster_emu_results = adiabatic_program.bloqade.python().run(10000)\n# ...as well as hardware without stress\nhw_results = adiabatic_program.parallelize(24).braket.aquila().run_async(100)\n</code></pre>"},{"location":"blog/2023/posts/bloqade-release/#integrated-visualization-tools","title":"Integrated Visualization Tools","text":"<p>Instantly understand what your programs are doing faster than you can say \"neutral atoms rock!\" with Bloqade's built-in visualization tools:</p> <p></p> <p></p> <p>For your results, no more obnoxious manual compilation of results across different parameters or wrangling them into more useful forms. Get insights of experiment outcomes in the blink of an eye:</p> <p></p> <p></p> <p>Now that's what we call having your cake AND eating it.</p>"},{"location":"blog/2023/posts/bloqade-release/#bloqade-roadmap","title":"Bloqade Roadmap","text":""},{"location":"blog/2023/posts/bloqade-release/#bloqade-alpha-phase","title":"Bloqade Alpha Phase","text":"<p>During the next year, we plan on continuing development of Bloqade's python interface. If you are as excited about Neutral Atom quantum computing as us, or heck, even just quantum physics in general, give Bloqade a try! This is your opportunity to influence the direction of Bloqade and get in on the ground floor of the next Quantum Computing revolution.</p>"},{"location":"blog/2023/posts/bloqade-release/#but-what-about-julia","title":"But what about Julia?","text":"<p>Don't you guys already HAVE an SDK in Julia? Why do you need two SDKs?</p> <p>That's right! However, there's a key motivating factor for the reason we created Bloqade Python that's distinct for Bloqade.jl's existence.</p> <p>Bloqade.jl is primarily geared as a high-performance emulator. It allows you to design complex neutral-atom algorithms that may not necessarily run on our hardware BUT are excellent if you're exploring novel physical phenonema/algorithms or as a tool for pedagogical purposes.</p> <p>Bloqade.jl does have the ability to submit to Aquila, our flagship quantum computer, but for more complex tasks such as sweeping parameters (e.g. running the same program on hardware with slightly different parameters each time) or advanced post-processing, it becomes cumbersome quite quickly.</p> <p>There are no plans to drop support any time soon though. On the contrary, we plan on fully integrating Bloqade.jl into the Python package, which will enable you to program Neutral Atom quantum hardware without having to choose.</p> <p>We very much look forward to you trying out Bloqade!</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to the project! We welcome all contributions. There are many different ways to contribute to Bloqade, and we are always looking for more help. We accept contributions in the form of bug reports, feature requests, documentation improvements, and code contributions. For more information about how to contribute, please read the following sections.</p>"},{"location":"contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Reporting a Bug </li> <li>Reporting Documentation Issues</li> <li>Feature Requests</li> <li>Developing Bloqade</li> <li>Design Philosophy and Architecture</li> <li>Community Slack</li> <li>Ask a Question</li> <li>Providing Feedback</li> </ul>"},{"location":"contributing/asking-a-question/","title":"Ask a Question","text":"<p>If you're interested in contributing to Bloqade, or just want to discuss the project, join the discussion on GitHub Discussions at https://github.com/QuEraComputing/bloqade-python/discussions</p>"},{"location":"contributing/code-of-conduct/","title":"Design Philosophy and Architecture","text":"<p>Given the heterogeneous nature of the hardware we target, We have decided to use a compiler-based approach to our software stack, allowing us to target different hardware backends with the same high-level language. Below is a diagram of the software stack in Bloqade.</p> <pre><code>graph TD\n    Builder[\"Builder Representation\"]\n    PythonAST[\"Bloqade AST Python\"]\n    JuliaAST[\"Bloqade AST Julia\"]\n\n    EmulatorPy[\"Emulator IR Python\"]\n    EmulatorJL[\"Emulator IR Julia\"]\n\n    QuEra[\"QuEra IR\"]\n    Braket[\"Braket IR\"]\n    JuliaEmulator[\"Bloqade.jl\"]\n    PythonEmulator[\"Python Emulator\"]\n\n    Aquila[\"Aquila\"]\n\n    Builder --&gt;|parse| PythonAST\n    PythonAST --&gt;|lower| EmulatorPy\n    PythonAST --&gt;|lower| QuEra\n    PythonAST --&gt;|lower| Braket\n    PythonAST --&gt;|transpile| JuliaAST\n\n    QuEra --&gt;|execute| Aquila\n    Braket --&gt;|execute| Aquila\n\n    JuliaAST --&gt;|lower| EmulatorJL\n    EmulatorPy --&gt;|execute| PythonEmulator\n    EmulatorJL --&gt;|execute| JuliaEmulator\n</code></pre>"},{"location":"contributing/code-of-conduct/#high-level-builder-representation","title":"High-Level Builder Representation","text":"<p>When programming Bloqade using the Python API, the user constructs a representation of an analog quantum circuit. This representation is a flattened version of the actual analog circuit. Flattened means that the user input is a linear sequence of operations where the context of neighboring nodes in the sequence of instructions can determine the program tree structure. The Bloqade AST describes the actual analog circuit.</p>"},{"location":"contributing/code-of-conduct/#bloqade-ast","title":"Bloqade AST","text":"<p>The Bloqade AST is a representation of a quantum analog circuit for neutral atom computing. It is a directed acyclic graph (DAG) with nodes for different hierarchical levels of the circuit. The base node is the <code>AnalogCircuit</code> which contains the geometry of the atoms stored as a <code>AtomArragment</code> or <code>ParallelRegister</code> objects. The other part of the circuit is the <code>Sequence</code>, which contains the waveforms that describe the drives for the Ryberg/Hyperfine transitions of each Rydberg atom. Each transition is represented by a <code>Pulse</code> including a <code>Field</code> for the drive's detuning, Rabi amplitude, and Rabi phase . A <code>Field</code> relates the spatial and temporal dependence of a drive. The spatial modulates the temporal dependence of the waveform. A DAG also describes the <code>Waveform</code> object. Finally, we have basic <code>Scalar</code> expressions as well for describing the syntax of real-valued continuous numbers.</p>"},{"location":"contributing/code-of-conduct/#bloqade-compilers-and-transpilers","title":"Bloqade Compilers and Transpilers","text":"<p>Given a user program expressed as the Bloqade AST, we can target various backends by transforming from the Bloqade AST to other kinds of IR. For example, when submitting a task to QuEra's hardware, we transform the Bloqade AST to the IR that describes a valid program for the hardware.</p> <p>This process is referred to as <code>lowering</code>, which in a general sense is a transformation that takes you from one IR to another where the target IR is specialized or has a smaller syntactical structure. <code>Transpiling</code> corresponds to a transformation that takes you from one language to equivalent expressions in another. For example, we can transpile from the Bloqade AST in Python to the Bloqade AST in Julia. The generic term for both of these types of transformation in Bloqade is Code Generation. You will find various code generation implementations in various <code>codegen</code> modules.</p>"},{"location":"contributing/community-slack/","title":"Community Slack","text":"<p>You can join QuEra's Slack workspace with this link. Join the <code>#bloqade</code> channel to discuss anything related to Bloqade.</p>"},{"location":"contributing/design-philosophy-and-architecture/","title":"Design Philosophy and Architecture","text":"<p>Given the heterogeneous nature of the hardware we target, We have decided to use a compiler-based approach to our software stack, allowing us to target different hardware backends with the same high-level language. Below is a diagram of the software stack in Bloqade.</p> <pre><code>graph TD\n    Builder[\"Builder Representation\"]\n    PythonAST[\"Bloqade AST Python\"]\n    JuliaAST[\"Bloqade AST Julia\"]\n\n    EmulatorPy[\"Emulator IR Python\"]\n    EmulatorJL[\"Emulator IR Julia\"]\n\n    QuEra[\"QuEra IR\"]\n    Braket[\"Braket IR\"]\n    JuliaEmulator[\"Bloqade.jl\"]\n    PythonEmulator[\"Python Emulator\"]\n\n    Aquila[\"Aquila\"]\n\n    Builder --&gt;|parse| PythonAST\n    PythonAST --&gt;|lower| EmulatorPy\n    PythonAST --&gt;|lower| QuEra\n    PythonAST --&gt;|lower| Braket\n    PythonAST --&gt;|transpile| JuliaAST\n\n    QuEra --&gt;|execute| Aquila\n    Braket --&gt;|execute| Aquila\n\n    JuliaAST --&gt;|lower| EmulatorJL\n    EmulatorPy --&gt;|execute| PythonEmulator\n    EmulatorJL --&gt;|execute| JuliaEmulator\n</code></pre>"},{"location":"contributing/design-philosophy-and-architecture/#high-level-builder-representation","title":"High-Level Builder Representation","text":"<p>When programming Bloqade using the Python API, the user constructs a representation of an analog quantum circuit. This representation is a flattened version of the actual analog circuit. Flattened means that the user input is a linear sequence of operations where the context of neighboring nodes in the sequence of instructions can determine the program tree structure. The Bloqade AST describes the actual analog circuit.</p>"},{"location":"contributing/design-philosophy-and-architecture/#bloqade-ast","title":"Bloqade AST","text":"<p>The Bloqade AST is a representation of a quantum analog circuit for neutral atom computing. It is a directed acyclic graph (DAG) with nodes for different hierarchical levels of the circuit. The base node is the <code>AnalogCircuit</code> which contains the geometry of the atoms stored as a <code>AtomArragment</code> or <code>ParallelRegister</code> objects. The other part of the circuit is the <code>Sequence</code>, which contains the waveforms that describe the drives for the Ryberg/Hyperfine transitions of each Rydberg atom. Each transition is represented by a <code>Pulse</code> including a <code>Field</code> for the drive's detuning, Rabi amplitude, and Rabi phase . A <code>Field</code> relates the spatial and temporal dependence of a drive. The spatial modulates the temporal dependence of the waveform. A DAG also describes the <code>Waveform</code> object. Finally, we have basic <code>Scalar</code> expressions as well for describing the syntax of real-valued continuous numbers.</p>"},{"location":"contributing/design-philosophy-and-architecture/#bloqade-compilers-and-transpilers","title":"Bloqade Compilers and Transpilers","text":"<p>Given a user program expressed as the Bloqade AST, we can target various backends by transforming from the Bloqade AST to other kinds of IR. For example, when submitting a task to QuEra's hardware, we transform the Bloqade AST to the IR that describes a valid program for the hardware.</p> <p>This process is referred to as <code>lowering</code>, which in a general sense is a transformation that takes you from one IR to another where the target IR is specialized or has a smaller syntactical structure. <code>Transpiling</code> corresponds to a transformation that takes you from one language to equivalent expressions in another. For example, we can transpile from the Bloqade AST in Python to the Bloqade AST in Julia. The generic term for both of these types of transformation in Bloqade is Code Generation. You will find various code generation implementations in various <code>codegen</code> modules.</p>"},{"location":"contributing/developing-bloqade/","title":"Setting up your Development Environment","text":"<p>Before You Get Started</p> <p>Depending on the complexity of the contribution you'd like to make to Bloqade, it may be worth reading the Design Philosophy and Architecture section to get an idea of why Bloqade is structured the way that it is and how to make your contribution adhere to this philosophy.</p> <p>Our development environment contains a set of tools we use for development, testing, and documentation. This section describes how to set up the development environment. We primarily use pdm to manage python environments and dependencies.</p>"},{"location":"contributing/developing-bloqade/#setting-up-python","title":"Setting up Python","text":"<p>We use pdm to manage dependencies and virtual environment. After cloning the repository, run the following command to install dependencies:</p> <pre><code>pdm install\n</code></pre> <p>You can also install different dependency groups:</p> <ul> <li>dev: dependencies for development</li> </ul> <pre><code>pdm install --dev\n# or\npdm install -d\n</code></pre> <ul> <li>doc: dependencies for building documentation</li> </ul> <pre><code>pdm install -G doc\n</code></pre>"},{"location":"contributing/developing-bloqade/#useful-pdm-scripts","title":"Useful PDM scripts","text":""},{"location":"contributing/developing-bloqade/#tests","title":"Tests","text":"<p>You can run tests via</p> <pre><code>pdm run test\n</code></pre> <p>Or run tests and generate coverage via</p> <pre><code>pdm run coverage\n</code></pre> <p>will print out the coverage file level report in terminal.</p> <pre><code>pdm run coverage-html\n</code></pre> <p>This command generates an interactive html report in <code>htmlcov</code> folder. This will show which specific lines are not covered by tests.</p>"},{"location":"contributing/developing-bloqade/#documentation","title":"Documentation","text":"<p>You can build documentation via</p> <pre><code>pdm run doc_build\n</code></pre> <p>Or run a local server to preview documentation via</p> <pre><code>pdm run doc\n</code></pre>"},{"location":"contributing/developing-bloqade/#jupytext","title":"Jupytext","text":"<p>You can sync jupyter notebooks and python scripts via</p> <pre><code>pdm run jupytext\n</code></pre> <p>this will help you development examples in jupyter notebook and python scripts simultaneously.</p>"},{"location":"contributing/developing-bloqade/#lint","title":"Lint","text":"<p>We primarily use ruff - an extremely fast linter for Python, and black as formatter. These have been configured into pre-commit hooks. After installing pre-commit on your own system, you can install pre-commit hooks to git via</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/documentation-issues/","title":"Reporting a Documentation Issue","text":"<p>We are always looking to improve our documentation. If you find a typo or think something is unclear, please open an issue on our GitHub page: https://github.com/QuEraComputing/bloqade-python/issues</p> <p>For typos or other minor problems, create an issue that contains a link to the specific page that includes the problem, along with a description of the problem and possibly a solution.</p> <p>For a request for new documentation content, please open up an issue and describe what you think is missing from the documentation.</p>"},{"location":"contributing/feature-requests/","title":"Requesting new Features","text":"<p>Given that we are currently at the beginning of the development of the Bloqade python interface, we are open to suggestions about what features would be helpful to include in future package iterations. If you have a request for a new feature, please open an issue on our GitHub page: https://github.com/QuEraComputing/bloqade-python/issues</p> <p>We ask that the feature requests be as specific as possible. Please include the following information in your feature request:</p> <ol> <li> <p>A short, descriptive title.</p> </li> <li> <p>A detailed description of the feature, including your attempt to solve the problem with the current version of Bloqade.</p> </li> <li> <p>A minimal code example that demonstrates the need for the feature.</p> </li> <li> <p>The version of Bloqade you are using.</p> </li> <li> <p>The version of Python you are using.</p> </li> <li> <p>The version of your operating system.</p> </li> </ol>"},{"location":"contributing/providing-feedback/","title":"Providing Feedback","text":"<p>While Github Issues are a great way for us to better understand any issues your having with Bloqade as well as provide us with feature requests, we're always looking for ways to collect more general feedback about what the user experience with Bloqade is like.</p> <p>To do that we have this form where you can provide your thoughts after using/experimenting/tinkering/hacking with Bloqade.</p> <p>Your feedback will help guide the future of Bloqade's design so be honest and know that you're contributing to the future of Quantum Computing with Neutral Atoms!</p>"},{"location":"contributing/reporting-a-bug/","title":"Reporting a Bug","text":"<p>Bloqade is currently in the alpha phase of development, meaning bugs most likely exist in the current implementation. We are continuously striving to improve the stability of Bloqade. As such, we encourage our users to report all bugs they find. To do this, we ask you to submit an issue to our GitHub page: https://github.com/QuEraComputing/bloqade-python/issues</p> <p>Please include the following information in your bug report:</p> <ol> <li> <p>A short, descriptive title.</p> </li> <li> <p>A detailed description of the bug, including the expected behavior and what happened.</p> </li> <li> <p>A minimal code example that reproduces the bug.</p> </li> <li> <p>The version of Bloqade you are using.</p> </li> <li> <p>The version of Python you are using.</p> </li> <li> <p>The version of your operating system.</p> </li> </ol>"},{"location":"drafts/aws_hybrid_execution/","title":"Hybrid Execution with AWS Hybrid Jobs","text":""},{"location":"drafts/aws_hybrid_execution/#introduction","title":"Introduction","text":"<p>Analog Hamiltonian Simulation (AHS) has proven itself to be a powerful method of performing quantum computation that is well-suited for solving optimization problems and performing computationally difficult simulations of other quantum systems. Unlike its counterpart digital/gate-based quantum computing where you think of your programs in terms of unitary operations that are akin to classicla gates, you think of programs in AHS in terms of the geometry of your qubits (individual atoms!) and the waveforms of the lasers that are applied to them.</p> <p>The team at QuEra Computing believes this is a useful step in the path to fault tolerant quantum computation but also realizes that such novel power and capabilities require a novel tool.</p> <p>That's why we're proud to announce the release of the Bloqade SDK for Python! We've had the opportunity to obtain valuable feedback from the community and leveraged our unique position as the only provider of publicly cloud-accessible Nuetral Atom hardware to produce a tool that puts the power of AHS hardware at your fingertips.</p>"},{"location":"drafts/aws_hybrid_execution/#installation","title":"Installation","text":"<p>Bloqade is a pure Python library so installation is as easy as <code>pip install bloqade</code>! Once installed you have a variety of options for building your Nuetral atom Analog program. We have worked very hard to provide a seamless user experience when venturing into unfamiliar territory of AHS with Nuetral Atoms! Let\u2019s dig into some of the major features Bloqade has to offer!</p>"},{"location":"drafts/aws_hybrid_execution/#features-of-bloqade","title":"Features of Bloqade","text":""},{"location":"drafts/aws_hybrid_execution/#just-in-time-documentation","title":"Just-in-time Documentation","text":"<p>I know you have probably spent a pretty penny on your multi-monitor setup so that you do not have to switch between windows when writing code and looking at documentation. What if I told you there was a better way? What if your code contained all the documentation you needed to continue writing your program? That\u2019s exactly what we have designed in the user experinence (UX) of Bloqade.</p> <p>Typically when building an AHS program one needs to construct many different objects and combine them in very particular ways which are not obvious without understanding the concept as a whole. Bloqade provides a unique experience programming AHS. Our interface eases the user into AHS programming by using Python\u2019s rich type-hinting system.  Most IDE's, as well as IPython and Jupyter, use the type hints to access to the methods and attributes that are availible to whatever object you currently have. We use this hinting to our advantage in Bloqade by building your AHS program with a chain of methods and attributes separated by <code>.</code>. In doing so you will be given hints as to what to do next at every step of the way when building your program.</p> <p></p> <p>While it is conventional thinking that it is bad to chain <code>.</code> statements together, there are some well known libraries like Pandas that can and do make heavy use of this pattern of programming. The dot-chaining syntax also integrate python linters like black to make your code highly readable without having to do anything other can call the linter on your python file.</p> <p>Example, before linter some unstrctured code  After running black we get consistent formatting.  In this case properties are always chained which makes reading the code a lot like reading a sentence.</p> <p>On top of these nice features, If you\u2019re in an IDE like VS code or PyCharm you can access the documentation of each method and attribute in which we provide even more hints for the next step after your current selection</p> <p></p> <p>Here is a blog post that goes into the advantages and disadvantages of chaining method calls/attributes like we have shown. It worth a read if you are still a bit skeptical! It's worth noting that you do not neccesarily have to chain method/attribute calls you can safely store a intermediate parts of program with intermediate objects because calling a method does not act in the object in-place. This means you can</p>"},{"location":"drafts/aws_hybrid_execution/#parameterized-programs","title":"Parameterized Programs","text":"<p>keep title capitalization consistent [name=jzlong]</p> <p>Many near-term applications for QC as well as AHS require some notion of parameterized programs. We\u2019ve made this a first-class feature in Bloqade enabling you to write a single AHS program precisely to define your experiment or algorithm symbolically enabling more readable and sharable code!</p> <p>You can also create stand-alone variables which have a basic symbolic representation that support some arithmetic operations that are useful for more advanced AHS applications. For example, say I have a piecewise linear pulse that has variable segments but I have another constant waveform running for the total time of the other waveform. I can sum the durations of each segment of the piecewise linear waveform to get the total duration and use that to construct the constant waveform.</p> <pre><code>from bloqade import var, start\n\nrabi_durations = [0.1, var(\"run_time\"), 0.1]\ntotal_time = sum(rabi_durations)\n\nprogram = (\n    start.add_position((0, 0))\n    .rydberg.detuning.uniform.constant(total_time, \"detuning\")\n    .amplitude.uniform.piecewise_linear(\n        rabi_durations, [0, \"amplitude\",  \"amplitude\",  0]\n    )\n)\n</code></pre> <p>Once you have defined your parameterized program there are three different methods of specifying the run time values of the parameters:</p> <pre><code>program.assign(var1=value1, var2=value2)\n</code></pre> <p>which assigns the variables in a static way. The basic logic here is for segments of program in which you want to share without limiting other users to use the concrete values you decided works for you.</p> <p><pre><code>program.batch_assign(var1=[value1_1, value1_2, \u2026],\u2026)\n</code></pre> or</p> <pre><code>program.batch_assign([dict(var1=value1_1,\u2026), dict(var1=value1_2,\u2026),\u2026])\n</code></pre> <p>specify a batch of tasks via parameters assigned to lists or a list of dictionaries with the assigned parameters. Next,</p> <pre><code>args([\u201cvar1\u201d, \u201cvar2\u201d])\n</code></pre> <p>will delay the assignment of the variable until the program is being executed. We will discuss this below in more detail.</p> <p>Note that none of these methods are required for non-parameterized programs. For parameterized programs you can mix and match all of these assignments together. However, they will always come in the order of <code>assign</code>, <code>batch_assign</code> then <code>args</code>. let's take the program above to give a concrete example.</p> <p>After specifying the program we can do the following assignment:</p> <pre><code>assigned_program = (\n    program.assign(amplitude=15.7)\n    .batch_assign(run_time=np.linspace(0.05, 3.0, 101))\n    .args([\"detuning\"])\n)\n</code></pre> <p>First we assign the amplitude to a value of 15.7 which is going to be non-changing regardless of the other changing parameters in execution. Because we assign \u2018run_time\u2019 using <code>batch_assign</code> that means every time we execute this program we will run 101 tasks with the parameter sweep defined by the list of values. Finally <code>args([\u201cdetuning\u201d])</code> implies that you must provide the value of the detuning as an argument when calling the execution method of the device. This is primarily useful for hybrid work flows or if you are simply just wanting to split your experiments into chunks defined by a different set of parameters. In conclusion, whether it is a hybrid algorithm or a parameter scan for your next fancy experiment Bloqade has you covered!</p>"},{"location":"drafts/aws_hybrid_execution/#visualization-tools","title":"Visualization Tools","text":"<p>While having a clean, readable syntax is great, there is always going to be the need for more visual representations. This is especially true for AHS programming where you think about things in terms of waveforms and atom configurations. As such, we provide visualization of your programs using <code>Bokeh</code>. Bokeh allows for very clean responsive interactive plots which we have implemented not only for AHS programs but AHS results as well!</p> <p></p> <p></p> <p>We also provide some visualization of your AHS program in the terminal:</p> <pre><code>In [1]: from bloqade import start\n   ...:\n   ...: program = (\n   ...:     start.add_position((0, 0))\n   ...:     .add_position((0, \"r\"))\n   ...:     .rydberg.detuning.uniform.piecewise_linear([0.1, 1.2, 0.1], [-20, -20, 20, 20])\n   ...:     .amplitude.uniform.piecewise_linear([0.1, 1.2, 0.1], [0, 15, 15, 0])\n   ...:     .args([\"r\"])\n   ...: )\n\nIn [2]: program.parse_circuit()\nOut[2]:\nAnalogCircuit\n\u251c\u2500 register\n\u2502  \u21d2 AtomArrangement\n\u2502    \u251c\u2500 Location: filled\n\u2502    \u2502  \u251c\u2500 x\n\u2502    \u2502  \u2502  \u21d2 Literal: 0\n\u2502    \u2502  \u2514\u2500 y\n\u2502    \u2502     \u21d2 Literal: 0\n\u2502    \u2514\u2500 Location: filled\n\u2502       \u251c\u2500 x\n\u2502       \u2502  \u21d2 Literal: 0\n\u2502       \u2514\u2500 y\n\u2502          \u21d2 Variable: r\n\u2514\u2500 sequence\n   \u21d2 Sequence\n     \u2514\u2500 RydbergLevelCoupling\n        \u21d2 Pulse\n          \u251c\u2500 Detuning\n          \u2502  \u21d2 Field\n          \u2502    \u2514\u2500 Drive\n          \u2502       \u251c\u2500 modulation\n          \u2502       \u2502  \u21d2 UniformModulation\n          \u2502       \u2514\u2500 waveform\n          \u2502          \u21d2 Append\n          \u2502            \u251c\u2500 Linear\n          \u2502            \u2502  \u251c\u2500 start\n          \u2502            \u2502  \u2502  \u21d2 Literal: -20\n          \u2502            \u2502  \u251c\u2500 stop\n          \u2502            \u2502  \u2502  \u21d2 Literal: -20\n          \u2502            \u2502  \u2514\u2500 duration\n          \u2502            \u2502     \u21d2 Literal: 0.1\n          \u2502            \u251c\u2500 Linear\n          \u2502            \u2502  \u251c\u2500 start\n          \u2502            \u2502  \u2502  \u21d2 Literal: -20\n          \u2502            \u2502  \u251c\u2500 stop\n          \u2502            \u2502  \u2502  \u21d2 Literal: 20\n          \u2502            \u2502  \u2514\u2500 duration\n          \u2502            \u2502     \u21d2 Literal: 1.2\n          \u2502            \u2514\u2500 Linear\n          \u2502               \u251c\u2500 start\n          \u2502               \u2502  \u21d2 Literal: 20\n          \u2502               \u251c\u2500 stop\n          \u2502               \u2502  \u21d2 Literal: 20\n          \u2502               \u2514\u2500 duration\n          \u2502                  \u21d2 Literal: 0.1\n          \u2514\u2500 RabiFrequencyAmplitude\n             \u21d2 Field\n               \u2514\u2500 Drive\n                  \u251c\u2500 modulation\n                  \u2502  \u21d2 UniformModulation\n                  \u2514\u2500 waveform\n                     \u21d2 Append\n                       \u251c\u2500 Linear\n                       \u2502  \u251c\u2500 start\n                       \u2502  \u2502  \u21d2 Literal: 0\n                       \u2502  \u251c\u2500 stop\n                       \u2502  \u2502  \u21d2 Literal: 15\n                       \u2502  \u2514\u2500 duration\n                       \u2502     \u21d2 Literal: 0.1\n                       \u251c\u2500 Linear\n                       \u2502  \u251c\u2500 start\n                       \u2502  \u2502  \u21d2 Literal: 15\n                       \u2502  \u251c\u2500 stop\n                       \u2502  \u2502  \u21d2 Literal: 15\n                       \u2502  \u2514\u2500 duration\n                       \u2502     \u21d2 Literal: 1.2\n                       \u2514\u2500 Linear\n                          \u251c\u2500 start\n                          \u2502  \u21d2 Literal: 15\n                          \u251c\u2500 stop\n                          \u2502  \u21d2 Literal: 0\n                          \u2514\u2500 duration\n                             \u21d2 Literal: 0.1\n</code></pre>"},{"location":"drafts/aws_hybrid_execution/#bloqade-emulator","title":"Bloqade Emulator","text":"<p>Anyone familiar with QuEra\u2019s Julia SDK Bloqade.jl knows that we\u2019re pretty obsessed with performance. We would also be remiss to advertise Bloqade\u2019s pure python emulator. While not as fast as Bloqade.jl, we have have worked to optimize our the state-vector simulator to get the most out of python as possible.  The emulator supports both two and three level atom configurations, along with global and local driving and support for the blockade subspace (for those who are more familiar with Rydberg atoms). The blockade subspace and matrix calculations are nearly optimal for both memory and time and are written in pure NumPy and SciPy. We also have basic Numba JIT compiled sparse operations that further optimize the memory when solving the time-dependent Schr\u00f6dinger equation. We hope our python emulator will allow you to explore a wide variety of applications for neutral atoms and prototype some neat new algorithms with AHS.</p> <p>Capitalize Bloqade across the entire article [name=jzlong]</p>"},{"location":"drafts/aws_hybrid_execution/#target-multiple-backends","title":"Target Multiple Backends","text":"<p>All Bloqade programs can be targeted to multiple emulation and hardware backends very easily, again using the chaining of <code>.</code>\u2019s. Also note that the chaining syntax allows Bloqade to let you know exactly when a program should be able to be run. To select <code>braket</code> as your service simply select the <code>braket</code> attribute of your program. At this stage there will be two methods availible for you, <code>aquila</code> and <code>local_emulator</code>.</p> <p>I personally prefer to distinguish between methods and attributes by putting the <code>()</code> after a method name and omitting them for attributes [name=jzlong]</p> <p>Each backend has different restrictions in terms of the types of AHS programs that can be run. During the alpha phase of Bloqade we will continue to improve the error messages that are given when targeting specific backends making it easy for you to diagnose any issues with your program execution.</p> <p>Depending on the backend there are two or three methods for executing your program. For Cloud devices Bloqade has an API for both asynchronous (<code>run_async</code>) and synchronous (<code>run</code>) method for executing the job. Local emulator backends only support the <code>run</code> API.</p> <p>Now let us revisit the meaning of <code>args</code> assignment. Every execution method has a <code>args</code> argument, this is where you can specify the values of the parameters defined in <code>args</code>  when defining your program. The order of the arguments in the <code>args</code> tuple is the order of the variables specified in the <code>args</code> method.</p> <p>a vs an? [name=jzlong]</p> <p>Finally the backend object that gets created is also callable where the such that <code>object(*args, shots=shots,...)</code> is equivalent to <code>object.run(shots, args=args, ...)</code>. While this is primarily a stylistic choice but this is an available interface for you if need be.</p> <p>\"where the such that\" -&gt; \"such that\" \"While this is primarily a stylistic choice but this is an available\" -&gt; \"While this is primarily a stylicstic choice, this is also an available interface for you if need be\" [name=jzlong]</p>"},{"location":"drafts/aws_hybrid_execution/#job-management-features","title":"Job management Features","text":"<p>If you use the <code>batch_assign</code> API combined with your parameterized program it is possible to submit entire batches of AWS tasks. It's not enough to make programming AHS easy though; you also need to manage all the data that gets generated. Fear not, we have you covered. We know it can be quite cumbersome to have to manage hundreds or thousands of tasks so we have provided some useful functionality inside Bloqade to make your life easier as well as making experiments more reproducible.</p> <p>Fear not, we have you covered! (worth adding an exclamation mark just to go the full nine yards with the chippy/enthusiastic tone). [name=jzlong]</p> <p>One of the most common issues when running AHS (or just QC in general) is saving experimental results. When using a cloud device one also has the added difficultly of associating a task id with the parameter in the parameter scan as well as checking and fetching the task results as the tasks are completed. Bloqade provides a uniform format of saving this data which is useful for users to do sharable and reproducable work. To save your results simply invoke the <code>save</code> and <code>load</code> functions. We also provide <code>dumps</code> and <code>loads</code> if you want to work directly with strings instead of JSON files! It's as simple as:</p> <p>capitalize ID [name=jzlong]</p> <pre><code>from bloqade import save, load\n\n# define program\n...\n\nbatch_task = my_program.braket.aquila().run_async(100)\n\nsave(batch_task, \u201cmy_aquila_results.json\u201d)\n\n# in some other file:\n\nloaded_batch_task = load(\u201cmy_aquila_results.json\u201d)\n\n# continue with analysis\n...\n</code></pre> <p>These objects will contain all the necessary information to fetch results and obtain the values of parameters used in your program.</p> <p>Saving files isn\u2019t all that Bloqade offers. When dealing with a Cloud device like Aquila it is important to be able to manage those asynchronous tasks. Bloqade offers different ways to do this:</p> <p>\"...isn't all that Bloqade offers.\" -&gt; \"..isn't all that Bloqade offers to make your life easier.\"</p> <ul> <li> <p><code>batch_task.fetch()</code> queries the current task statuses and fetches the results of completed tasks without blocking the python interpreter. The results are stored inside the current object.</p> </li> <li> <p><code>batch_task.pull()</code> Like fetch but waits until all tasks have been completed before unblocking the interpreter. The tasks the results are stored inside the current object.</p> </li> <li> <p><code>batch_task.get_tasks(*status_codes)</code> returns a new Batch object that contains the tasks with the status given by the inputs to the function</p> </li> <li> <p><code>batch_task.remove_tasks(*status_codes)</code> return a new Batch object that contains tasks that did not match the status code that have been given.</p> </li> </ul> <p>See the documentation for more details on what the various status codes are and what they mean.</p>"},{"location":"drafts/aws_hybrid_execution/#adaptive-workloads","title":"Adaptive workloads","text":"<p>As mentioned above, the ability to parameterize and assign values to your analog program means that there is a lot one can do in terms of running various kinds of experiments. Here we will discuss how to combine the parameterized pulses with braket\u2019s hybrid jobs!</p> <p>In this case we can pass our parameterized pulse program into classical optimizer in order to provide classical feedback for the next quantum program to run. The use case we will cover here is a pretty standard problem that maps very neatly onto the AHS architecture implemented with Neutral atoms. Because of the Rydberg blockade effect the ground state of a collection of atoms maps exactly to what is called the Maximum Independent Set (MIS) problem on geometric graphs. The MIS problem is a graph coloring problem where the goal is to find the largest set of nodes in a graph such that no two nodes are connected by an edge. This problem is NP-hard and has many applications in scheduling, resource allocation, and even quantum error correction.</p> <p>I also think it better to use the term \"Combinatorial Optimization\" over \"Graph Coloring\" considering CO might open a broader window in people's minds for what the machine is capable of than just \"Graph Coloring\". It would also be nice to have links to examples for each application (MIS for scheduling, resource allocation, QEC.)</p> <p>We refer the reader to this Notebook example for a more detailed explanation of the problem and how it maps onto AHS. For this blog post we will focus on the implementation of the hybrid algorithm using Bloqade and Braket Hybrid Jobs.</p> <p>Like most of the Bloqade programs we begin by importing the necessary components to build the program:</p> <pre><code>import numpy as np\nfrom bloqade import RB_C6, save, start, var\nfrom bloqade.atom_arrangement import Square\nfrom braket.devices import Devices\nfrom braket.aws import AwsDevice\n</code></pre> <p>using the <code>AwsDevice</code> we can get some information about the capabilities of the device. Note that Bloqade uses <code>rad/us</code> and <code>us</code> for energy and time units respectively while braket uses SI unites, e.g. <code>rad/s</code> and <code>s</code>, hence the conversion of units below.</p> <pre><code># define the parameters of the experiment\ndevice = AwsDevice(Devices.QuEra.Aquila)\nrydberg_properties = device.properties.paradigm.rydberg.rydbergGlobal\n\n# Convert energy units to rad/us and time to us\ndetuning_max = float(rydberg_properties.detuningRange[1]) / 1e6\nrabi_max = float(rydberg_properties.rabiFrequencyRange[1]) / 1e6\ntotal_time = float(rydberg_properties.timeMax) * 1e6\n</code></pre> <p>For the particular problem we are studying we need to map the problem graph onto the atom arrangement. For more information we refer the reader to the notebook example.</p> <pre><code># make sure next nearest neighbors are blockaded\nRmin = np.sqrt(2) # minimum unit disk radius\nRmax = 2  # maximum unit disk radius\nRudg = np.sqrt(Rmin * Rmax) # geometric mean of Rmin and Rmax\n\ndetuning_end = detuning_max / 4 # detuning at the end of the pulse\nblockade_radius = (RB_C6 / detuning_end) ** (1 / 6)\nlattice_spacing = blockade_radius / Rudg\n</code></pre> <p>Now we can define the program. We will use the <code>var</code> function to define the parameters for the program. Also the cost function will involve calculating the final energy of tha atoms which can be obtained from the geometry of the program via the <code>rydberg_interaction</code> method.</p> <pre><code># define the time step for the detuning waveform\ndt = 0.4\nn_steps = int(total_time / dt)\n# create variables for the detuning time steps\ndetuning_vars = [var(f\"d{i}\") for i in range(n_steps - 1)]\n\n# define the lattice size before defect insertion\nL = 4\n# set seed for defect generation\nrng = np.random.default_rng(1337)\n# define the geometry of the program\ngeometry = (\n    Square(L, lattice_spacing)\n    .apply_defect_count(L**2 // 2, rng=rng)\n    .remove_vacant_sites()\n)\n# define the program\nprogram = (\n    geometry.rydberg.detuning.uniform.piecewise_linear(\n        n_steps * [dt], [-detuning_end] + detuning_vars + [detuning_end]\n    )\n    .amplitude.uniform.piecewise_linear(\n        [0.1, total_time - 0.2, 0.1], [0, rabi_max, rabi_max, 0]\n    )\n)\n# get the interaction matrix\nV_ij = geometry.interaction_matrix()\n</code></pre> <p>We need to build the infrastructure to do the hybrid job. There are many different tools availible in <code>braket.jobs</code> that allow you to log the progress of your hybrid algorithm. Here we set up a simple class that wraps the cost function and log the progress of the algorithm.</p> <pre><code>from braket.jobs import (\n    InstanceConfig,\n    hybrid_job,\n    save_job_checkpoint,\n)\nfrom braket.jobs.metrics import log_metric\nfrom braket.jobs_data import PersistedJobDataFormat\nfrom braket.tracking import Tracker\n\n# define a wrapper for the cost function for reporting\nclass CostFuncWrapper:\n    def __init__(self, backend, shots=10, **options):\n        self.backend = backend\n        self.options = options\n        self.iterations = 0\n        self.shots = shots\n        self.prev_calls = {}\n        self.task_tracker = Tracker().start()\n\n    @staticmethod\n    def cost_func(report):\n        bitstrings = 1 - np.asarray(report.bitstrings(False))\n        detuning_energies = -detuning_end * bitstrings.sum(axis=-1)\n        interaction_energies = np.einsum(\n            \"ij, ...i, ...j-&gt; ...\", V_ij, bitstrings, bitstrings\n        )\n\n        total_energy = detuning_energies + interaction_energies\n        # minimize the energy mean and standard deviation\n        return total_energy.mean() + total_energy.std()\n\n    def __call__(self, x):\n        args = tuple(x)\n\n        batch_task = self.backend.run(self.shots, args=args, **self.options)\n        report = batch_task.report()\n\n        save(batch_task, f\"my-aquila_results-{self.iterations}.json\")\n\n        self.prev_calls[args] = report\n        return self.cost_func(report)\n\n    def callback(self, state):\n        args = tuple(state.x)\n        self.iterations += 1\n        bitstrings = 1 - np.asarray(self.prev_calls[args].bitstrings(False))\n        detuning_energies = -detuning_end * bitstrings.sum(axis=-1)\n\n        interaction_energies = np.einsum(\n            \"ij, ...i, ...j-&gt; ...\", V_ij, bitstrings, bitstrings\n        )\n\n        total_energy = detuning_energies + interaction_energies\n        mean_energy = total_energy.mean()\n        std_energy = total_energy.std()\n\n        # Log metrics to display in Braket Console\n        log_metric(\n            iteration_number=self.iterations, value=state.fun, metric_name=\"loss\"\n        )\n        log_metric(\n            iteration_number=self.iterations,\n            value=mean_energy,\n            metric_name=\"mean energy\",\n        )\n        log_metric(\n            iteration_number=self.iterations,\n            value=std_energy,\n            metric_name=\"std energy\",\n        )\n\n        # Also track the quantum task cost for Braket devices\n        braket_task_cost = float(\n            self.task_tracker.qpu_tasks_cost()\n            + self.task_tracker.simulator_tasks_cost()\n        )\n        log_metric(\n            metric_name=\"braket_cost\",\n            value=braket_task_cost,\n            iteration_number=self.iterations,\n        )\n\n        # Save a checkpoint to resume the hybrid job from where you left off\n        checkpoint_data = {\"i\": self.iterations, \"args\": args}\n        save_job_checkpoint(\n            checkpoint_data, data_format=PersistedJobDataFormat.PICKLED_V4\n        )\n        # end the job if the std energy is less than 5% of the mean energy\n        # this indicates that the system is close to the ground state\n        return abs(std_energy / mean_energy) &lt; 0.05\n</code></pre> <p>While this is a lot to take in let us go through some important things. Firstly, you can generate a <code>Report</code> object from a Bloqade batch of tasks. This object provides some basic analysis methods common to Neutral atom AHS computing. The one we make the most use of here is the <code>bitstrings</code> method which return a list of arrays that contains the shot results after executing the program. It takes a boolean argument that specifies whether or not to return the bitstrings of shots where there were atoms that did not get put into a trap before the computation was executed. By default this filter is applied, but for this problem we want to include those shots in our analysis hence the <code>False</code> argument.</p> <p>No need to capitalize \"Batch\" unless you want to refer to the object type You can just say AHS, AHS Computing seems redundant Do we assume users know what a trap is? Might be worth having a sentence or two, just say something like \"It takes a boolean argument that specifies whether or not to return the bitstrings of shots where there were atoms that did not successfully get put into position...\"</p> <p>Another thing to note is that our cost function not only contains the <code>mean</code> energy but also the standard deviation. The reason for this is because we are targeting an eigenstate of the final Hamiltonian which has no energy variance. This is a good way to check if the system is in the ground state. We use the ratio of the standard deviation to the mean energy as a stopping condition for the algorithm.</p> <p>Finally, we have a callback function that is called after each iteration of the optimizer. This is where we can log the progress of the algorithm. We use the <code>Tracker</code> object to track the cost of the quantum tasks that are being executed. We also use the <code>log_metric</code> function to log the mean and standard deviation of the energy as well as the cost function of the quantum tasks.</p> <p>Now we can define the function that will run the hybrid job.</p> <pre><code>def run_algo(assigned_program, device_arn=None, n_calls=10, shots=10):\n    @hybrid_job(\n        device=device_arn,  # Which device to get priority access to\n        dependencies=\"requirements.txt\",  # install bloqade\n        instance_config=InstanceConfig(\"ml.m5.large\"),\n    )\n    def _runner(backend, shots, n_calls, **options):\n        from skopt import gp_minimize\n\n        # Braket task cost\n        wrapped_cost_func = CostFuncWrapper(backend, shots=shots, **options)\n\n        n_params = len(backend.params.args_list)\n        bounds = n_params * [(-detuning_max, detuning_max)]\n\n        result = gp_minimize(\n            wrapped_cost_func,\n            bounds,\n            callback=wrapped_cost_func.callback,\n            n_calls=n_calls,\n        )\n\n        detuning_values = {var.name: val for var, val in zip(detuning_vars, result.x)}\n\n        return detuning_values\n\n    if device_arn == Devices.QuEra.Aquila:  # use Aquila\n        backend = assigned_program.braket.aquila()\n        options = dict()\n    else:  # use  bloqade emulator\n        backend = assigned_program.bloqade.python()\n        options = dict(atol=1e-8, rtol=1e-4, solver_name=\"dopri5\")\n\n    # Run the hybrid job\n    return _runner(backend, n_calls, shots, **options)\n</code></pre> <p>We use the <code>hybrid_job</code> decorator to define the hybrid job. This decorator takes a <code>device_arn</code> argument which is the Amazon Resource Name (ARN) of the device you want to run the hybrid job on. There are some other options associated with the EC2 instance that is used to run the hybrid job. We will use the <code>InstanceConfig</code> object to specify the instance type and number of instances to use. <code>dependencies</code> points to a text file that contains the python dependencies needed to run this hybrid job. In this case we need <code>bloqade</code> and <code>scikit-optimize</code> in this text file.</p> <p>The function <code>_runner</code> that is being decorated must take the <code>backend</code> as the first argument. This object is generated by the Bloqade API and must match the device arn that is specified in the decorator. <code>n_calls</code> is the total number of iterations of the optimizer and <code>shots</code> is the number of shots to use for each iteration. <code>options</code> is a dictionary of options that are passed to the <code>run</code> method of the backend. The return value of the function is the final value of the parameters that were optimized. We wrap the <code>_runner</code> inside <code>run_algo</code> that takes the <code>program</code> and the <code>device_arn</code> as arguments to make sure that the device requested by <code>hybrid_jobs</code> matches the device called by <code>bloqade</code> as well as setting up specialized <code>options</code> for the different <code>bloqade</code> backends.</p> <p>To run the hybrid job we simply call the <code>run_algo</code> function with the assigned program and the device arn.</p> <pre><code>optimal_parameters = run_algo(program.args(detuning_vars), device_arn=Devices.QuEra.Aquila)\n</code></pre> <p>Finally we can plot the results of the hybrid job.</p> <pre><code>assigned_program = program.assign(**optimal_params)\nassigned_program.show()\n</code></pre> <p>To run the algorithm with Bloqade emulator we simply change the device arn to None.</p> <p>Full source code:</p> <p>```python= import numpy as np from bloqade import RB_C6, save, start, var from bloqade.atom_arrangement import Square from braket.devices import Devices from braket.aws import AwsDevice</p>"},{"location":"drafts/aws_hybrid_execution/#define-the-parameters-of-the-experiment","title":"define the parameters of the experiment","text":"<p>device = AwsDevice(Devices.QuEra.Aquila) rydberg_properties = device.properties.paradigm.rydberg.rydbergGlobal</p>"},{"location":"drafts/aws_hybrid_execution/#convert-energy-units-to-radus-and-time-to-us","title":"Convert energy units to rad/us and time to us","text":"<p>detuning_max = float(rydberg_properties.detuningRange[1]) / 1e6 rabi_max = float(rydberg_properties.rabiFrequencyRange[1]) / 1e6 total_time = float(rydberg_properties.timeMax) * 1e6</p>"},{"location":"drafts/aws_hybrid_execution/#make-sure-next-nearest-neighbors-are-blockaded","title":"make sure next nearest neighbors are blockaded","text":""},{"location":"drafts/aws_hybrid_execution/#unit-disk-minimum-and-maximum-radii","title":"unit disk minimum and maximum radii","text":"<p>Rmin = np.sqrt(2)  # minimum unit disk radius Rmax = 2  # maximum unit disk radius</p>"},{"location":"drafts/aws_hybrid_execution/#choose-geometric-mean-of-rmin-and-rmax","title":"choose geometric mean of Rmin and Rmax","text":"<p>Rudg = np.sqrt(Rmin * Rmax)</p> <p>detuning_end = detuning_max / 4 blockade_radius = (RB_C6 / detuning_end) ** (1 / 6) lattice_spacing = blockade_radius / Rudg</p>"},{"location":"drafts/aws_hybrid_execution/#define-the-time-step-for-the-detuning-waveform","title":"define the time step for the detuning waveform","text":"<p>dt = 0.4 n_steps = int(total_time / dt)</p>"},{"location":"drafts/aws_hybrid_execution/#create-variables-for-the-detuning-time-steps","title":"create variables for the detuning time steps","text":"<p>detuning_vars = [var(f\"d{i}\") for i in range(n_steps - 1)]</p>"},{"location":"drafts/aws_hybrid_execution/#define-the-lattice-size-before-defect-insertion","title":"define the lattice size before defect insertion","text":"<p>L = 4</p>"},{"location":"drafts/aws_hybrid_execution/#set-seed-for-geometry-generation","title":"set seed for geometry generation","text":"<p>rng = np.random.default_rng(1337) program = (     Square(L, lattice_spacing)     .apply_defect_count(L**2 // 2, rng=rng)     .remove_vacant_sites()     .rydberg.detuning.uniform.piecewise_linear(         n_steps * [dt], [-detuning_end] + detuning_vars + [detuning_end]     )     .amplitude.uniform.piecewise_linear(         [0.1, total_time - 0.2, 0.1], [0, rabi_max, rabi_max, 0]     ) )</p>"},{"location":"drafts/aws_hybrid_execution/#get-atom-register-and-interaction-matrix","title":"get atom register and interaction matrix","text":"<p>V_ij = program.parse_register().rydberg_interaction()</p> <p>from braket.jobs import (     InstanceConfig,     hybrid_job,     save_job_checkpoint, ) from braket.jobs.metrics import log_metric from braket.jobs_data import PersistedJobDataFormat from braket.tracking import Tracker</p>"},{"location":"drafts/aws_hybrid_execution/#define-a-wrapper-for-the-cost-function-for-reporting","title":"define a wrapper for the cost function for reporting","text":"<p>class CostFuncWrapper:     def init(self, cost_func, backend, shots=10, **options):         self.backend = backend         self.options = options         self.iterations = 0         self.shots = shots         self.prev_calls = {}         self.task_tracker = Tracker().start()</p> <pre><code>@staticmethod\ndef cost_func(report):\n    bitstrings = 1 - np.asarray(report.bitstrings(False))\n    detuning_energies = -detuning_end * bitstrings.sum(axis=-1)\n    interaction_energies = np.einsum(\n        \"ij, ...i, ...j-&gt; ...\", V_ij, bitstrings, bitstrings\n    )\n\n    total_energy = detuning_energies + interaction_energies\n    # minimize the energy mean and standard deviation\n    return total_energy.mean() + total_energy.std()\n\ndef __call__(self, x):\n    args = tuple(x)\n\n    batch_task = self.backend.run(self.shots, args=args, **self.options)\n    report = batch_task.report()\n\n    save(batch_task, f\"my-aquila_results-{self.iterations}.json\")\n\n    self.prev_calls[args] = report\n    return self.cost_func(report)\n\ndef callback(self, state):\n    args = tuple(state.x)\n    self.iterations += 1\n    bitstrings = 1 - np.asarray(self.prev_calls[args].bitstrings(False))\n    detuning_energies = -detuning_end * bitstrings.sum(axis=-1)\n\n    interaction_energies = np.einsum(\n        \"ij, ...i, ...j-&gt; ...\", V_ij, bitstrings, bitstrings\n    )\n\n    total_energy = detuning_energies + interaction_energies\n    mean_energy = total_energy.mean()\n    std_energy = total_energy.std()\n\n    # Log metrics to display in Braket Console\n    log_metric(\n        iteration_number=self.iterations, value=state.fun, metric_name=\"loss\"\n    )\n    log_metric(\n        iteration_number=self.iterations,\n        value=mean_energy,\n        metric_name=\"mean energy\",\n    )\n    log_metric(\n        iteration_number=self.iterations,\n        value=std_energy,\n        metric_name=\"std energy\",\n    )\n\n    # Also track the quantum task cost for Braket devices\n    braket_task_cost = float(\n        self.task_tracker.qpu_tasks_cost()\n        + self.task_tracker.simulator_tasks_cost()\n    )\n    log_metric(\n        metric_name=\"braket_cost\",\n        value=braket_task_cost,\n        iteration_number=self.iterations,\n    )\n\n    # Save a checkpoint to resume the hybrid job from where you left off\n    checkpoint_data = {\"i\": self.iterations, \"args\": args}\n    save_job_checkpoint(\n        checkpoint_data, data_format=PersistedJobDataFormat.PICKLED_V4\n    )\n    # end the job if the std energy is less than 5% of the mean energy\n    # this indicates that the system is close to the ground state\n    return abs(std_energy / mean_energy) &lt; 0.05\n</code></pre> <p>def run_algo(assigned_program, device_arn=None, n_calls=10, shots=10):     @hybrid_job(         device=device_arn,  # Which device to get priority access to         dependencies=\"requirements.txt\",  # install bloqade         instance_config=InstanceConfig(\"ml.m5.large\"),     )     def _runner(backend, shots, n_calls, **options):         from skopt import gp_minimize</p> <pre><code>    # Braket task cost\n    wrapped_cost_func = CostFuncWrapper(backend, shots=shots, **options)\n\n    n_params = len(backend.params.args_list)\n    bounds = n_params * [(-detuning_max, detuning_max)]\n\n    result = gp_minimize(\n        wrapped_cost_func,\n        bounds,\n        callback=wrapped_cost_func.callback,\n        n_calls=n_calls,\n    )\n\n    detuning_values = {var.name: val for var, val in zip(detuning_vars, result.x)}\n\n    return detuning_values\n\nif device_arn == Devices.QuEra.Aquila:  # use Aquila\n    backend = assigned_program.braket.aquila()\n    options = dict()\nelse:  # use  bloqade emulator\n    backend = assigned_program.bloqade.python()\n    options = dict(atol=1e-8, rtol=1e-4, solver_name=\"dopri5\")\n\n# Run the hybrid job\nreturn _runner(backend, n_calls, shots, **options)\n</code></pre>"},{"location":"drafts/aws_hybrid_execution/#optimal_params-run_algoprogramargsdetuning_vars-devicesqueraaquila","title":"optimal_params = run_algo(program.args(detuning_vars), Devices.QuEra.Aquila)","text":"<p>optimal_params = run_algo(program.args(detuning_vars), None, n_calls=10, shots=10)</p> <p>assigned_program = program.assign(**optimal_params) assigned_program.show()</p> <p>```</p>"},{"location":"home/background/","title":"Background","text":""},{"location":"home/background/#neutral-atom-qubits","title":"Neutral Atom Qubits","text":"<p>The qubits that QuEra's neutral atom computer Aquila and Bloqade are designed to emulate are based on neutral atoms. As the name implies they are atoms that are neutrally charged but are also capable of achieving a Rydberg state where a single electron can be excited to an incredibly high energy level without ionizing the atom.</p> <p>This incredibly excited electron energy level \\(|r\\rangle\\) and its default ground state \\(|g\\rangle\\) create a two-level system where superposition can occur. For enabling interaction between two or more qubits and achieving entanglement, when the neutral atoms are in the Rydberg state a phenomenon known as the Rydberg blockade can occur where an atom in the Rydberg state prevents a neighboring atom from also being excited to the same state.</p> <p>For a more nuanced and in-depth read about the neutral atoms that Bloqade and Aquila use, refer to QuEra's qBook section on Qubits by puffing up atoms.</p>"},{"location":"home/background/#analog-vs-digital-quantum-computing","title":"Analog vs Digital Quantum Computing","text":"<p>There are two modes of quantum computation that neutral atoms are capable of: Analog and Digital. </p> <p>You can find a brief explanation of the distinction below but for a more in-depth explanation you can refer to QuEra's qBook section on Analog vs Digital Quantum Computing</p>"},{"location":"home/background/#analog-mode","title":"Analog Mode","text":"<p>In the analog mode (supported by Bloqade and Aquila) you control your computation through the parameters of a time-dependent Hamiltonian that influences all the qubits at once. There are options for local control of the Hamiltonian on certain qubits however.</p>"},{"location":"home/background/#digital-mode","title":"Digital Mode","text":"<p>In the Digital Mode individual or multiple groups of qubits are controlled by applying gates (individual unitary operations). For neutral atoms, this digital mode can be accomplished with the introduction of hyperfine coupling, enabling a quantum state to be stored for long periods of time while also allowing for multi-qubit gates.</p>"},{"location":"home/background/#rydberg-many-body-hamiltonian","title":"Rydberg Many-Body Hamiltonian","text":"<p>When you emulate a program in Bloqade, you are emulating the time evolution of the Rydberg many-body Hamiltonian which looks like this:</p> \\[ i \\hbar \\dfrac{\\partial}{\\partial t} | \\psi \\rangle = \\hat{\\mathcal{H}}(t) | \\psi \\rangle,  \\\\ \\] \\[ \\frac{\\mathcal{H}(t)}{\\hbar} = \\sum_j \\frac{\\Omega_j(t)}{2} \\left( e^{i \\phi_j(t) } | g_j \\rangle  \\langle r_j | + e^{-i \\phi_j(t) } | r_j \\rangle  \\langle g_j | \\right) - \\sum_j \\Delta_j(t) \\hat{n}_j + \\sum_{j &lt; k} V_{jk} \\hat{n}_j \\hat{n}_k, \\] <p>where: \\(\\Omega_j\\), \\(\\phi_j\\), and \\(\\Delta_j\\) denote the Rabi frequency amplitude, laser phase, and the detuning of the driving laser field on atom (qubit) \\(j\\) coupling the two states  \\(| g_j \\rangle\\) (ground state) and \\(| r_j \\rangle\\) (Rydberg state); \\(\\hat{n}_j = |r_j\\rangle \\langle r_j|\\) is the number operator, and \\(V_{jk} = C_6/|\\mathbf{x}_j - \\mathbf{x}_k|^6\\) describes the Rydberg interaction (van der Waals interaction) between atoms \\(j\\) and \\(k\\) where \\(\\mathbf{x}_j\\) denotes the position of the atom \\(j\\); \\(C_6\\) is the Rydberg interaction constant that depends on the particular Rydberg state used. For Bloqade, the default \\(C_6 = 862690 \\times 2\\pi \\text{ MHz \u03bcm}^6\\) for \\(|r \\rangle = \\lvert 70S_{1/2} \\rangle\\) of the \\(^{87}\\)Rb atoms; \\(\\hbar\\) is the reduced Planck's constant.</p>"},{"location":"home/background/#local-control","title":"Local Control","text":"<p>The Rydberg Many-Body Hamiltonian already implies from its subscripts that you can also have local control over your atoms. In Bloqade this local control extends to any term in the Hamiltonian while on Aquila this is currently restricted to the \\(\\Delta_j\\) laser detuning term.</p> <p>Fields in Bloqade give you local (single-atom) control over the many-body Rydberg Hamiltonian.</p> <p>They are a sum of one or more spatial modulations, which allows you to scale the amplitude of the waveform across the different sites in the system:</p> \\[ F_{i}(t) = \\sum_{\\alpha} C_{i}^{\\alpha}f_{\\alpha}(t)  \\] \\[ C_{i}^{\\alpha} \\in \\mathbb{R}  \\] \\[ f_{\\alpha}(t) \\colon \\mathbb{R} \\to \\mathbb{R} \\] <p>The \\(i\\)-th component of the field is used to generate the drive at the \\(i\\)-th site.</p> <p>Note that the drive is only applied if the \\(i\\)-th site is filled with an atom.</p> <p>You build fields in Bloqade by first specifying the spatial modulation followed by the waveform it should be multiplied by.</p> <p>In the case of a uniform spatial modulation, it can be interpreted as  a constant scaling factor where \\(C_{i}^{\\alpha} = 1.0\\).</p>"},{"location":"home/emulation/","title":"Emulation","text":"<p>This page is a work in progress!</p>"},{"location":"home/geometry/","title":"Geometry","text":"<p>This page is a work in progress!</p>"},{"location":"home/gotchas/","title":"Bloqade Gotchas: Common Mistakes in Using Bloqade","text":"<p>It is tempting when coming from different quantum SDKs and frameworks to apply the same pattern of thought to Bloqade. However, a lot of practices from those prior tools end up being anti-patterns in Bloqade. While you can use those patterns and they can still work, it ends up causing you the developer to write unnecessarily verbose, complex, and hard-to-read code as well as preventing you from reaping the full benefits of what Bloqade has to offer.</p> <p>This page is dedicated to cataloguing those anti-patterns and what you can do instead to maximize the benefit Bloqade can offer you.</p>"},{"location":"home/gotchas/#redefining-lattices-and-common-atom-arrangements","title":"Redefining Lattices and Common Atom Arrangements","text":"<p>You might be tempted to define lattice-based geometries through the following means:</p> <pre><code>from bloqade import start\n\nspacing = 4.0\ngeometry = start.add_positions(\n    [(i * spacing, j * spacing) for i in range(4) for j in range(4)]\n)\n</code></pre> <p>This is quite redundant and verbose, especially considering Bloqade offers a large number of pre-defined lattices you can customize the spacing of in <code>bloqade.atom_arrangement</code>. In the code above, we're just defining a 4x4 square lattice of atoms with 4.0 micrometers of spacing between them. This can be expressed as follows</p> <pre><code>from bloqade.atom_arrangement import Square\n\nspacing = 4.0\ngeometry = Square(4, lattice_spacing = spacing)\n</code></pre>"},{"location":"home/gotchas/#copying-a-program-to-create-new-ones","title":"Copying a Program to create New Ones","text":"<p>Many gate-based SDKs rely on having a mutable object representing your circuit. This means if you want to build on top of some base circuit without mutating it, you have to copy it:</p> <pre><code>import copy\n\nbase_circuit = qubits.x(0)....\n# make copy of base circuit\ncustom_circuit_1 = copy(base_circuit)\n# build on top of copy of base circuit\ncustom_circuit_1.x(0).z(5)...\n# create a new circuit by copying the base again\ncustom_circuit_2 = copy(base_circuit)\n# build on top of that copy again\ncustom_circuit_2.y(5).cz(0,2)...\n</code></pre> <p>In Bloqade Python this is unnecessary because at every step of your program an immutable object is returned which means you can save it and not have to worry about mutating any internal state.</p> <pre><code>from bloqade import start\nbase_program = start.add_position((0,0)).rydberg.rabi.amplitude.uniform\n# Just recycle your base program! No `copy` needed!\nnew_program_1 = base_program.constant(duration=5.0, value=5.0)\nnew_program_2 = base_program.piecewise_linear(\n    durations=[5.0], values = [0.0, 5.0]\n)\n</code></pre>"},{"location":"home/gotchas/#creating-new-programs-instead-of-using-batch_assign","title":"Creating New Programs Instead of Using <code>.batch_assign</code>","text":"<p>If you have a set of parameters you'd like to test your program on versus a single parameter, don't generate a new program for each value:</p> <pre><code>rabi_values = [2.0, 4.7, 6.1]\nprograms_with_different_rabi_values = []\n\nfor rabi_value in rabi_values:\n    program = start.add_position((0, 0)).rydberg.rabi.amplitude.uniform.constant(\n        duration=5.0, value=rabi_value\n    )\n    programs_with_different_rabi_values.append(program)\n\nresults = []\n\nfor program in programs_with_different_rabi_values:\n    result = program.bloqade.python().run(100)\n    results.append(result)\n</code></pre> <p>Instead take advantage of the fact Bloqade has facilities specifically designed to make trying out multiple values in your program without needing to make individual copies via <code>.batch_assign</code>. The results are also automatically handled for you so each value you test has its own set of results, but all collected in a singular dataframe versus the above where you'd have to keep track of individual results.</p> <pre><code>rabi_values = [2.0, 4.7, 6.1]\n# place a variable for the Rabi Value and then batch assign values to it\nprogram_with_rabi_values = start.add_position(\n    0, 0\n).rydberg.rabi.amplitude.uniform.constant(duration=5.0, value=\"rabi_value\")\nprogram_with_assignments = program_with_rabi_values.batch_assign(\n    rabi_value=rabi_values\n)\n\n# get your results in one dataframe versus having to keep track of a\n# bunch of individual programs and their individual results\nbatch = program_with_assignments.bloqade.python().run(100)\nresults_dataframe = batch.report().dataframe\n</code></pre>"},{"location":"home/quick_start/","title":"Quick Start","text":"<p>All the sections below are self-contained, you can click on the links in the Table of Contents to read the relevant parts. </p>"},{"location":"home/quick_start/#navigating-the-bloqade-api","title":"Navigating the Bloqade API","text":"<p>As you develop your Bloqade program, you are expected to rely on pop-up \"hints\" provided in your development environment to help you determine what the next part of your program should be.</p>"},{"location":"home/quick_start/#vs-code","title":"VS Code","text":"<p>In VS Code this is automatic, just type the <code>.</code> and see what options pop up:</p>"},{"location":"home/quick_start/#jetbrains-pycharm","title":"JetBrains PyCharm","text":"<p>The same goes for JetBrains PyCharm:</p>"},{"location":"home/quick_start/#jupyter-notebook","title":"Jupyter Notebook","text":"<p>In a Jupyter Notebook you'll need to type <code>.</code> and then hit tab for the hints to appear:</p>"},{"location":"home/quick_start/#ipython","title":"IPython","text":"<p>The same goes for IPython:</p>"},{"location":"home/quick_start/#defining-atom-geometry","title":"Defining Atom Geometry","text":"<p>You can import pre-defined geometries based on Bravais lattices from <code>bloqade.atom_arrangement</code>. You may also specify a lattice spacing which dictates the spacing between the atoms as well as the number of atom sites in a certain direction.</p> <pre><code>from bloqade.atom_arrangement import Square, Kagome\n\nsimple_geometry = Square(2, 4, lattice_spacing = 4.0)\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\n</code></pre> <p>You can easily visualize your geometries as well with <code>.show()</code>:</p> <pre><code>more_complex_geometry.show()\n</code></pre> <p>You can also add positions to a pre-defined geometry:</p> <pre><code>from bloqade.atom_arrangement import Square\n\nbase_geometry = Square(2)\ngeometry_with_my_positions = base_geometry.add_position([(10,10), (20,20)])\n</code></pre> <p>As well as apply defects via <code>.apply_defect_density</code>. In the example below we apply a defect with a probability of 0.2:</p> <pre><code>from bloqade.atom_arrangement import Square, Kagome\n\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\ndefective_geometry = more_complex_geometry.apply_defect_density(0.2)\n</code></pre> <p>Or if you want to completely roll out your own atom geometry from scratch just use <code>add_position</code> by itself:</p> <pre><code>from bloqade import start\n\nmy_geometry = start.add_position([(1,2), (3,4), (5,6)])\n</code></pre>"},{"location":"home/quick_start/#building-waveforms","title":"Building Waveforms","text":"<p>After you've defined a geometry you:</p> <ul> <li>Specify which level coupling to drive: <code>rydberg</code> or <code>hyperfine</code></li> <li>Specify <code>detuning</code>, <code>rabi.amplitude</code> or <code>rabi.phase</code></li> <li>Specify the spatial modulation</li> </ul> <p>Which then leads you to the ability to specify a waveform of interest and begin constructing your pulse sequence.  In the example below, we target the ground-Rydberg level coupling to drive with uniform spatial modulation for the Rabi amplitude. Our waveform is a piecewise linear one which ramps from \\(0\\) to \\(5 \\,\\text{rad/us}\\), holds that value for \\(1 \\,\\text{us}\\) and then ramps back down to \\(0 \\,\\text{rad/us}\\).</p> <pre><code>from bloqade import start\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nwaveform_applied = (\n    target_rabi_amplitude\n    .piecewise_linear(durations = [0.06, 1, 0.06], values = [0, 5, 5, 0])\n)\n</code></pre> <p>You aren't restricted to just piecewise linear waveforms however, you can also specify:</p> <ul> <li><code>linear</code> - Define a transition from one value to another over a duration</li> <li><code>constant</code> - Define a fixed value over a duration</li> <li><code>piecewise_constant</code> - Define a step-wise function with specific durations for each step</li> <li><code>poly</code> - Define a polynomial waveform using coefficients over a duration</li> </ul>"},{"location":"home/quick_start/#arbitrary-functions-as-waveforms","title":"Arbitrary Functions as Waveforms","text":"<p>For more complex waveforms it may provide to be tedious trying to chain together a large number of <code>piecewise_constant</code> or <code>piecewise_linear</code> methods and instead easier to just define the waveform as a function of time.</p> <p>Bloqade lets you easily plug in an arbitrary function with <code>.fn</code>:</p> <pre><code>from bloqade import start\nfrom math import sin\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\n\ndef custom_waveform(t): \n    return 2.0 * sin(t)\n\ncustom_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n)\n</code></pre> <p>In this form you can immediately emulate it if you'd like but to run this on hardware you need to discretize it. The waveform on hardware has to either be: </p> <ul> <li>Piecewise linear for Rabi amplitude and detuning terms of the Hamiltonian</li> <li>Piecewise constant for the Phase term of the Hamiltonian</li> </ul> <p>Bloqade can automatically perform this conversion with <code>sample()</code>, all you need to do is specify the kind of interpolation and the size of the discretization step in time. Below we set the step duration to be \\(0.05 \\,\\text{us}\\) with <code>\"linear\"</code> interpolation to give us a resulting piecewise linear waveform.</p> <pre><code>custom_discretized_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n    .sample(0.05, \"linear\")\n)\n</code></pre> <p>Note</p> <p>Programs that have custom functions as waveforms are not fully serializable. This means that when you are saving and reloading results, the original embedded program will be missing that custom waveform. You will still be able to analyze the saved results! </p>"},{"location":"home/quick_start/#slicing-and-recording-waveforms","title":"Slicing and Recording Waveforms","text":"<p>When you conduct parameter sweeps with your program, you may want to sweep over your program across  time. This will require \"slicing\" your waveforms, where you define the waveform of interest and then, using a variable with <code>.slice</code>, indicate the times at which the waveform duration should be cut short.</p> <p>In the example below we define a simple piecewise linear waveform but slice it starting from a time duration of \\(0 \\,\\text{us}\\) to values between \\(1\\) to \\(2 \\,\\text{us}\\).</p> <pre><code>from bloqade import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre> <p>This program will run fine in emulation but due to hardware constraints certain waveforms (such as those targeting the Rabi Amplitude), the waveform needs to start and end at \\(0 \\,\\text{rad}/\\text{us}\\). Thus, there needs to be a way to slice our waveform but also add an end component to that waveform. <code>.record</code> in Bloqade lets you literally \"record\" the value at the end of a <code>.slice</code> and then use it to construct further parts of the waveform.</p> <p>In the program below the waveform is still sliced but with the help of <code>.record</code> a linear segment that pulls the waveform down to \\(0.0 \\,\\text{rad}/\\text{us}\\) from whatever its current value at the slice is in \\(0.7 \\,\\text{us}\\) is added. </p> <pre><code>from bloqade import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n    .record(\"waveform_value\")\n    .linear(\"rabi_value\", 0.0, 0.7)\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre>"},{"location":"home/quick_start/#waveforms-with-no-geometry","title":"Waveforms with No Geometry","text":"<p>If you have multiple atom geometries you'd like to apply a pulse sequence to or you simply don't want to worry about what atom geometry to start with, you can just build straight off of <code>start</code>:</p> <pre><code>from bloqade import start\n\npulse_sequence = (\n    start\n    .rydberg.rabi.amplitude.uniform\n    .constant(value=1.0, duration=1.0)\n    .parse_sequence()\n)\n</code></pre> <p>You can visualize your sequence as well with <code>.show()</code>:</p> <pre><code>pulse_sequence.show()\n</code></pre> <p></p> <p>And when you're content with it you just <code>.apply()</code> it on the geometries of your choice:</p> <pre><code>from bloqade.atom_arrangement import Honeycomb, Kagome \n\ngeometry_1 = Honeycomb(2, lattice_spacing = 6.0)\ngeometry_2 = Kagome(2, lattice_spacing = 6.0)\n\nprogram_1  = geometry_1.apply(pulse_sequence)\nprogram_2  = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"home/quick_start/#emulation","title":"Emulation","text":"<p>When you've completed the definition of your program you can use Bloqade's own emulator to get results. The emulation performs the time evolution of the analog Rydberg Hamiltonian. Here we say we want to the program to be run and measurements obtained 1000 times.</p> <pre><code>results = your_program.bloqade.python().run(1000)\n</code></pre> <p>Note</p> <p>If your atoms are particularly close together or the ODE solver gives you the following message:</p> <pre><code>RuntimeError: DOP853/DOPRI5: Problem is probably stiff (interrupted).\n</code></pre> <p>In which case you will need to specify the <code>interaction_picture=True</code> argument:</p> <pre><code>results = your_program.bloqade.python().run(1000, interaction_picture=True)\n</code></pre>"},{"location":"home/quick_start/#submitting-to-hardware","title":"Submitting to Hardware","text":"<p>To submit your program to hardware ensure you have your AWS Braket credentials loaded. You will need to use the AWS CLI to do this.</p> <p>Then it's just a matter of selecting the Aquila on Braket backend. Before going any further Bloqade provides two options for running your program on actual hardware:</p> <ul> <li>Using <code>.run</code> is blocking, meaning you will not be able to execute anything else while Bloqade waits for results</li> <li>Using <code>.run_async</code> lets you submit to hardware and continue any further execution, while also letting you query the status of your program in the queue.</li> </ul> <p>In the example below we use <code>.run_async</code> to specify the program should be run and measurements obtained 1000 times.</p> <pre><code>async_results = your_program.braket.aquila().run_async(1000)\n</code></pre> <p>We can see the status of our program via:</p> <p><pre><code>async_results.fetch()\n</code></pre> Which gives us the Task ID, a unique identifier for the task as well as the status of the task. In the example below the task is <code>Enqueued</code> meaning it has been successfully created and is awaiting execution on the cloud. When the task is actually running on hardware, the status will change to <code>Running</code>. <pre><code>                                             task ID    status  shots\n0  arn:aws:braket:us-east-1:XXXXXXXXXXXX:quantum-...  Enqueued    100\n</code></pre></p>"},{"location":"home/quick_start/#analyzing-results","title":"Analyzing Results","text":"<p>When you've retrieved your results from either emulation or hardware you can generate a <code>.report()</code>:</p> <pre><code>report = results.report()\n</code></pre> <p>For the examples below we analyze the results of a two atom program.</p> <p>The report contains useful information such as:</p> <ul> <li> <p>The raw bitstrings measured per each execution of the program <pre><code>report.bitstrings()\n</code></pre> <pre><code>[array([[1, 1],\n        [1, 1],\n        [1, 1],\n        ...,\n        [1, 1],\n        [1, 1],\n        [1, 0]], dtype=int8)]\n</code></pre></p> </li> <li> <p>The number of times each unique bitstring occurred: <pre><code>report.counts()\n</code></pre> <pre><code>[OrderedDict([('11', 892), ('10', 59), ('01', 49)])]\n</code></pre></p> </li> <li> <p>The Rydberg Density for each atom <pre><code>report.rydberg_densities()\n</code></pre> <pre><code>                 0      1\ntask_number              \n0            0.053  0.054\n</code></pre></p> </li> </ul> <p>And can also provide useful visual information such as the state of your atoms and the bitstring distribution via:</p> <pre><code>report.show()\n</code></pre> <p></p>"},{"location":"home/quick_start/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>You can easily do parameter sweeps in emulation and on Aquila with variables. Bloqade automatically detects strings in your program as variables that you can later assign singular or multiple values to. </p> <p>In the example below, we define a program with a singular variable that controls the amplitude of the waveform.</p> <pre><code>from bloqade import start\n\nrabi_oscillations_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.06, 3, 0.06], \n        values=[0, \"rabi_amplitude\", \"rabi_amplitude\", 0]\n    )\n)\n</code></pre> <p>We can assign a single fixed value to the variable:</p> <pre><code>single_value_assignment = rabi_oscillations_program.assign(rabi_amplitude=3.5)\n</code></pre> <p>Or, to perform a sweep, we use <code>.batch_assign</code>:</p> <pre><code>import numpy as np\nrabi_amplitudes = np.linspace(1.0, 2.0, 20)\n\nmultiple_value_assignment = rabi_oscillations_program.batch_assign(rabi_amplitude=rabi_amplitudes)\n</code></pre> <p>This will actually create multiple versions of the program internally, with each program assigned a fixed value from the sweep. Bloqade will automatically handle the compilation of results from these multiple programs in order, meaning there is no major departure from what you saw in analyzing the results of your program.</p> <p>You can also delay assignment of a value to a variable by first declaring it in <code>.args()</code> and then passing a value when you call <code>run</code>:</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\nresults = delayed_assignment_program.bloqade.python().run(100, args=(1.0,))\n</code></pre> <p>You can alternatively treat the program as a callable after using <code>.args()</code> (note the inverted order of arguments in the call!): </p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\ncallable_program = delayed_assignment_program.bloqade.python()\nresults = callable_program(1.0, shots=100)\n</code></pre> <p>Variables aren't just restricted to having values assigned to them, you can also symbolically manipulate them!</p>"},{"location":"home/quick_start/#symbolic-parameters","title":"Symbolic Parameters","text":"<p>Variables in Bloqade can also be symbolically manipulated, giving you even more flexibility when you construct your program.</p> <p>In the example below, we externally declare a variable <code>my_var</code> that then has some arithmetic done on it to allow it to have a different value in a later part of the program:</p> <pre><code>from bloqade import start, var\n\nmy_var = var(\"my_variable\")\nwaveform_durations = [0.6, 1.0, 0.6]\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=waveform_durations, \n                      values=[0.0, my_var, my_var, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .piecewise_linear(durations=waveform_durations, \n                      values=[my_var-1.0, my_var*0.5, my_var/2, my_var+1.0 ])\n)\n</code></pre> <p>You still perform variable assignment just like you normally would: </p> <pre><code>program = detuning_waveform.assign(my_variable=1.0)\n</code></pre> <p>You can also use Python's built-in <code>sum</code> if you want the sum of multiple variables as a value in your program. This is quite useful when it comes to needing to indicate a full duration for a waveform that doesn't need to be split up:</p> <p><pre><code>from bloqade import start, var\n\nvariable_durations = var([\"a\", \"b\", \"c\"])\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=variable_durations, \n                      values=[0.0, 1.5, 1.5, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .constant(duration=sum(variable_durations),\n              value=16.2)\n)\n</code></pre> We later assign values and Bloqade will automatically handle the summation:</p> <pre><code>program = detuning_waveform.assign(a=0.5, b=1.2, c=0.5)\n</code></pre>"},{"location":"home/quick_start/#saving-and-loading-results","title":"Saving and Loading Results","text":"<p>You can save your results in JSON format using Bloqade's <code>save</code> function:</p> <pre><code>from bloqade import start, save\n\nyour_program = ...\nemulation_results = your_program.bloqade.python().run(100)\nhardware_results = your_program.braket.aquila.run_async(100)\n\nsave(emulation_results, \"emulation_results.json\") \nsave(hardware_results, \"hardware_results.json\") \n</code></pre> <p>And later reload them into Python using the <code>load</code> function:</p> <pre><code>from bloqade import load\nemulation_results = load(\"emulation_results.json\")\nhardware_results = load(\"hardware_results.json\")\n</code></pre>"},{"location":"home/submission/","title":"Submission","text":"<p>This page is a work in progress!</p>"},{"location":"home/visualization/","title":"Visualization","text":"<p>This page is a work in progress!</p>"},{"location":"home/waveforms/","title":"Waveforms","text":"<p>This page is a work in progress!</p>"},{"location":"reference/hardware-capabilities/","title":"Hardware Capabilities","text":"<p>During program development, it can be quite handy to know what true hardware capabilities are and incorporate that information programmaticaly. Bloqade offers the ability to do this via <code>get_capabilities()</code>.</p>"},{"location":"reference/hardware-capabilities/#programmatic-access","title":"Programmatic Access","text":"<p><code>get_capabilities()</code> (importable directly from <code>bloqade</code>) returns a <code>QuEraCapabilities</code> object. This object contains all the hardware constraints in <code>Decimal</code> format for the Aquila machine, our publically-accessible QPU on AWS Braket.</p> <p>An example of using <code>get_capabilities()</code> is presented below:</p> <pre><code>from bloqade import get_capabilities, piecewise_linear\n\n# get capabilities for Aquila\naquila_capabilities = get_capabilities()\n\n# obtain maximum Rabi frequency as Decimal\nmax_rabi = aquila_capabilities.capabilities.rydberg.global_.rabi_frequency_max\n\n# use that value in constructing a neat Rabi waveform\nrabi_wf = piecewise_linear(durations = [0.5, 1.0, 0.5], values = [0, max_rabi, max_rabi, 0])\n</code></pre> <p>The attribute names for each value have been provided below but will require you to provide the proper prefix like in the example above (e.g. the maximum number of qubits lives under the <code>number_qubits_max</code> attribute which can be navigated to via <code>*your_QuEra_Capabilities_Object*.lattice.number_qubits_max</code>).</p>"},{"location":"reference/hardware-capabilities/#aquila-capabilities","title":"Aquila Capabilities","text":""},{"location":"reference/hardware-capabilities/#task","title":"Task","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.task</code> for:<ul> <li>minimum number of shots</li> <li>maximum number of shots</li> </ul> </li> </ul> Capability Attribute Value Minimum Number of Shots <code>number_shots_min</code> 1 Maximum Number of Shots <code>number_shots_max</code> 1000"},{"location":"reference/hardware-capabilities/#lattice-geometry","title":"Lattice Geometry","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.lattice</code> for:<ul> <li>maximum number of qubits</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.lattice.area</code> for:<ul> <li>maximum lattice area width</li> <li>maximum lattice area height</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.lattice.geometry</code> for:<ul> <li>maximum number of sites</li> <li>position resolution</li> <li>minimum radial spacing</li> <li>minimum vertical spacing</li> </ul> </li> </ul> Capability Attribute Value Maximum Number of Qubits <code>number_qubits_max</code> 256 Maximum Lattice Area Width <code>width</code> 75.0 \u00b5m Maximum Lattice Area Height <code>height</code> 76.0 \u00b5m Minimum Radial Spacing between Qubits <code>spacing_radial_min</code> 4.0 \u00b5m Minimum Vertical Spacing between Qubits <code>spacing_vertical_min</code> 4.0 \u00b5m Position Resolution <code>position_resolution</code> 0.1 \u00b5m Maximum Number of Sites <code>number_sites_max</code> 256"},{"location":"reference/hardware-capabilities/#global-rydberg-values","title":"Global Rydberg Values","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg</code> for:<ul> <li>C6 Coefficient</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg.global_</code> for:<ul> <li>Everything else related to global (applied to all atom) capabilities</li> </ul> </li> </ul> Capability Attribute Value Rydberg Interaction Constant <code>c6_coefficient</code> 5.42\u00d710\u2076 rad/\u03bcs \u00d7 \u00b5m\u2076 Minimum Rabi Frequency <code>rabi_frequency_min</code> 0.00 rad/\u03bcs Maximum Rabi Frequency <code>rabi_frequency_max</code> 15.8 rad/\u03bcs Rabi Frequency Resolution <code>rabi_frequency_resolution</code> 0.0004 rad/\u03bcs Maximum Rabi Frequency Slew Rate <code>rabi_frequency_slew_rate_max</code> 250.0 rad/\u00b5s\u00b2 Minimum Detuning <code>detuning_min</code> -125.0 rad/\u03bcs Maximum Detuning <code>detuning_max</code> 125.0 rad/\u03bcs Detuning Resolution <code>detuning_resolution</code> 2.0\u00d710\u207b\u2077 rad/\u03bcs Maximum Detuning Slew Rate <code>detuning_slew_rate_max</code> 2500.0 rad/\u00b5s\u00b2 Minimum Phase <code>phase_min</code> -99.0 rad Maximum Phase <code>phase_max</code> 99.0 rad Phase Resolution <code>phase_resolution</code> 5.0\u00d710\u207b\u2077 rad Minimum Time <code>time_min</code> 0.0 \u00b5s Maximum Time <code>time_max</code> 4.0 \u00b5s Time Resolution <code>time_resolution</code> 0.001 \u00b5s Minimum \u0394t <code>time_delta_min</code> 0.05 \u00b5s"},{"location":"reference/hardware-capabilities/#local-detuning-values","title":"Local Detuning Values","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg.local</code> for the following values:</li> </ul> Capability Attribute Value Maximum Detuning <code>detuning_max</code> 125.0 rad/\u03bcs Minimum Detuning <code>detuning_min</code> 0 rad/\u03bcs Maximum Detuning Slew Rate <code>detuning_slew_rate_max</code> 1256.0 rad/\u00b5s\u00b2 Maximum Number of Local Detuning Sites <code>number_local_detuning_sites</code> 200 Maximum Site Coefficient <code>site_coefficient_max</code> 1.0 Minimum Site Coefficient <code>site_ceofficient_min</code> 0.0 Minimum Radial Spacing <code>spacing_radial_min</code> 5 \u00b5m Minimum \u0394t <code>time_delta_min</code> 0.05 \u03bcs Time Resolution <code>time_resolution</code> 0.001 \u00b5s"},{"location":"reference/overview/","title":"Builder Overview","text":"<p>You may have noticed from the Getting Started and Tutorials that Bloqade uses this interesting, dot-intensive syntax.</p> <p><pre><code>from bloqade import start\n\nprog = start.add_position((0,0)).rydberg.rabi.amplitude.uniform.constant(1,1)\n</code></pre> Exhibit A: Lots of Dots</p> <p>In fact, it might look remniscent of what you see in some gate-based Quantum Computing SDKs:</p> <pre><code># this is strictly pseudocode\ncircuit = init_qubits(n_qubits)\n# note the dots!\ncircuit.x(0).z(1).cnot(0, 1)...\n</code></pre> <p>What's the deal with that?</p>"},{"location":"reference/overview/#syntax-motivations","title":"Syntax Motivations","text":"<p>We call this syntax the builder or builder syntax and as its name implies, it is designed to let you build programs for Analog Hamiltonian Simulation hardware as easily and as straightforward as possible.</p> <p>The linear structure implies a natural hierarchy in how you think about targeting the various degrees of freedom (detuning, atom positions, Rabi amplitude, etc.) your program will have. In the beginning you have unrestricted access to all these degrees of freedom but in order to do something useful you need to:</p> <ol> <li>Narrow down and explicitly identify what you want to control</li> <li>Provide the instructions on how you want to control what your focused on</li> </ol> <p>Context is a strong component of the builder syntax, as you are both actively restricted from doing certain things that can introduce ambiguity based on where you are in your program and repeating the same action in different parts of the program yields different results.</p>"},{"location":"reference/overview/#visual-guides","title":"Visual Guides","text":"<p>While we hope the Smart Documentation (the ability to instantly see all your next possible steps and their capabilities in your favorite IDE/IPython) is sufficient to get you where you need to go, we undestand it's particularly beneficial to get a high-level overview of things before diving in.</p> <p>The Standard Representation is a nice flow chart that gives a high-level overview of the different steps and components in the builder syntax.</p>"},{"location":"reference/standard/","title":"Build Workflow","text":"<pre><code>\nflowchart TD\n  ProgramStart([\"start\"])\n\n  Geometry(\"Geometry or Lattice\")\n\n  Coupling[\"Coupling\n  -----------\n  rydberg\n  hyperfine\"]\n\n  Detuning[\"detuning\"]\n  Rabi[\"rabi\"]\n\n  Amplitude[\"amplitude\"]\n  Phase[\"phase\"]\n\n  SpaceModulation(\"SpatialModulation\n  ----------------------\n  uniform\n  scale\n  location\n  \")\n  Waveform{\"Waveform\n  ------------\n  piecewise_linear\n  piecewise_constant\n  constant\n  linear\n  poly\n  fn\n  \"}\n\n  Options([\"Options\n  ---------\n  assign\n  batch_assign\n  args\n  parallelize\n  \"])\n\n  Services([\"Services\n  ----------\n  bloqade\n  quera\n  braket\"])\n\n  QuEraBackends([\"Backends\n  ------------\n  mock\n  cloud_mock\n  aquila\n  device\"])\n\n  BraketBackends([\"Backends\n  ------------\n  aquila\n  local_emulator\"])\n\n  BloqadeBackends([\"Backends\n  ------------\n  python\n  julia\"])\n\n  Execution(\"\n  Execution hardware only\n  -------------------------------\n  run_async()\n\n  Hardware and simulation\n  -------------------------------\n  run()\n  __call__\")\n\n  ProgramStart --&gt;|add_position| Geometry;\n  Geometry --&gt; Coupling;\n  ProgramStart --&gt; Coupling;\n\n  Coupling --&gt; Detuning;\n  Coupling --&gt; Rabi;\n\n  Rabi --&gt; Amplitude;\n  Rabi --&gt; Phase;\n\n  Detuning --&gt; SpaceModulation;\n  Amplitude --&gt; SpaceModulation;\n  Phase --&gt; SpaceModulation;\n\n  SpaceModulation --&gt; Waveform;\n\n  Waveform --&gt; Coupling;\n  Waveform --&gt; Services;\n  Waveform --&gt; Options;\n  Options --&gt; Services;\n\n  Services --&gt;|quera| QuEraBackends;\n  Services --&gt;|braket| BraketBackends;\n  Services --&gt;|bloqade| BloqadeBackends;\n  QuEraBackends --&gt; Execution;\n  BraketBackends --&gt; Execution;\n  BloqadeBackends --&gt; Execution;\n\n  click ProgramStart \"../bloqade/#bloqade.start\";\n  click Geometry \"../bloqade/atom_arrangement/\";\n  click Coupling \"../bloqade/builder/drive/\";\n  click Detuning \"../bloqade/builder/field/#bloqade.builder.field.Detuning\";\n  click Rabi \"../bloqade/builder/field/#bloqade.builder.field.Rabi\";\n  click Amplitude \"../bloqade/builder/field/#bloqade.builder.field.Amplitude\";\n  click Phase \"../bloqade/builder/field/#bloqade.builder.field.Phase\";\n  click SpaceModulation \"../bloqade/builder/spatial/\";\n  click Waveform \"../bloqade/builder/waveform/\";\n  click Options \"../bloqade/builder/pragmas/\";\n  click Services \"../bloqade/builder/backend/\";\n  click QuEraBackends \"../bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute\";\n  click BraketBackends \"../bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute\";\n  click BloqadeBackends \"../bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeBackend\";\n  click Execution \"../bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketRoutine\";\n</code></pre>"},{"location":"reference/bloqade/","title":"Index","text":""},{"location":"reference/bloqade/atom_arrangement/","title":"Atom arrangement","text":""},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement","title":"AtomArrangement","text":"<pre><code>AtomArrangement(parent=None)\n</code></pre> <p>             Bases: <code>ProgramStart</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.add_position","title":"add_position","text":"<pre><code>add_position(position, filling=None)\n</code></pre> <p>Add a position or multiple positions to a pre-existing geometry.</p> <p><code>add_position</code> is capable of accepting: - A single tuple for one atom coordinate: <code>(1.0, 2.5)</code> - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.] - A numpy array of shape (N, 2) where N is the number of atoms</p> <p>You may also intersperse variables anywhere a value may be present.</p> <p>You can also pass in an optional argument which determines the atom \"filling\" (whether or not at a specified coordinate an atom should be present).</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.add_position--usage-example","title":"Usage Example:","text":"<pre><code># single coordinate\n&gt;&gt;&gt; reg = start.add_position((0,0))\n# you may chain add_position calls\n&gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n# you can add variables anywhere a value may be present\n&gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n# and specify your atom fillings\n&gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n[True, False])\n# alternatively you could use one boolean to specify\n# all coordinates should be empty/filled\n&gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n(5.2, 2.2)], False)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def add_position(\n    self,\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[Union[BoolArray, List[bool], bool]] = None,\n) -&gt; \"ListOfLocations\":\n    \"\"\"\n    Add a position or multiple positions to a pre-existing geometry.\n\n    `add_position` is capable of accepting:\n    - A single tuple for one atom coordinate: `(1.0, 2.5)`\n    - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.]\n    - A numpy array of shape (N, 2) where N is the number of atoms\n\n    You may also intersperse variables anywhere a value may be present.\n\n    You can also pass in an optional argument which determines the atom \"filling\"\n    (whether or not at a specified coordinate an atom should be present).\n\n    ### Usage Example:\n    ```\n    # single coordinate\n    &gt;&gt;&gt; reg = start.add_position((0,0))\n    # you may chain add_position calls\n    &gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n    # you can add variables anywhere a value may be present\n    &gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n    # and specify your atom fillings\n    &gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n    [True, False])\n    # alternatively you could use one boolean to specify\n    # all coordinates should be empty/filled\n    &gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n    (5.2, 2.2)], False)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`: to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`: to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    if is_bearable(position, PositionArray) and is_bearable(\n        filling, Optional[BoolArray]\n    ):\n        return self.add_position_ndarray(position, filling)\n    elif is_bearable(position, List[Tuple[ScalarType, ScalarType]]) and is_bearable(\n        filling, Optional[List[bool]]\n    ):\n        return self.add_position_list_tuples(position, filling)\n    elif is_bearable(position, Tuple[ScalarType, ScalarType]) and is_bearable(\n        filling, Optional[bool]\n    ):\n        return self.add_position_single_tupe(position, filling)\n    else:\n        raise TypeError(\"Invalid input types for add_position provided!\")\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.apply_defect_count","title":"apply_defect_count","text":"<pre><code>apply_defect_count(n_defects, rng=np.random.default_rng())\n</code></pre> <p>Drop <code>n_defects</code> atoms from the geometry randomly. Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.apply_defect_count--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n# you may also chain apply_defect_count calls\n&gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n# you can also use apply_defect_count on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>:     to add more positions</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_density(defect_probability)</code>:     to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>:     to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify     Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>:     to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>:     shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_count(\n    self, n_defects: int, rng: np.random.Generator = np.random.default_rng()\n):\n    \"\"\"\n    Drop `n_defects` atoms from the geometry randomly. Internally this occurs\n    by setting certain sites to have a SiteFilling set to false indicating\n    no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n    # you may also chain apply_defect_count calls\n    &gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n    # you can also use apply_defect_count on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n            to add more positions\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_count(n_defects)`: to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_density(defect_probability)`:\n            to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n            to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`: to specify\n            Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n            to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n            shows your geometry in your web browser\n    \"\"\"\n\n    location_list = []\n    for location_info in self.enumerate():\n        location_list.append(location_info)\n\n    filled_sites = []\n\n    for index, location_info in enumerate(location_list):\n        if location_info.filling is SiteFilling.filled:\n            filled_sites.append(index)\n\n    if n_defects &gt;= len(filled_sites):\n        raise ValueError(\n            f\"n_defects {n_defects} must be less than the number of filled sites \"\n            f\"({len(filled_sites)})\"\n        )\n\n    for _ in range(n_defects):\n        index = rng.choice(filled_sites)\n        location_list[index] = LocationInfo.create(\n            location_list[index].position,\n            (False if location_list[index].filling is SiteFilling.filled else True),\n        )\n        filled_sites.remove(index)\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.apply_defect_density","title":"apply_defect_density","text":"<pre><code>apply_defect_density(\n    defect_probability, rng=np.random.default_rng()\n)\n</code></pre> <p>Drop atoms randomly with <code>defect_probability</code> probability (range of 0 to 1). Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.apply_defect_density--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n# you may also chain apply_defect_density calls\n&gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n# you can also use apply_defect_density on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n.apply_defect_density(0.5, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>: to add more positions</li> <li><code>...apply_defect_count(defect_counts).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts) .apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_density(\n    self,\n    defect_probability: float,\n    rng: np.random.Generator = np.random.default_rng(),\n):\n    \"\"\"\n    Drop atoms randomly with `defect_probability` probability (range of 0 to 1).\n    Internally this occurs by setting certain sites to have a SiteFilling\n    set to false indicating no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n    # you may also chain apply_defect_density calls\n    &gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n    # you can also use apply_defect_density on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n    .apply_defect_density(0.5, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n        to add more positions\n        - `...apply_defect_count(defect_counts).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n        .apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n        to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`:\n        to specify Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n        shows your geometry in your web browser\n    \"\"\"\n\n    p = min(1, max(0, defect_probability))\n    location_list = []\n\n    for location_info in self.enumerate():\n        if rng.random() &lt; p:\n            location_list.append(\n                LocationInfo.create(\n                    location_info.position,\n                    (\n                        False\n                        if location_info.filling is SiteFilling.filled\n                        else True\n                    ),\n                )\n            )\n        else:\n            location_list.append(location_info)\n\n    return ListOfLocations(location_list=location_list)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs=fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments)\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.scale","title":"scale","text":"<pre><code>scale(scale)\n</code></pre> <p>Scale the geometry of your atoms.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n# atom positions are now (0,0), (2,2)\n&gt;&gt;&gt; new_reg = reg.scale(2)\n# you may also use scale on pre-defined geometries\n&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n# atoms in the chain will now be 2 um apart versus\n# the default 1 um\n&gt;&gt;&gt; Chain(11).scale(2)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef scale(self, scale: ScalarType):\n    \"\"\"\n    Scale the geometry of your atoms.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n    # atom positions are now (0,0), (2,2)\n    &gt;&gt;&gt; new_reg = reg.scale(2)\n    # you may also use scale on pre-defined geometries\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    # atoms in the chain will now be 2 um apart versus\n    # the default 1 um\n    &gt;&gt;&gt; Chain(11).scale(2)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`:\n        to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    scale = cast(scale)\n    location_list = []\n    for location_info in self.enumerate():\n        x, y = location_info.position\n        new_position = (scale * x, scale * y)\n        location_list.append(\n            LocationInfo.create(new_position, bool(location_info.filling.value))\n        )\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Chain","title":"Chain","text":"<pre><code>Chain(L, *, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, *, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.L = L\n    self.lattice_spacing = cast(lattice_spacing)\n    self.vertical_chain = vertical_chain\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Kagome","title":"Kagome","text":"<pre><code>Kagome(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Lieb","title":"Lieb","text":"<pre><code>Lieb(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width,\n    height,\n    *,\n    lattice_spacing_x=1.0,\n    lattice_spacing_y=1.0\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0,\n):\n    self.width = width\n    self.height = height\n    self.lattice_spacing_x = cast(lattice_spacing_x)\n    self.lattice_spacing_y = (\n        cast(lattice_spacing_y)\n        if lattice_spacing_y is not None\n        else self.lattice_spacing_x\n    )\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Square","title":"Square","text":"<pre><code>Square(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Triangular","title":"Triangular","text":"<pre><code>Triangular(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/constants/","title":"Constants","text":""},{"location":"reference/bloqade/constants/#bloqade.constants.RB_C6","title":"RB_C6  <code>module-attribute</code>","text":"<pre><code>RB_C6 = 2 * pi * 862690\n</code></pre> <p>The C6 constant for the Rydberg Interaction of two Rubidium atoms in units of: rad \u03bcm^6/\u03bcs</p>"},{"location":"reference/bloqade/factory/","title":"Factory","text":""},{"location":"reference/bloqade/factory/#bloqade.factory.constant","title":"constant","text":"<pre><code>constant(duration, value)\n</code></pre> <p>Create a Constant waveform.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>ScalarType</code> <p>Duration of the Constant waveform.</p> required <code>value</code> <code>ScalarType</code> <p>Value of the Constant waveform.s</p> required <p>Returns:</p> Name Type Description <code>Constant</code> <code>Constant</code> <p>A Constant waveform.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef constant(duration: ScalarType, value: ScalarType) -&gt; Constant:\n    \"\"\"Create a Constant waveform.\n\n    Args:\n        duration (ScalarType): Duration of the Constant waveform.\n        value (ScalarType): Value of the Constant waveform.s\n\n    Returns:\n        Constant: A Constant waveform.\n    \"\"\"\n    return Constant(value, duration)\n</code></pre>"},{"location":"reference/bloqade/factory/#bloqade.factory.get_capabilities","title":"get_capabilities","text":"<pre><code>get_capabilities(use_experimental=False)\n</code></pre> <p>Get the device capabilities for Aquila</p> <p>Parameters:</p> Name Type Description Default <code>use_experimental</code> <code>bool</code> <p>Get experimental capabilities instead of standard ones. By default value is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>QuEraCapabilities</code> <code>QuEraCapabilities</code> <p>capabilities object for Aquila device.</p> Note <p>Units of time, distance, and energy are microseconds (us), micrometers (um), and rad / us, respectively.</p> <p>For a comprehensive list of capabilities, see the Hardware Reference page</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>def get_capabilities(use_experimental: bool = False) -&gt; \"QuEraCapabilities\":\n    \"\"\"Get the device capabilities for Aquila\n\n    Args:\n        use_experimental (bool): Get experimental capabilities instead of\n            standard ones. By default value is False.\n\n    Returns:\n        QuEraCapabilities: capabilities object for Aquila device.\n\n\n    Note:\n        Units of time, distance, and energy are microseconds (us),\n        micrometers (um), and rad / us, respectively.\n\n        For a comprehensive list of capabilities,\n        see the [Hardware Reference](../../reference/hardware-capabilities.md)\n        page\n    \"\"\"\n\n    from bloqade.submission.capabilities import get_capabilities\n\n    # manually convert to units\n    return get_capabilities(use_experimental=use_experimental).scale_units(\n        Decimal(\"1e6\"), Decimal(\"1e-6\")\n    )\n</code></pre>"},{"location":"reference/bloqade/factory/#bloqade.factory.linear","title":"linear","text":"<pre><code>linear(duration, start, stop)\n</code></pre> <p>Create a Linear waveform.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>ScalarType</code> <p>Duration of linear waveform</p> required <code>start</code> <code>ScalarType</code> <p>Starting value of linear waveform</p> required <code>stop</code> <code>ScalarType</code> <p>Ending value of linear waveform</p> required <p>Returns:</p> Name Type Description <code>Linear</code> <code>Linear</code> <p>Linear waveform</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef linear(duration: ScalarType, start: ScalarType, stop: ScalarType) -&gt; Linear:\n    \"\"\"Create a Linear waveform.\n\n    Args:\n        duration (ScalarType): Duration of linear waveform\n        start (ScalarType): Starting value of linear waveform\n        stop (ScalarType): Ending value of linear waveform\n\n    Returns:\n        Linear: Linear waveform\n    \"\"\"\n    return Linear(start, stop, duration)\n</code></pre>"},{"location":"reference/bloqade/factory/#bloqade.factory.piecewise_constant","title":"piecewise_constant","text":"<pre><code>piecewise_constant(durations, values)\n</code></pre> <p>Create a piecewise linear waveform.</p> <p>Create a piecewise constant waveform from a list of durations and values. The value <code>duration[i]</code> corresponds to the length of time for the i'th segment with a value of <code>values[i]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The duration of each segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values for each segment</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of <code>values</code> is not the same as the length of</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Waveform</code> <p>The piecewise linear waveform.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef piecewise_constant(\n    durations: List[ScalarType], values: List[ScalarType]\n) -&gt; Waveform:\n    \"\"\"Create a piecewise linear waveform.\n\n    Create a piecewise constant waveform from a list of durations and values. The\n    value `duration[i]` corresponds to the length of time for the i'th segment\n    with a value of `values[i]`.\n\n    Args:\n        durations (List[ScalarType]): The duration of each segment\n        values (List[ScalarType]): The values for each segment\n\n    Raises:\n        ValueError: If the length of `values` is not the same as the length of\n        `durations`.\n\n    Returns:\n        Waveform: The piecewise linear waveform.\n    \"\"\"\n    if len(durations) != len(values):\n        raise ValueError(\n            \"The length of values must be the same as the length of durations\"\n        )\n\n    pwc_wf = None\n    for duration, value in zip(durations, values):\n        if pwc_wf is None:\n            pwc_wf = Constant(value, duration)\n        else:\n            pwc_wf = pwc_wf.append(Constant(value, duration))\n\n    return pwc_wf\n</code></pre>"},{"location":"reference/bloqade/factory/#bloqade.factory.piecewise_linear","title":"piecewise_linear","text":"<pre><code>piecewise_linear(durations, values)\n</code></pre> <p>Create a piecewise linear waveform.</p> <p>Create a piecewise linear waveform from a list of durations and values. The value <code>duration[i]</code> is of the linear segment between <code>values[i]</code> and <code>values[i+1]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The duration of each segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values for each segment</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of <code>values</code> is not one greater than the length of</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Waveform</code> <p>The piecewise linear waveform.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef piecewise_linear(durations: List[ScalarType], values: List[ScalarType]) -&gt; Waveform:\n    \"\"\"Create a piecewise linear waveform.\n\n    Create a piecewise linear waveform from a list of durations and values. The\n    value `duration[i]` is of the linear segment between `values[i]` and `values[i+1]`.\n\n    Args:\n        durations (List[ScalarType]): The duration of each segment\n        values (List[ScalarType]): The values for each segment\n\n    Raises:\n        ValueError: If the length of `values` is not one greater than the length of\n        `durations`.\n\n    Returns:\n        Waveform: The piecewise linear waveform.\n    \"\"\"\n\n    if len(durations) + 1 != len(values):\n        raise ValueError(\n            \"The length of values must be one greater than the length of durations\"\n        )\n\n    pwl_wf = None\n    for duration, start, stop in zip(durations, values[:-1], values[1:]):\n        if pwl_wf is None:\n            pwl_wf = Linear(start, stop, duration)\n        else:\n            pwl_wf = pwl_wf.append(Linear(start, stop, duration))\n\n    return pwl_wf\n</code></pre>"},{"location":"reference/bloqade/factory/#bloqade.factory.rydberg_h","title":"rydberg_h","text":"<pre><code>rydberg_h(\n    atoms_positions,\n    detuning=None,\n    amplitude=None,\n    phase=None,\n    static_params={},\n    batch_params=[],\n    args=[],\n)\n</code></pre> <p>Create a rydberg program with uniform detuning, amplitude, and phase.</p> <p>Parameters:</p> Name Type Description Default <code>atoms_positions</code> <code>Any</code> <p>Description of geometry of atoms in system.</p> required <code>detuning</code> <code>Optional[Waveform]</code> <p>Waveform for detuning. Defaults to None.</p> <code>None</code> <code>amplitude</code> <code>Optional[Waveform]</code> <p>Waveform describing the amplitude of the rabi term. Defaults to None.</p> <code>None</code> <code>phase</code> <code>Optional[Waveform]</code> <p>Waveform describing the phase of rabi term. Defaults to None.</p> <code>None</code> <code>static_params</code> <code>Dict[str, Any]</code> <p>Define static parameters of your program. Defaults to {}.</p> <code>{}</code> <code>batch_params</code> <code>Union[List[Dict[str, Any]], Dict[str, Any]]</code> <p>Parmaters for a batch of tasks. Defaults to [].</p> <code>[]</code> <code>args</code> <code>List[str]</code> <p>List of arguments to leave till runtime. Defaults to [].</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>Routine</code> <code>Routine</code> <p>An object that can be used to dispatch a rydberg program to multiple backends.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef rydberg_h(\n    atoms_positions: Any,\n    detuning: Optional[Waveform] = None,\n    amplitude: Optional[Waveform] = None,\n    phase: Optional[Waveform] = None,\n    static_params: Dict[str, Any] = {},\n    batch_params: Union[List[Dict[str, Any]], Dict[str, Any]] = [],\n    args: List[str] = [],\n) -&gt; Routine:\n    \"\"\"Create a rydberg program with uniform detuning, amplitude, and phase.\n\n    Args:\n        atoms_positions (Any): Description of geometry of atoms in system.\n        detuning (Optional[Waveform], optional): Waveform for detuning.\n            Defaults to None.\n        amplitude (Optional[Waveform], optional): Waveform describing the amplitude of\n            the rabi term. Defaults to None.\n        phase (Optional[Waveform], optional): Waveform describing the phase of rabi\n            term. Defaults to None.\n        static_params (Dict[str, Any], optional): Define static parameters of your\n            program. Defaults to {}.\n        batch_params (Union[List[Dict[str, Any]], Dict[str, Any]], optional):\n            Parmaters for a batch of tasks. Defaults to [].\n        args (List[str], optional): List of arguments to leave till runtime.\n            Defaults to [].\n\n    Returns:\n        Routine: An object that can be used to dispatch a rydberg program to\n            multiple backends.\n    \"\"\"\n    from bloqade import start\n    from bloqade.atom_arrangement import AtomArrangement\n\n    if isinstance(atoms_positions, AtomArrangement):\n        prog = atoms_positions\n    else:\n        prog = start.add_position(atoms_positions)\n\n    if detuning is not None:\n        prog = prog.rydberg.detuning.uniform.apply(detuning)\n\n    if amplitude is not None:\n        prog = prog.amplitude.uniform.apply(amplitude)\n\n    if phase is not None:\n        prog = prog.phase.uniform.apply(phase)\n\n    prog = prog.assign(**static_params)\n\n    if isinstance(batch_params, dict):\n        prog = prog.batch_assign(**batch_params)\n    else:\n        prog = prog.batch_assign(batch_params)\n\n    prog = prog.args(args)\n\n    return prog.parse()\n</code></pre>"},{"location":"reference/bloqade/serialize/","title":"Serialize","text":""},{"location":"reference/bloqade/serialize/#bloqade.serialize.dumps","title":"dumps","text":"<pre><code>dumps(o, use_decimal=True, **json_kwargs)\n</code></pre> <p>Serialize object to string</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dumps</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the serialized object as a string</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef dumps(\n    o: Any,\n    use_decimal: bool = True,\n    **json_kwargs,\n) -&gt; str:\n    \"\"\"Serialize object to string\n\n    Args:\n        o (Any): the object to serialize\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dumps\n\n    Returns:\n        str: the serialized object as a string\n    \"\"\"\n    if not isinstance(o, Serializer.types):\n        raise TypeError(\n            f\"Object of type {type(o)} is not JSON serializable. \"\n            f\"Only {Serializer.types} are supported.\"\n        )\n    return json.dumps(o, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade/serialize/#bloqade.serialize.load","title":"load","text":"<pre><code>load(fp, use_decimal=True, **json_kwargs)\n</code></pre> <p>Load object from file</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.load</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef load(fp: Union[TextIO, str], use_decimal: bool = True, **json_kwargs):\n    \"\"\"Load object from file\n\n    Args:\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.load\n\n    Returns:\n        Any: the deserialized object\n    \"\"\"\n    load_bloqade()\n    if isinstance(fp, str):\n        with open(fp, \"r\") as f:\n            return json.load(\n                f,\n                object_hook=Serializer.object_hook,\n                use_decimal=use_decimal,\n                **json_kwargs,\n            )\n    else:\n        return json.load(\n            fp,\n            object_hook=Serializer.object_hook,\n            use_decimal=use_decimal,\n            **json_kwargs,\n        )\n</code></pre>"},{"location":"reference/bloqade/serialize/#bloqade.serialize.loads","title":"loads","text":"<pre><code>loads(s, use_decimal=True, **json_kwargs)\n</code></pre> <p>Load object from string</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the string to load</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.loads</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef loads(s: str, use_decimal: bool = True, **json_kwargs):\n    \"\"\"Load object from string\n\n    Args:\n        s (str): the string to load\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.loads\n\n    Returns:\n        Any: the deserialized object\n    \"\"\"\n    load_bloqade()\n    return json.loads(\n        s, object_hook=Serializer.object_hook, use_decimal=use_decimal, **json_kwargs\n    )\n</code></pre>"},{"location":"reference/bloqade/serialize/#bloqade.serialize.save","title":"save","text":"<pre><code>save(o, fp, use_decimal=True, **json_kwargs)\n</code></pre> <p>Serialize object to file</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dump</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef save(\n    o: Any,\n    fp: Union[TextIO, str],\n    use_decimal=True,\n    **json_kwargs,\n) -&gt; None:\n    \"\"\"Serialize object to file\n\n    Args:\n        o (Any): the object to serialize\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dump\n\n    Returns:\n        None\n    \"\"\"\n    if not isinstance(o, Serializer.types):\n        raise TypeError(\n            f\"Object of type {type(o)} is not JSON serializable. \"\n            f\"Only {Serializer.types} are supported.\"\n        )\n    if isinstance(fp, str):\n        with open(fp, \"w\") as f:\n            json.dump(o, f, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n    else:\n        json.dump(o, fp, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade/builder/","title":"Index","text":""},{"location":"reference/bloqade/builder/args/","title":"Args","text":""},{"location":"reference/bloqade/builder/assign/","title":"Assign","text":""},{"location":"reference/bloqade/builder/coupling/","title":"Coupling","text":""},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.Hyperfine","title":"Hyperfine","text":"<pre><code>Hyperfine(parent=None)\n</code></pre> <p>             Bases: <code>LevelCoupling</code></p> <p>This node represent level coupling between hyperfine state.</p> <p>Examples:</p> <pre><code>- To reach the node from the start node:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.coupling.Hyperfine'&gt;\n\n- Hyperfine level coupling have two reachable field nodes:\n\n    - detuning term (See also [`Detuning`][bloqade.builder.field.Detuning])\n    - rabi term (See also [`Rabi`][bloqade.builder.field.Rabi])\n\n&gt;&gt;&gt; hyp_detune = bloqade.start.hyperfine.detuning\n&gt;&gt;&gt; hyp_rabi = bloqade.start.hyperfine.rabi\n</code></pre> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.LevelCoupling","title":"LevelCoupling","text":"<pre><code>LevelCoupling(parent=None)\n</code></pre> <p>             Bases: <code>Builder</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.LevelCoupling.detuning","title":"detuning  <code>property</code>","text":"<pre><code>detuning\n</code></pre> <p>Specify the <code>Detuning</code> <code>Field</code> of your program. You will be able to specify the spatial modulation afterwards.</p> <p>Returns:</p> Type Description <code>Detuning</code> <p><code>Detuning</code>: A program node representing the detuning field.</p> Background and Context <p>In the Many-Body Rydberg Hamiltonian:</p> \\[ \\frac{\\mathcal{H}(t)}{\\hbar} = \\sum_j \\frac{\\Omega_j(t)}{2} \\left( e^{i \\phi_j(t) } | g_j \\rangle  \\langle r_j | + e^{-i \\phi_j(t) } | r_j \\rangle  \\langle g_j | \\right) - \\sum_j \\Delta_j(t) \\hat{n}_j + \\sum_{j &lt; k} V_{jk} \\hat{n}_j \\hat{n}_k. \\] <p>The detuning is specified by the term \\(\\Delta_j(t)\\) and specifies how off-resonant the laser being applied to the atoms is from the atomic energy transition, which is driven by the Rabi frequency \\(\\Omega_j(t)\\).</p> <p>The detuning is described by a field, which is the summation of one or more drives, with the drive being the sum of a waveform and spatial modulation:</p> \\[ \\sum_j \\Delta_j(t)  = \\sum_j \\sum_a C^{a}_{j} f_{a}(t) \\] <p>Note that the spatial modulation \\(C_{j}\\) scales how much of the detuning waveform is experienced by the atom at site \\(j\\). You can specify the scaling that all atoms feel to be identical (global detuning) or you can specify different scaling for different atoms (local detuning).</p> Examples <p><pre><code>from bloqade import start\n\n# specify geometry, in this case just one atom\ngeometry = start.add_position((0,0))\n# specify your coupling (either `rydberg` or `hyperfine`)\ncoupling = geometry.rydberg\n# Begin specifying your detuning\ncoupling.detuning\n</code></pre> Alternatively you may start with building your Rabi field and then reach the ability to build your detuning like so:</p> <pre><code>from bloqade import start\ngeometry = start.add_position((0,0))\ncoupling = geometry.rydberg\nrabi_field = coupling.rabi.amplitude.uniform.constant(duration = 1.0, value = 1.0)\ndetuning = rabi_field.detuning\n</code></pre> Applications <ul> <li>Single Qubit Floquet Dynamics</li> <li>Two Qubit Adiabatic Sweep</li> <li>1D Z2 State Preparation</li> <li>2D State Preparation</li> <li>Quantum Scar Dynamics</li> <li>Solving the Maximal Independent Set Problem on defective King Graph</li> </ul> Potential Pitfalls <p>Bloqade allows you to build a field for the Detuning in the form of:</p> \\[ \\sum_j \\Delta_j(t)  = \\sum_j \\sum_a C^{a}_{j} f_{a}(t) \\] <p>Where your field can contain multiple drives.</p> <p>In reality the hardware only supports the following configuration:</p> \\[ \\Delta_{i}(t) = \\Delta_{1}(t) + c_{i} \\Delta_{2}(t) \\] \\[ c_i \\in [0, 1] \\] \\[ \\Delta_{2}(t) \\leq 0 \\] <p>Where \\(\\Delta_{1}(t)\\) is your global detuning (establishable via <code>uniform</code>) and \\(\\Delta_{2}(t)\\) is your local detuning waveform with the spatial modulation \\(c_{i}\\) establishable via <code>location</code> or <code>scale</code>.</p>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.LevelCoupling.detuning--next-possible-steps","title":"Next Possible Steps","text":"<p>You may continue building your program via:</p> <ul> <li><code>uniform</code>: To address all atoms in the field</li> <li><code>location(locations, scales)</code>: To address atoms at specific     locations via indices</li> <li><code>scale(coeffs)</code>: To address all atoms with an individual scale factor</li> </ul>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.LevelCoupling.rabi","title":"rabi  <code>property</code>","text":"<pre><code>rabi\n</code></pre> <p>Specify the complex-valued <code>Rabi</code> field of your program.</p> <p>The Rabi field is composed of a real-valued Amplitude and Phase field.</p> <ul> <li>Next possible steps to build your program are   creating the <code>RabiAmplitude</code> field   and <code>RabiPhase</code> field of the field:<ul> <li><code>...rabi.amplitude</code>: To create the Rabi amplitude field</li> <li><code>...rabi.phase</code>: To create the Rabi phase field</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.Rydberg","title":"Rydberg","text":"<pre><code>Rydberg(parent=None)\n</code></pre> <p>             Bases: <code>LevelCoupling</code></p> <p>This node represent level coupling of rydberg state.</p> <p>Examples:</p> <pre><code>- To reach the node from the start node:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.coupling.Rydberg'&gt;\n\n- Rydberg level coupling have two reachable field nodes:\n\n    - detuning term (See also [`Detuning`][bloqade.builder.field.Detuning])\n    - rabi term (See also [`Rabi`][bloqade.builder.field.Rabi])\n\n&gt;&gt;&gt; ryd_detune = bloqade.start.rydberg.detuning\n&gt;&gt;&gt; ryd_rabi = bloqade.start.rydberg.rabi\n</code></pre> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/drive/","title":"Drive","text":""},{"location":"reference/bloqade/builder/drive/#bloqade.builder.drive.Drive","title":"Drive","text":""},{"location":"reference/bloqade/builder/drive/#bloqade.builder.drive.Drive.hyperfine","title":"hyperfine  <code>property</code>","text":"<pre><code>hyperfine\n</code></pre> <p>Address the Hyperfine level coupling in your program.</p> <ul> <li>Next possible steps to build your program are specifying the   <code>Rabi</code> field or   <code>Detuning</code> field.<ul> <li><code>...hyperfine.rabi</code>: for Rabi field</li> <li><code>...hyperfine.detuning</code>: for Detuning field</li> </ul> </li> <li>In the absence of a field you the value is set to zero by default.</li> </ul>"},{"location":"reference/bloqade/builder/drive/#bloqade.builder.drive.Drive.rydberg","title":"rydberg  <code>property</code>","text":"<pre><code>rydberg\n</code></pre> <p>Address the Rydberg level coupling in your program.</p> <ul> <li>Next possible steps to build your program are specifying the   <code>Rabi</code> field or   <code>Detuning</code> field.<ul> <li><code>...rydberg.rabi</code>: for Rabi field</li> <li><code>...rydberg.detuning</code>: for Detuning field</li> </ul> </li> <li>In the absence of a field you the value is set to zero by default.</li> </ul>"},{"location":"reference/bloqade/builder/field/","title":"Field","text":""},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Detuning","title":"Detuning","text":"<pre><code>Detuning(parent=None)\n</code></pre> <p>             Bases: <code>Field</code></p> <p>This node represent detuning field of a specified level coupling (rydberg or hyperfine) type.</p> <p>Examples:</p> <pre><code>- To specify detuning of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.detuning\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Detuning'&gt;\n\n- To specify detuning of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.detuning\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Detuning'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See <code>SpatialModulation</code> for additional options.</p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field","title":"Field","text":"<pre><code>Field(parent=None)\n</code></pre> <p>             Bases: <code>Builder</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.uniform","title":"uniform  <code>property</code>","text":"<pre><code>uniform\n</code></pre> <p>Address all atoms as part of defining the spatial modulation component of a drive.</p> <p>Next steps to build your program include choosing the waveform that will be summed with the spatial modulation to create a drive.</p> <p>The drive by itself, or the sum of subsequent drives (created by just chaining the construction of drives) will become the field (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.).</p> <ul> <li>You can now do:<ul> <li><code>...uniform.linear(start, stop, duration)</code> : to apply a linear waveform</li> <li><code>...uniform.constant(value, duration)</code> : to apply a constant waveform</li> <li><code>...uniform.poly([coefficients], duration)</code> : to apply a     polynomial waveform</li> <li><code>...uniform.apply(wf:bloqade.ir.Waveform)</code>: to apply a pre-defined waveform</li> <li><code>...uniform.piecewise_linear([durations], [values])</code>:  to apply a piecewise linear waveform</li> <li><code>...uniform.piecewise_constant([durations], [values])</code>: to apply a piecewise constant waveform</li> <li><code>...uniform.fn(f(t,...))</code>: to apply a function as a waveform</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.location","title":"location","text":"<pre><code>location(labels, scales=None)\n</code></pre> <p>Address a single atom (or multiple) atoms.</p> <p>Address a single atom (or multiple) as part of defining the spatial modulation component of a drive. You can specify the atoms to target as a list of labels and a list of scales. The scales are used to multiply the waveform that is applied to the atom. You can also specify a single label and scale to target a single atom.</p> <p>Next steps to build your program include choosing the waveform that will be summed with the spatial modulation to create a drive.</p> <p>The drive by itself, or the sum of subsequent drives (created by just chaining the construction of drives) will become the field. (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)</p>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.location--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n# to target a single atom with a waveform\n&gt;&gt;&gt; one_location_prog = prog.location(0)\n# to target a single atom with a scale\n&gt;&gt;&gt; one_location_prog = prog.location(0, 0.5)\n# to target multiple atoms with same waveform\n&gt;&gt;&gt; multi_location_prog = prog.location([0, 2])\n# to target multiple atoms with different scales\n&gt;&gt;&gt; multi_location_prog = prog.location([0, 2], [0.5, \"scale\"])\n</code></pre> <ul> <li>You can now do:<ul> <li><code>...location(labels, scales).linear(start, stop, duration)</code> : to apply     a linear waveform</li> <li><code>...location(labels, scales).constant(value, duration)</code> : to apply     a constant waveform</li> <li><code>...location(labels, scales).poly([coefficients], duration)</code> : to apply     a polynomial waveform</li> <li><code>...location(labels, scales).apply(wf:bloqade.ir.Waveform)</code>: to apply     a pre-defined waveform</li> <li><code>...location(labels, scales).piecewise_linear([durations], [values])</code>:     to apply     a piecewise linear waveform</li> <li><code>...location(labels, scales).piecewise_constant([durations], [values])</code>:     to apply     a piecewise constant waveform</li> <li><code>...location(labels, scales).fn(f(t,..))</code>: to apply a function as a     waveform</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/field.py</code> <pre><code>def location(\n    self,\n    labels: Union[List[int], int],\n    scales: Union[List[ScalarType], ScalarType, None] = None,\n) -&gt; \"Location\":\n    \"\"\"Address a single atom (or multiple) atoms.\n\n    Address a single atom (or multiple) as part of defining the spatial\n    modulation component of a drive. You can specify the atoms to target\n    as a list of labels and a list of scales. The scales are used to\n    multiply the waveform that is applied to the atom. You can also specify\n    a single label and scale to target a single atom.\n\n    Next steps to build your program include choosing the waveform that\n    will be summed with the spatial modulation to create a drive.\n\n    The drive by itself, or the sum of subsequent drives (created by just\n    chaining the construction of drives) will become the field.\n    (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n    # to target a single atom with a waveform\n    &gt;&gt;&gt; one_location_prog = prog.location(0)\n    # to target a single atom with a scale\n    &gt;&gt;&gt; one_location_prog = prog.location(0, 0.5)\n    # to target multiple atoms with same waveform\n    &gt;&gt;&gt; multi_location_prog = prog.location([0, 2])\n    # to target multiple atoms with different scales\n    &gt;&gt;&gt; multi_location_prog = prog.location([0, 2], [0.5, \"scale\"])\n    ```\n\n    - You can now do:\n        - `...location(labels, scales).linear(start, stop, duration)` : to apply\n            a linear waveform\n        - `...location(labels, scales).constant(value, duration)` : to apply\n            a constant waveform\n        - `...location(labels, scales).poly([coefficients], duration)` : to apply\n            a polynomial waveform\n        - `...location(labels, scales).apply(wf:bloqade.ir.Waveform)`: to apply\n            a pre-defined waveform\n        - `...location(labels, scales).piecewise_linear([durations], [values])`:\n            to apply\n            a piecewise linear waveform\n        - `...location(labels, scales).piecewise_constant([durations], [values])`:\n            to apply\n            a piecewise constant waveform\n        - `...location(labels, scales).fn(f(t,..))`: to apply a function as a\n            waveform\n\n    \"\"\"\n    return self._location(labels, scales)\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.scale","title":"scale","text":"<pre><code>scale(coeffs)\n</code></pre> <p>Address all the atoms scaling each atom with an element of the list or define a variable name for the scale list to be assigned later by defining a <code>name</code> and using <code>assign</code> or <code>batch_assign</code> later.</p> <p>Next steps to build your program include choosing the waveform that will be summed with the spatial modulation to create a drive.</p> <p>The drive by itself, or the sum of subsequent drives (created by just chaining the construction of drives) will become the field (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)</p>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n\n# assign a literal list of values to scale each atom\n&gt;&gt;&gt; one_location_prog = prog.scale([0.1, 0.2, 0.3])\n# assign a variable name to be assigned later\n&gt;&gt;&gt; one_location_prog = prog.scale(\"a\")\n# \"a\" can be assigned in the END of the program during variable assignment\n# using a list of values, indicating the scaling for each atom\n&gt;&gt;&gt; single_assignment = ...assign(a = [0.1, 0.2, 0.3])\n# a list of lists, indicating a set of atoms should be targeted\n# for each task in a batch.\n&gt;&gt;&gt; batch_assignment = ...batch_assign(a = [list_1, list_2, list_3,...])\n</code></pre> <ul> <li>You can now do:<ul> <li><code>...scale(coeffs).linear(start, stop, duration)</code> : to apply     a linear waveform</li> <li><code>...scale(coeffs).constant(value, duration)</code> : to apply     a constant waveform</li> <li><code>...scale(coeffs).poly([coefficients], duration)</code> : to apply     a polynomial waveform</li> <li><code>...scale(coeffs).apply(wf:bloqade.ir.Waveform)</code>: to apply     a pre-defined waveform</li> <li><code>...scale(coeffs).piecewise_linear(durations, values)</code>:  to     apply a piecewise linear waveform</li> <li><code>...scale(coeffs).piecewise_constant(durations, values)</code>: to     apply a piecewise constant waveform</li> <li><code>...scale(coeffs).fn(f(t,..))</code>: to apply a function as a waveform</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/field.py</code> <pre><code>def scale(self, coeffs: Union[str, List[ScalarType]]) -&gt; \"Scale\":\n    \"\"\"\n    Address all the atoms scaling each atom with an element of the list\n    or define a variable name for the scale list to be assigned later by\n    defining a `name` and using `assign` or `batch_assign` later.\n\n    Next steps to build your program include choosing the waveform that\n    will be summed with the spatial modulation to create a drive.\n\n    The drive by itself, or the sum of subsequent drives (created by just\n    chaining the construction of drives) will become the field\n    (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n\n    # assign a literal list of values to scale each atom\n    &gt;&gt;&gt; one_location_prog = prog.scale([0.1, 0.2, 0.3])\n    # assign a variable name to be assigned later\n    &gt;&gt;&gt; one_location_prog = prog.scale(\"a\")\n    # \"a\" can be assigned in the END of the program during variable assignment\n    # using a list of values, indicating the scaling for each atom\n    &gt;&gt;&gt; single_assignment = ...assign(a = [0.1, 0.2, 0.3])\n    # a list of lists, indicating a set of atoms should be targeted\n    # for each task in a batch.\n    &gt;&gt;&gt; batch_assignment = ...batch_assign(a = [list_1, list_2, list_3,...])\n\n    ```\n\n    - You can now do:\n        - `...scale(coeffs).linear(start, stop, duration)` : to apply\n            a linear waveform\n        - `...scale(coeffs).constant(value, duration)` : to apply\n            a constant waveform\n        - `...scale(coeffs).poly([coefficients], duration)` : to apply\n            a polynomial waveform\n        - `...scale(coeffs).apply(wf:bloqade.ir.Waveform)`: to apply\n            a pre-defined waveform\n        - `...scale(coeffs).piecewise_linear(durations, values)`:  to\n            apply a piecewise linear waveform\n        - `...scale(coeffs).piecewise_constant(durations, values)`: to\n            apply a piecewise constant waveform\n        - `...scale(coeffs).fn(f(t,..))`: to apply a function as a waveform\n\n    \"\"\"\n    from bloqade.builder.spatial import Scale\n\n    return Scale(coeffs, self)\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Rabi","title":"Rabi","text":"<pre><code>Rabi(parent=None)\n</code></pre> <p>             Bases: <code>Builder</code></p> <p>This node represent rabi field of a specified level coupling (rydberg or hyperfine) type.</p> <p>Examples:</p> <pre><code>- To specify rabi of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi\n&lt;class 'bloqade.builder.field.Rabi'&gt;\n\n- To specify rabi of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Rabi'&gt;\n</code></pre> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Rabi.amplitude","title":"amplitude  <code>property</code>","text":"<pre><code>amplitude\n</code></pre> <p>Specify the real-valued Rabi Amplitude field.</p> <p>Next steps to build your program focus on specifying a spatial modulation.</p> <p>The spatial modulation, when coupled with a waveform, completes the specification of a \"Drive\". One or more drives can be summed together automatically to create a field such as the Rabi Amplitude here.</p> <ul> <li>You can now<ul> <li><code>...amplitude.uniform</code>: Address all atoms in the field</li> <li><code>...amplitude.location(...)</code>: Scale atoms by their indices</li> <li><code>...amplitude.scale(...)</code>: Scale each atom with a value from a     list or assign a variable name to be assigned later</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Rabi.phase","title":"phase  <code>property</code>","text":"<pre><code>phase\n</code></pre> <p>Specify the real-valued Rabi Phase field.</p> <p>Next steps to build your program focus on specifying a spatial modulation.</p> <p>The spatial modulation, when coupled with a waveform, completes the specification of a \"Drive\". One or more drives can be summed together automatically to create a field such as the Rabi Phase here.</p> <ul> <li>You can now<ul> <li><code>...amplitude.uniform</code>: Address all atoms in the field</li> <li><code>...amplitude.location(...)</code>: Scale atoms by their indices</li> <li><code>...amplitude.scale(...)</code>: Scale each atom with a value from a     list or assign a variable name to be assigned later</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.RabiAmplitude","title":"RabiAmplitude","text":"<pre><code>RabiAmplitude(parent=None)\n</code></pre> <p>             Bases: <code>Field</code></p> <p>This node represent amplitude of a rabi field.</p> <p>Examples:</p> <pre><code>- To specify rabi amplitude of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi.amplitude\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Amplitude'&gt;\n\n- To specify rabi amplitude of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi.amplitude\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Amplitude'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See <code>SpatialModulation</code> for additional options.</p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.RabiPhase","title":"RabiPhase","text":"<pre><code>RabiPhase(parent=None)\n</code></pre> <p>             Bases: <code>Field</code></p> <p>This node represent phase of a rabi field.</p> <p>Examples:</p> <pre><code>- To specify rabi phase of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi.phase\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Phase'&gt;\n\n- To specify rabi phase of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi.phase\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Phase'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See <code>SpatialModulation</code> for additional options.</p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/parallelize/","title":"Parallelize","text":""},{"location":"reference/bloqade/builder/pragmas/","title":"Pragmas","text":""},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Assignable","title":"Assignable","text":""},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Assignable.assign","title":"assign","text":"<pre><code>assign(**assignments)\n</code></pre> <p>Assign values to variables declared previously in the program.</p> <p>This is reserved for variables that should only take single values OR for spatial modulations that were created with <code>.scale(str)</code> in which case you can pass in a list. This is the ONLY circumstance in which multiple values are allowed.</p>"},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Assignable.assign--usage-examples","title":"Usage Examples:","text":"<pre><code># define geometry\n&gt;&gt;&gt; reg = bloqade.start\n...       .add_position([(0,0),(1,1),(2,2),(3,3)])\n# define variables in program\n&gt;&gt;&gt; seq = reg.rydberg.detuning.uniform\n...       .linear(start=\"ival\",stop=1,duration=\"span_time\")\n# assign values to variables\n&gt;&gt;&gt; seq = seq.assign(span_time = 0.5, ival = 0.0)\n</code></pre> <ul> <li>You can now:<ul> <li><code>...assign(assignments).bloqade</code>: select the bloqade local     emulator backend</li> <li><code>...assign(assignments).braket</code>: select braket local emulator or     QuEra hardware</li> <li><code>...assign(assignments).device(specifier_string)</code>: select backend     by specifying a string</li> </ul> </li> <li>Assign multiple values to a single variable for a parameter sweep:<ul> <li><code>...assign(assignments).batch_assign(assignments)</code>:</li> </ul> </li> <li>Parallelize the program register, duplicating the geometry and waveform     sequence to take advantage of all available   space/qubits on the QPU:<ul> <li><code>...assign(assignments).parallelize(cluster_spacing)</code></li> </ul> </li> <li>Defer value assignment of certain variables to runtime:<ul> <li><code>...assign(assignments).args([previously_defined_vars])</code></li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/pragmas.py</code> <pre><code>def assign(self, **assignments) -&gt; \"Assign\":\n    \"\"\"\n    Assign values to variables declared previously in the program.\n\n    This is reserved for variables that should only take single values OR\n    for spatial modulations that were created with `.scale(str)` in which case\n    you can pass in a list. This is the ONLY circumstance in which multiple\n    values are allowed.\n\n    ### Usage Examples:\n    ```\n    # define geometry\n    &gt;&gt;&gt; reg = bloqade.start\n    ...       .add_position([(0,0),(1,1),(2,2),(3,3)])\n    # define variables in program\n    &gt;&gt;&gt; seq = reg.rydberg.detuning.uniform\n    ...       .linear(start=\"ival\",stop=1,duration=\"span_time\")\n    # assign values to variables\n    &gt;&gt;&gt; seq = seq.assign(span_time = 0.5, ival = 0.0)\n    ```\n\n    - You can now:\n        - `...assign(assignments).bloqade`: select the bloqade local\n            emulator backend\n        - `...assign(assignments).braket`: select braket local emulator or\n            QuEra hardware\n        - `...assign(assignments).device(specifier_string)`: select backend\n            by specifying a string\n    - Assign multiple values to a single variable for a parameter sweep:\n        - `...assign(assignments).batch_assign(assignments)`:\n    - Parallelize the program register, duplicating the geometry and waveform\n        sequence to take advantage of all available\n      space/qubits on the QPU:\n        - `...assign(assignments).parallelize(cluster_spacing)`\n    - Defer value assignment of certain variables to runtime:\n        - `...assign(assignments).args([previously_defined_vars])`\n\n    \"\"\"\n    from bloqade.builder.assign import Assign\n\n    return Assign(assignments, parent=self)\n</code></pre>"},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.BatchAssignable","title":"BatchAssignable","text":""},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.BatchAssignable.batch_assign","title":"batch_assign","text":"<pre><code>batch_assign(__batch_params=[], **assignments)\n</code></pre> <p>Assign multiple values to a single variable to create a parameter sweep.</p> <p>Bloqade automatically handles the multiple programs this would generate and treats it as object with unified results for easy post-processing.</p> <p>NOTE: if you assign multiple values to multiple variables in your program, the values must be of the same length. Bloqade will NOT do a Cartesian product (e.g. if \"var1\" is assigned [1,2,3] and \"var2\" is assigned [4,5,6] then the resulting programs will have assignments [1,4], [2,5], [3,6]).</p>"},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.BatchAssignable.batch_assign--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (0, \"atom_distance\")])\n&gt;&gt;&gt; prog = reg.rydberg.rabi.amplitude.uniform.constant(\"value\", 5.0)\n&gt;&gt;&gt; var_assigned_prog = prog.batch_assign(value = [1.0, 2.0, 3.0],\natom_distance = [1.0, 2.0, 3.0])\n</code></pre> <ul> <li>Next steps are:<ul> <li><code>...batch_assign(assignments).bloqade</code>: select the bloqade     local emulator backend</li> <li><code>...batch_assign(assignments).braket</code>: select braket local emulator or QuEra hardware</li> <li><code>...batch_assign(assignments).device(specifier_string)</code>: select backend by specifying a string</li> </ul> </li> <li>Parallelize the program register, duplicating the geometry and waveform   sequence to take advantage of all available   space/qubits on the QPU:<ul> <li><code>...batch_assign(assignments).parallelize(cluster_spacing)</code></li> </ul> </li> <li>Defer value assignment of certain variables to runtime:<ul> <li><code>...batch_assign(assignments).args([previously_defined_vars])</code></li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/pragmas.py</code> <pre><code>def batch_assign(\n    self,\n    __batch_params: List[Dict[str, ParamType]] = [],\n    **assignments: List[ParamType],\n) -&gt; Union[\"BatchAssign\", \"ListAssign\"]:\n    \"\"\"\n\n    Assign multiple values to a single variable to create a parameter sweep.\n\n    Bloqade automatically handles the multiple programs this would generate\n    and treats it as object with unified results for easy post-processing.\n\n    NOTE: if you assign multiple values to multiple variables in your program,\n    the values must be of the same length. Bloqade will NOT do a Cartesian product\n    (e.g. if \"var1\" is assigned [1,2,3] and \"var2\" is assigned [4,5,6] then the\n    resulting programs will have assignments [1,4], [2,5], [3,6]).\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (0, \"atom_distance\")])\n    &gt;&gt;&gt; prog = reg.rydberg.rabi.amplitude.uniform.constant(\"value\", 5.0)\n    &gt;&gt;&gt; var_assigned_prog = prog.batch_assign(value = [1.0, 2.0, 3.0],\n    atom_distance = [1.0, 2.0, 3.0])\n    ```\n\n    - Next steps are:\n        - `...batch_assign(assignments).bloqade`: select the bloqade\n            local emulator backend\n        - `...batch_assign(assignments).braket`: select braket local\n        emulator or QuEra hardware\n        - `...batch_assign(assignments).device(specifier_string)`: select\n        backend by specifying a string\n    - Parallelize the program register, duplicating the geometry and waveform\n      sequence to take advantage of all available\n      space/qubits on the QPU:\n        - `...batch_assign(assignments).parallelize(cluster_spacing)`\n    - Defer value assignment of certain variables to runtime:\n        - `...batch_assign(assignments).args([previously_defined_vars])`\n\n    \"\"\"\n    from bloqade.builder.assign import BatchAssign, ListAssign\n\n    if len(__batch_params) &gt; 0 and assignments:\n        raise ValueError(\"batch_params and assignments cannot be used together.\")\n\n    if len(__batch_params) &gt; 0:\n        return ListAssign(__batch_params, parent=self)\n    else:\n        return BatchAssign(assignments, parent=self)\n</code></pre>"},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Parallelizable","title":"Parallelizable","text":""},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Parallelizable.parallelize","title":"parallelize","text":"<pre><code>parallelize(cluster_spacing)\n</code></pre> <p>Parallelize the current problem (register and sequence) by duplicating the geometry to take advantage of all available space/qubits on hardware.</p> <p>The singular argument lets you specify how far apart the clusters should be in micrometers.</p>"},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Parallelizable.parallelize--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position((0,0)).rydberg.rabi.uniform.amplitude\n.constant(1.0, 1.0)\n# copy-paste the geometry and waveforms\n&gt;&gt;&gt; parallelized_prog = reg.parallelize(24)\n</code></pre> <ul> <li>Your next steps are:      <code>...parallelize(cluster_spacing).bloqade</code>: select the bloqade         local emulator backend      <code>...parallelize(cluster_spacing).braket</code>: select braket         local emulator or QuEra hardware on the cloud      <code>...parallelize(cluster_spacing).device(specifier_string)</code>: select         backend by specifying a string</li> </ul> Source code in <code>src/bloqade/builder/pragmas.py</code> <pre><code>def parallelize(self, cluster_spacing: LiteralType) -&gt; \"Parallelize\":\n    \"\"\"\n\n    Parallelize the current problem (register and sequence) by duplicating\n    the geometry to take advantage of all available space/qubits on hardware.\n\n    The singular argument lets you specify how far apart the clusters\n    should be in micrometers.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position((0,0)).rydberg.rabi.uniform.amplitude\n    .constant(1.0, 1.0)\n    # copy-paste the geometry and waveforms\n    &gt;&gt;&gt; parallelized_prog = reg.parallelize(24)\n    ```\n\n    - Your next steps are:\n         `...parallelize(cluster_spacing).bloqade`: select the bloqade\n            local emulator backend\n         `...parallelize(cluster_spacing).braket`: select braket\n            local emulator or QuEra hardware on the cloud\n         `...parallelize(cluster_spacing).device(specifier_string)`: select\n            backend by specifying a string\n\n    \"\"\"\n    from bloqade.builder.parallelize import Parallelize\n\n    return Parallelize(cluster_spacing, self)\n</code></pre>"},{"location":"reference/bloqade/builder/route/","title":"Route","text":""},{"location":"reference/bloqade/builder/sequence_builder/","title":"Sequence builder","text":""},{"location":"reference/bloqade/builder/spatial/","title":"Spatial","text":""},{"location":"reference/bloqade/builder/spatial/#bloqade.builder.spatial.Location","title":"Location","text":"<pre><code>Location(labels, scales, parent=None)\n</code></pre> <p>             Bases: <code>SpatialModulation</code></p> Source code in <code>src/bloqade/builder/spatial.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    labels: List[int],\n    scales: List[ScalarType],\n    parent: Optional[Builder] = None,\n) -&gt; None:\n    from bloqade.ir.scalar import cast\n    from bloqade.ir.control.field import Location\n\n    super().__init__(parent)\n    self._scaled_locations = {\n        Location(label): cast(scale) for label, scale in zip(labels, scales)\n    }\n</code></pre>"},{"location":"reference/bloqade/builder/spatial/#bloqade.builder.spatial.Uniform","title":"Uniform","text":"<pre><code>Uniform(parent=None)\n</code></pre> <p>             Bases: <code>SpatialModulation</code></p> <p>The node specify a uniform spacial modulation. Which is ready to apply waveform (See <code>Waveform</code> for available waveform options)</p> <p>Examples:</p> <pre><code>- To hit this node from the start node:\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.uniform\n\n- Apply Linear waveform:\n\n&gt;&gt;&gt; wv = bloqade.ir.Linear(start=0,stop=1,duration=0.5)\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.uniform.apply(wv)\n</code></pre> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/start/","title":"Start","text":""},{"location":"reference/bloqade/builder/start/#bloqade.builder.start.ProgramStart","title":"ProgramStart","text":"<pre><code>ProgramStart(parent=None)\n</code></pre> <p>             Bases: <code>Drive</code>, <code>Builder</code></p> <p>ProgramStart is the base class for a starting/entry node for building a program.</p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/start/#bloqade.builder.start.ProgramStart.apply","title":"apply","text":"<pre><code>apply(sequence)\n</code></pre> <p>Apply a pre-built sequence to a program.</p> <p>This allows you to build a program independent of any geometry and then <code>apply</code> the program to said geometry. Or, if you have a program you would like to try on multiple geometries you can trivially do so with this.</p> <p>Example Usage: <pre><code>&gt;&gt;&gt; from numpy import pi\n&gt;&gt;&gt; seq = start.rydberg.rabi.amplitude.constant(2.0 * pi, 4.5)\n# choose a geometry of interest to apply the program on\n&gt;&gt;&gt; from bloqade.atom_arrangement import Chain, Kagome\n&gt;&gt;&gt; complete_program = Chain(10).apply(seq)\n# you can .apply to as many geometries as you like\n&gt;&gt;&gt; another_complete_program = Kagome(3).apply(seq)\n</code></pre></p> <ul> <li>From here you can now do:<ul> <li><code>...assign(assignments).bloqade</code>: select the bloqade     local emulator backend</li> <li><code>...assign(assignments).braket</code>: select braket     local emulator or QuEra hardware</li> <li><code>...assign(assignments).device(specifier_string)</code>: select     backend by specifying a string</li> </ul> </li> <li>Assign multiple values to a single variable for a parameter sweep:<ul> <li><code>...assign(assignments).batch_assign(assignments)</code>:</li> </ul> </li> <li>Parallelize the program register, duplicating the geometry and waveform     sequence to take advantage of all available   space/qubits on the QPU:<ul> <li><code>...assign(assignments).parallelize(cluster_spacing)</code></li> </ul> </li> <li>Defer value assignment of certain variables to runtime:<ul> <li><code>...assign(assignments).args([previously_defined_vars])</code></li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/start.py</code> <pre><code>@beartype\ndef apply(self, sequence: SequenceExpr) -&gt; SequenceBuilder:\n    \"\"\"\n    Apply a pre-built sequence to a program.\n\n    This allows you to build a program independent of any geometry\n    and then `apply` the program to said geometry. Or, if you have a\n    program you would like to try on multiple geometries you can\n    trivially do so with this.\n\n    Example Usage:\n    ```\n    &gt;&gt;&gt; from numpy import pi\n    &gt;&gt;&gt; seq = start.rydberg.rabi.amplitude.constant(2.0 * pi, 4.5)\n    # choose a geometry of interest to apply the program on\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain, Kagome\n    &gt;&gt;&gt; complete_program = Chain(10).apply(seq)\n    # you can .apply to as many geometries as you like\n    &gt;&gt;&gt; another_complete_program = Kagome(3).apply(seq)\n    ```\n\n    - From here you can now do:\n        - `...assign(assignments).bloqade`: select the bloqade\n            local emulator backend\n        - `...assign(assignments).braket`: select braket\n            local emulator or QuEra hardware\n        - `...assign(assignments).device(specifier_string)`: select\n            backend by specifying a string\n    - Assign multiple values to a single variable for a parameter sweep:\n        - `...assign(assignments).batch_assign(assignments)`:\n    - Parallelize the program register, duplicating the geometry and waveform\n        sequence to take advantage of all available\n      space/qubits on the QPU:\n        - `...assign(assignments).parallelize(cluster_spacing)`\n    - Defer value assignment of certain variables to runtime:\n        - `...assign(assignments).args([previously_defined_vars])`\n\n    \"\"\"\n    return SequenceBuilder(sequence, self)\n</code></pre>"},{"location":"reference/bloqade/builder/typing/","title":"Typing","text":""},{"location":"reference/bloqade/builder/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Recordable","title":"Recordable","text":""},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Recordable.record","title":"record","text":"<pre><code>record(name)\n</code></pre> <p>Copy or \"record\" the value at the end of the waveform into a variable so that it can be used in another place.</p> <p>A common design pattern is to couple this with <code>.slice()</code> considering you may not know exactly what the end value of a <code>.slice()</code> is, especially in parameter sweeps where it becomes cumbersome to handle.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Recordable.record--usage-example","title":"Usage Example:","text":"<pre><code># define program of interest\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; prog = start.rydberg.rabi.amplitude.uniform\n&gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n# We now slice the piecewise_linear from above and record the\n# value at the end of that slice. We then use that value\n# to construct a new waveform that can be appended to the previous\n# one without introducing discontinuity (refer to the\n# \"Quantum Scar Dynamics\" tutorial for how this could be handy)\n&gt;&gt;&gt; prog_with_record = prog_with_wf.slice(0.0, 1.0).record(\"end_of_wf\")\n&gt;&gt;&gt; record_applied_prog = prog_with_record.linear(start=\"end_of_wf\"\n, stop=0.0, duration=0.3)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...slice(start, stop).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...slice(start, stop).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...slice(start, stop).piecewise_linear()</code>:     to append a piecewise linear waveform</li> <li><code>...slice(start, stop).piecewise_constant()</code>:     to append a piecewise constant waveform</li> <li><code>...slice(start, stop).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...slice(start, stop).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...slilce(start, stop).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...slice(start, stop).uniform</code>:     To address all atoms in the field</li> <li><code>...slice(start, stop).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...slice(start, stop).scale(str)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...slice(start, stop).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...slice(start, stop)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...slice(start, stop).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...slice(start, stop).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...slice(start, stop).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...slice(start, stop).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...slice(start, stop).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...slice(start, stop).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...slice(start, stop).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...slice(start, stop).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...slice(start, stop).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...slice(start, stop).detuning</code>:     to target the Detuning field</li> <li><code>...slice(start, stop).rabi</code>:     to target the complex-valued Rabi field ```</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef record(self, name: str) -&gt; \"Record\":\n    \"\"\"\n    Copy or \"record\" the value at the end of the waveform into a variable\n    so that it can be used in another place.\n\n    A common design pattern is to couple this with `.slice()` considering\n    you may not know exactly what the end value of a `.slice()` is,\n    especially in parameter sweeps where it becomes cumbersome to handle.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    # define program of interest\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; prog = start.rydberg.rabi.amplitude.uniform\n    &gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    # We now slice the piecewise_linear from above and record the\n    # value at the end of that slice. We then use that value\n    # to construct a new waveform that can be appended to the previous\n    # one without introducing discontinuity (refer to the\n    # \"Quantum Scar Dynamics\" tutorial for how this could be handy)\n    &gt;&gt;&gt; prog_with_record = prog_with_wf.slice(0.0, 1.0).record(\"end_of_wf\")\n    &gt;&gt;&gt; record_applied_prog = prog_with_record.linear(start=\"end_of_wf\"\n    , stop=0.0, duration=0.3)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...slice(start, stop).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...slice(start, stop).constant(value, duration)`:\n            to append a constant waveform\n        - `...slice(start, stop).piecewise_linear()`:\n            to append a piecewise linear waveform\n        - `...slice(start, stop).piecewise_constant()`:\n            to append a piecewise constant waveform\n        - `...slice(start, stop).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...slice(start, stop).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...slilce(start, stop).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...slice(start, stop).uniform`:\n            To address all atoms in the field\n        - `...slice(start, stop).location(int)`:\n            To address an atom at a specific location via index\n        - `...slice(start, stop).scale(str)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...slice(start, stop).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...slice(start, stop)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...slice(start, stop).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...slice(start, stop).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...slice(start, stop).bloqade`:\n            to run on the Bloqade local emulator\n        - `...slice(start, stop).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...slice(start, stop).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...slice(start, stop).rydberg`:\n            to target the Rydberg level coupling\n        - `...slice(start, stop).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...slice(start, stop).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...slice(start, stop).phase`:\n            to target the real-valued Rabi Phase field\n        - `...slice(start, stop).detuning`:\n            to target the Detuning field\n        - `...slice(start, stop).rabi`:\n            to target the complex-valued Rabi field\n    ```\n    \"\"\"\n    return Record(name, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Sliceable","title":"Sliceable","text":""},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Sliceable.slice","title":"slice","text":"<pre><code>slice(start=None, stop=None)\n</code></pre> <p>Indicate that you only want a portion of your waveform to be used in the program.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Sliceable.slice--usage-example","title":"Usage Example:","text":"<pre><code># define a program with a waveform of interest\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.amplitude.uniform\n&gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n# instead of using the full waveform we opt to only take the first 1 us\n&gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(0.0, 1.0)\n# you may use variables as well\n&gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(\"start\", \"end\")\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...slice(start, stop).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...slice(start, stop).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...slice(start, stop).piecewise_linear()</code>:     to append a piecewise linear waveform</li> <li><code>...slice(start, stop).piecewise_constant()</code>:     to append a piecewise constant waveform</li> <li><code>...slice(start, stop).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...slice(start, stop).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...slilce(start, stop).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...slice(start, stop).uniform</code>:     To address all atoms in the field</li> <li><code>...slice(start, stop).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...slice(start, stop).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...slice(start, stop).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...slice(start, stop)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...slice(start, stop).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...slice(start, stop).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...slice(start, stop).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...slice(start, stop).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...slice(start, stop).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...slice(start, stop).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...slice(start, stop).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...slice(start, stop).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...slice(start, stop).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...slice(start, stop).detuning</code>:     to target the Detuning field</li> <li><code>...slice(start, stop).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef slice(\n    self,\n    start: Optional[ScalarType] = None,\n    stop: Optional[ScalarType] = None,\n) -&gt; \"Slice\":\n    \"\"\"\n    Indicate that you only want a portion of your waveform to be used in\n    the program.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n\n    ### Usage Example:\n    ```\n    # define a program with a waveform of interest\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.amplitude.uniform\n    &gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    # instead of using the full waveform we opt to only take the first 1 us\n    &gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(0.0, 1.0)\n    # you may use variables as well\n    &gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(\"start\", \"end\")\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...slice(start, stop).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...slice(start, stop).constant(value, duration)`:\n            to append a constant waveform\n        - `...slice(start, stop).piecewise_linear()`:\n            to append a piecewise linear waveform\n        - `...slice(start, stop).piecewise_constant()`:\n            to append a piecewise constant waveform\n        - `...slice(start, stop).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...slice(start, stop).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...slilce(start, stop).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...slice(start, stop).uniform`:\n            To address all atoms in the field\n        - `...slice(start, stop).location(int)`:\n            To address an atom at a specific location via index\n        - `...slice(start, stop).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...slice(start, stop).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...slice(start, stop)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...slice(start, stop).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...slice(start, stop).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...slice(start, stop).bloqade`:\n            to run on the Bloqade local emulator\n        - `...slice(start, stop).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...slice(start, stop).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...slice(start, stop).rydberg`:\n            to target the Rydberg level coupling\n        - `...slice(start, stop).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...slice(start, stop).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...slice(start, stop).phase`:\n            to target the real-valued Rabi Phase field\n        - `...slice(start, stop).detuning`:\n            to target the Detuning field\n        - `...slice(start, stop).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return Slice(start, stop, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable","title":"WaveformAttachable","text":"<pre><code>WaveformAttachable(parent=None)\n</code></pre> <p>             Bases: <code>Builder</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.apply","title":"apply","text":"<pre><code>apply(wf)\n</code></pre> <p>Apply a <code>Waveform</code> built previously to current location(s).</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.apply--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# build our waveform independently of the main program\n&gt;&gt;&gt; from bloqade import piecewise_linear\n&gt;&gt;&gt; wf = piecewise_linear(durations=[0.3, 2.5, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n&gt;&gt;&gt; prog.apply(wf)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...apply(waveform).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...apply(waveform).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...apply(waveform).piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...apply(waveform).piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...apply(waveform).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...apply(waveform).apply(waveform)</code>:     to append a pre-defined waveform</li> <li><code>...apply(waveform).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...apply(waveform).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...apply(waveform).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...apply(waveform).uniform</code>: To address all atoms in the field</li> <li><code>...apply(waveform).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...apply(waveform).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying a     single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...apply(waveform).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...apply(waveform).batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...apply(waveform).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...apply(waveform).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...apply(waveform).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...apply(waveform).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...apply(waveform).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...apply(waveform).rydberg</code>: to target the Rydberg level coupling</li> <li><code>...apply(waveform).hyperfine</code>: to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...apply(waveform).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...apply(waveform).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...apply(waveform).detuning</code>:     to target the Detuning field</li> <li><code>...apply(waveform).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef apply(self, wf: ir.Waveform) -&gt; \"Apply\":\n    \"\"\"\n    Apply a [`Waveform`][bloqade.ir.control.Waveform] built previously to\n    current location(s).\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # build our waveform independently of the main program\n    &gt;&gt;&gt; from bloqade import piecewise_linear\n    &gt;&gt;&gt; wf = piecewise_linear(durations=[0.3, 2.5, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    &gt;&gt;&gt; prog.apply(wf)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...apply(waveform).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...apply(waveform).constant(value, duration)`:\n            to append a constant waveform\n        - `...apply(waveform).piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...apply(waveform).piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...apply(waveform).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...apply(waveform).apply(waveform)`:\n            to append a pre-defined waveform\n        - `...apply(waveform).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...apply(waveform).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...apply(waveform).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...apply(waveform).uniform`: To address all atoms in the field\n        - `...apply(waveform).location(int)`:\n            To address an atom at a specific location via index\n        - `...apply(waveform).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying a\n                single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...apply(waveform).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...apply(waveform).batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...apply(waveform).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...apply(waveform).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...apply(waveform).bloqade`:\n            to run on the Bloqade local emulator\n        - `...apply(waveform).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...apply(waveform).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...apply(waveform).rydberg`: to target the Rydberg level coupling\n        - `...apply(waveform).hyperfine`: to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...apply(waveform).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...apply(waveform).phase`:\n            to target the real-valued Rabi Phase field\n        - `...apply(waveform).detuning`:\n            to target the Detuning field\n        - `...apply(waveform).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return Apply(wf, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.constant","title":"constant","text":"<pre><code>constant(value, duration)\n</code></pre> <p>Append or assign a constant waveform to the current location(s).</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.constant--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# apply a constant waveform of 1.9 radians/us for 0.5 us\n&gt;&gt;&gt; prog.constant(value=1.9,duration=0.5)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...constant(value, duration).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...constant(value, duration).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...constant(value, duration)     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...constant(value, duration)     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...constant(value, duration).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...constant(value, duration).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...constant(value, duration).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...constant(value, duration).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...constant(value, duration).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...constant(value, duration).uniform</code>:     To address all atoms in the field</li> <li><code>...constant(value, duration).scale(...)</code>:     To address an atom at a specific location via index</li> <li><code>...constant(value, duration).location(int)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...constant(value, duration).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...constant(value, duration)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...constant(value, duration).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...constant(value, duration).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...constant(value, duration).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...constant(value, duration).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...constant(start, stop, duration).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...constant(value, duration).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...constant(value, duration).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current   level coupling (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...constant(value, duration).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...constant(value, duration).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...constant(value, duration).detuning</code>:     to target the Detuning field</li> <li><code>...constant(value, duration).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef constant(self, value: ScalarType, duration: ScalarType) -&gt; \"Constant\":\n    \"\"\"\n    Append or assign a constant waveform to the current location(s).\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # apply a constant waveform of 1.9 radians/us for 0.5 us\n    &gt;&gt;&gt; prog.constant(value=1.9,duration=0.5)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...constant(value, duration).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...constant(value, duration).constant(value, duration)`:\n            to append a constant waveform\n        - `...constant(value, duration)\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...constant(value, duration)\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...constant(value, duration).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...constant(value, duration).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...constant(value, duration).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...constant(value, duration).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...constant(value, duration).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...constant(value, duration).uniform`:\n            To address all atoms in the field\n        - `...constant(value, duration).scale(...)`:\n            To address an atom at a specific location via index\n        - `...constant(value, duration).location(int)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...constant(value, duration).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...constant(value, duration)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...constant(value, duration).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...constant(value, duration).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...constant(value, duration).bloqade`:\n            to run on the Bloqade local emulator\n        - `...constant(value, duration).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...constant(start, stop, duration).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...constant(value, duration).rydberg`:\n            to target the Rydberg level coupling\n        - `...constant(value, duration).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current\n      level coupling (previously selected as `rydberg` or `hyperfine`):\n        - `...constant(value, duration).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...constant(value, duration).phase`:\n            to target the real-valued Rabi Phase field\n        - `...constant(value, duration).detuning`:\n            to target the Detuning field\n        - `...constant(value, duration).rabi`:\n            to target the complex-valued Rabi field\n\n    \"\"\"\n    return Constant(value, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.fn","title":"fn","text":"<pre><code>fn(fn, duration)\n</code></pre> <p>Append or assign a custom function as a waveform.</p> <p>The function must have its first argument be that of time but can also have other arguments which are treated as variables. You can assign values to later in the program via <code>.assign</code> or <code>.batch_assign</code>.</p> <p>The function must also return a singular float value.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.fn--usage-examples","title":"### Usage Examples:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# define our custom waveform. It must have one argument\n# be time followed by any other number of arguments that can\n# be assigned a value later in the program via `.assign` or `.batch_assign`\n&gt;&gt;&gt; def custom_waveform_function(t, arg1, arg2):\n        return arg1*t + arg2\n&gt;&gt;&gt; prog = prog.fn(custom_waveform_function, duration = 0.5)\n# assign values\n&gt;&gt;&gt; assigned_vars_prog = prog.assign(arg1 = 1.0, arg2 = 2.0)\n# or go for batching!\n&gt;&gt;&gt; assigned_vars_batch_prog = prog.assign(arg1 = 1.0, arg2 = [1.0, 2.0, 3.0])\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...fn(f(t,...))     .linear(start, stop, duration)</code>: to append another linear waveform</li> <li><code>...fn(f(t,...))     .constant(value, duration)</code>: to append a constant waveform</li> <li><code>...fn(f(t,...))     .piecewise_linear(durations, values)</code>:     to append a piecewise linear waveform</li> <li><code>...fn(f(t,...))     .piecewise_constant(durations, values)</code>:     to append a piecewise constant waveform</li> <li><code>...fn(f(t,...))     .poly([coefficients], duration)</code>: to append a polynomial waveform</li> <li><code>...fn(f(t,...))     .apply(waveform)</code>: to append a pre-defined waveform</li> <li><code>...fn(f(t,...))     .fn(f(t,...))</code>: to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...fn(f(t,...)).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...fn(f(t,...)).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...fn(f(t,...)).uniform</code>:     To address all atoms in the field</li> <li><code>...fn(f(t,...)).scale(...)</code>:     To address an atom at a specific location via index</li> <li>...fn(f(t,...)).location(int)`<ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning it a     list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...fn(f(t,...))     .assign(variable_name = value)</code>: to assign a single value to a variable</li> <li><code>...fn(f(t,...))     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...fn(f(t,...))     .args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...fn(f(t,...)).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...fn(f(t,...)).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...fn(f(t,...)).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...fn(f(t,...)).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...fn(f(t,...)).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...fn(f(t,...)).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...fn(f(t,...)).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...fn(f(t,...)).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...fn(f(t,...)).detuning</code>:     to target the Detuning field</li> <li><code>...fn(f(t,...)).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef fn(self, fn: Callable, duration: ScalarType) -&gt; \"Fn\":\n    \"\"\"\n    Append or assign a custom function as a waveform.\n\n    The function must have its first argument be that of time but\n    can also have other arguments which are treated as variables.\n    You can assign values to later in the program via `.assign` or `.batch_assign`.\n\n    The function must also return a singular float value.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### ### Usage Examples:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # define our custom waveform. It must have one argument\n    # be time followed by any other number of arguments that can\n    # be assigned a value later in the program via `.assign` or `.batch_assign`\n    &gt;&gt;&gt; def custom_waveform_function(t, arg1, arg2):\n            return arg1*t + arg2\n    &gt;&gt;&gt; prog = prog.fn(custom_waveform_function, duration = 0.5)\n    # assign values\n    &gt;&gt;&gt; assigned_vars_prog = prog.assign(arg1 = 1.0, arg2 = 2.0)\n    # or go for batching!\n    &gt;&gt;&gt; assigned_vars_batch_prog = prog.assign(arg1 = 1.0, arg2 = [1.0, 2.0, 3.0])\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...fn(f(t,...))\n            .linear(start, stop, duration)`: to append another linear waveform\n        - `...fn(f(t,...))\n            .constant(value, duration)`: to append a constant waveform\n        - `...fn(f(t,...))\n            .piecewise_linear(durations, values)`:\n            to append a piecewise linear waveform\n        - `...fn(f(t,...))\n            .piecewise_constant(durations, values)`:\n            to append a piecewise constant waveform\n        - `...fn(f(t,...))\n            .poly([coefficients], duration)`: to append a polynomial waveform\n        - `...fn(f(t,...))\n            .apply(waveform)`: to append a pre-defined waveform\n        - `...fn(f(t,...))\n            .fn(f(t,...))`: to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...fn(f(t,...)).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...fn(f(t,...)).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...fn(f(t,...)).uniform`:\n            To address all atoms in the field\n        - `...fn(f(t,...)).scale(...)`:\n            To address an atom at a specific location via index\n        - ...fn(f(t,...)).location(int)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning it a\n                list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...fn(f(t,...))\n            .assign(variable_name = value)`: to assign a single value to a variable\n        - `...fn(f(t,...))\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...fn(f(t,...))\n            .args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...fn(f(t,...)).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...fn(f(t,...)).bloqade`:\n            to run on the Bloqade local emulator\n        - `...fn(f(t,...)).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...fn(f(t,...)).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...fn(f(t,...)).rydberg`:\n            to target the Rydberg level coupling\n        - `...fn(f(t,...)).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...fn(f(t,...)).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...fn(f(t,...)).phase`:\n            to target the real-valued Rabi Phase field\n        - `...fn(f(t,...)).detuning`:\n            to target the Detuning field\n        - `...fn(f(t,...)).rabi`:\n            to target the complex-valued Rabi field\n\n    \"\"\"\n    return Fn(fn, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.linear","title":"linear","text":"<pre><code>linear(start, stop, duration)\n</code></pre> <p>Append or assign a linear waveform to the current location(s).</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.linear--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# apply a linear waveform that goes from 0 to 1 radians/us in 0.5 us\n&gt;&gt;&gt; prog.linear(start=0,stop=1,duration=0.5)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...linear(start, stop, duration).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...linear(start, stop, duration).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...linear(start, stop, duration)     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...linear(start, stop, duration)     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...linear(start, stop, duration).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...linear(start, stop, duration).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...linear(start, stop, duration).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...linear(start, stop, duration).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...linear(start, stop, duration).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...linear(start, stop, duration).uniform</code>:     To address all atoms in the field</li> <li><code>...linear(start, stop, duration).location(int)</code>:     To address atoms at specific location with scaling</li> <li><code>...linear(start, stop, duration).scale(...)</code><ul> <li>To address atoms at specific location with scaling</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...linear(start, stop, duration).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...linear(start, stop, duration)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...linear(start, stop, duration).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...linear(start, stop, duration).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...linear(start, stop, duration).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...linear(start, stop, duration).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...linear(start, stop, duration).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...linear(start, stop, duration).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...linear(start, stop, duration).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...linear(start, stop, duration).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...linear(start, stop, duration).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...linear(start, stop, duration).detuning</code>:     to target the Detuning field</li> <li><code>...linear(start, stop, duration).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef linear(\n    self, start: ScalarType, stop: ScalarType, duration: ScalarType\n) -&gt; \"Linear\":\n    \"\"\"\n\n    Append or assign a linear waveform to the current location(s).\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # apply a linear waveform that goes from 0 to 1 radians/us in 0.5 us\n    &gt;&gt;&gt; prog.linear(start=0,stop=1,duration=0.5)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...linear(start, stop, duration).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...linear(start, stop, duration).constant(value, duration)`:\n            to append a constant waveform\n        - `...linear(start, stop, duration)\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...linear(start, stop, duration)\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...linear(start, stop, duration).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...linear(start, stop, duration).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...linear(start, stop, duration).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...linear(start, stop, duration).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...linear(start, stop, duration).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...linear(start, stop, duration).uniform`:\n            To address all atoms in the field\n        - `...linear(start, stop, duration).location(int)`:\n            To address atoms at specific location with scaling\n        - `...linear(start, stop, duration).scale(...)`\n            - To address atoms at specific location with scaling\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...linear(start, stop, duration).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...linear(start, stop, duration)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...linear(start, stop, duration).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...linear(start, stop, duration).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...linear(start, stop, duration).bloqade`:\n            to run on the Bloqade local emulator\n        - `...linear(start, stop, duration).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...linear(start, stop, duration).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...linear(start, stop, duration).rydberg`:\n            to target the Rydberg level coupling\n        - `...linear(start, stop, duration).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...linear(start, stop, duration).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...linear(start, stop, duration).phase`:\n            to target the real-valued Rabi Phase field\n        - `...linear(start, stop, duration).detuning`:\n            to target the Detuning field\n        - `...linear(start, stop, duration).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n\n    return Linear(start, stop, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.piecewise_constant","title":"piecewise_constant","text":"<pre><code>piecewise_constant(durations, values)\n</code></pre> <p>Append or assign a piecewise constant waveform to current location(s).</p> <p>The <code>durations</code> argument should have number of elements = len(values). <code>durations</code> should be the duration PER section of the waveform, NON-CUMULATIVE.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.piecewise_constant--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.phase.uniform\n# create a staircase, we hold 0.0 rad/us for 1.0 us, then\n# to 1.0 rad/us for 0.5 us before stopping at 0.8 rad/us for 0.9 us.\n&gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3], values=[1.0, 0.5, 0.9])\n</code></pre> <ul> <li>Your next steps including:</li> <li>Continue building your waveform via:<ul> <li><code>...piecewise_constant([durations], [values])     .linear(start, stop, duration)</code>: to append another linear waveform</li> <li><code>...piecewise_constant([durations], [values])     .constant(value, duration)</code>: to append a constant waveform</li> <li><code>...piecewise_constant([durations], [values])     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...piecewise_constant([durations], [values])     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...piecewise_constant([durations], [values])     .poly([coefficients], duration)</code>: to append a polynomial waveform</li> <li><code>...piecewise_constant([durations], [values])     .apply(waveform)</code>: to append a pre-defined waveform</li> <li><code>...piecewise_constant([durations], [values]).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...piecewise_constant([durations], [values])     .slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...piecewise_constant([durations], [values])     .record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...piecewise_constant([durations], [values]).uniform</code>:     To address all atoms in the field</li> <li><code>...piecewise_constant([durations], [values]).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...piecewise_constant([durations], [values]).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning it a     list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...piecewise_constant([durations], [values])     .assign(variable_name = value)</code>: to assign a single value to a variable</li> <li><code>...piecewise_constant([durations], [values])     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...piecewise_constant([durations], [values])     .args([\"previously_defined_var\"])</code>: to defer assignment     of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...piecewise_constant([durations], [values]).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...piecewise_constant([durations], [values]).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...piecewise_constant([durations], [values]).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...piecewise_constat([durations], [values]).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...piecewise_constant([durations], [values]).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...piecewise_constant([durations], [values]).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...piecewise_constant(durations, values).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...piecewise_constant([durations], [values]).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...piecewise_constant([durations], [values]).detuning</code>:     to target the Detuning field</li> <li><code>...piecewise_constant([durations], [values]).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef piecewise_constant(\n    self, durations: List[ScalarType], values: List[ScalarType]\n) -&gt; \"PiecewiseConstant\":\n    \"\"\"\n    Append or assign a piecewise constant waveform to current location(s).\n\n    The `durations` argument should have number of elements = len(values).\n    `durations` should be the duration PER section of the waveform,\n    NON-CUMULATIVE.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.phase.uniform\n    # create a staircase, we hold 0.0 rad/us for 1.0 us, then\n    # to 1.0 rad/us for 0.5 us before stopping at 0.8 rad/us for 0.9 us.\n    &gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3], values=[1.0, 0.5, 0.9])\n    ```\n\n    - Your next steps including:\n    - Continue building your waveform via:\n        - `...piecewise_constant([durations], [values])\n            .linear(start, stop, duration)`: to append another linear waveform\n        - `...piecewise_constant([durations], [values])\n            .constant(value, duration)`: to append a constant waveform\n        - `...piecewise_constant([durations], [values])\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...piecewise_constant([durations], [values])\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...piecewise_constant([durations], [values])\n            .poly([coefficients], duration)`: to append a polynomial waveform\n        - `...piecewise_constant([durations], [values])\n            .apply(waveform)`: to append a pre-defined waveform\n        - `...piecewise_constant([durations], [values]).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...piecewise_constant([durations], [values])\n            .slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...piecewise_constant([durations], [values])\n            .record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...piecewise_constant([durations], [values]).uniform`:\n            To address all atoms in the field\n        - `...piecewise_constant([durations], [values]).location(int)`:\n            To address an atom at a specific location via index\n        - `...piecewise_constant([durations], [values]).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning it a\n                list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...piecewise_constant([durations], [values])\n            .assign(variable_name = value)`: to assign a single value to a variable\n        - `...piecewise_constant([durations], [values])\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...piecewise_constant([durations], [values])\n            .args([\"previously_defined_var\"])`: to defer assignment\n            of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...piecewise_constant([durations], [values]).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...piecewise_constant([durations], [values]).bloqade`:\n            to run on the Bloqade local emulator\n        - `...piecewise_constant([durations], [values]).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...piecewise_constat([durations], [values]).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...piecewise_constant([durations], [values]).rydberg`:\n            to target the Rydberg level coupling\n        - `...piecewise_constant([durations], [values]).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...piecewise_constant(durations, values).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...piecewise_constant([durations], [values]).phase`:\n            to target the real-valued Rabi Phase field\n        - `...piecewise_constant([durations], [values]).detuning`:\n            to target the Detuning field\n        - `...piecewise_constant([durations], [values]).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return PiecewiseConstant(durations, values, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.piecewise_linear","title":"piecewise_linear","text":"<pre><code>piecewise_linear(durations, values)\n</code></pre> <p>Append or assign a piecewise linear waveform to current location(s), where the waveform is formed by connecting <code>values[i], values[i+1]</code> with linear segments.</p> <p>The <code>durations</code> argument should have # of elements = len(values) - 1. <code>durations</code> should be the duration PER section of the waveform, NON-CUMULATIVE.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.piecewise_linear--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# ramp our waveform up to a certain value, hold it\n# then ramp down. In this case, we ramp up to 2.0 rad/us in 0.3 us,\n# then hold it for 1.5 us before ramping down in 0.3 us back to 0.0 rad/us.\n&gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...piecewise_linear([durations], [values])     .linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...piecewise_linear([durations], [values]).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...piecewise_linear([durations], [values])     .piecewise_linear(durations, values)</code>:     to append a piecewise linear waveform</li> <li><code>...piecewise_linear([durations], [values])     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...piecewise_linear([durations], [values])     .poly([coefficients], duration)</code>: to append a polynomial waveform</li> <li><code>...piecewise_linear([durations], [values]).apply(waveform)</code>:     to append a pre-defined waveform</li> <li><code>...piecewise_linear([durations], [values]).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...piecewise_linear([durations], [values])     .slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...piecewise_linear([durations], [values])     .record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...piecewise_linear([durations], [values]).uniform</code>:     To address all atoms in the field</li> <li><code>...piecewise_linear([durations], [values]).scale(...)</code>:     To address an atom at a specific location via index</li> <li><code>...piecewise_linear([durations], [values]).location(int)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning it a     list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...piecewise_linear([durations], [values])     .assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...piecewise_linear([durations], [values])     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...piecewise_linear([durations], [values])     .args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...piecewise_linear([durations], [values]).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...piecewise_linear([durations], [values]).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...piecewise_linear([durations], [values]).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...piecewise_linear([durations], [values]).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...piecewise_linear([durations], [values]).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...piecewise_linear([durations], [values]).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...piecewise_linear([durations], [values]).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...piecewise_linear([durations], [values]).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...piecewise_linear([durations], [values]).detuning</code>:     to target the Detuning field</li> <li><code>....rabi</code>: to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef piecewise_linear(\n    self, durations: List[ScalarType], values: List[ScalarType]\n) -&gt; \"PiecewiseLinear\":\n    \"\"\"\n    Append or assign a piecewise linear waveform to current location(s),\n    where the waveform is formed by connecting `values[i], values[i+1]`\n    with linear segments.\n\n    The `durations` argument should have # of elements = len(values) - 1.\n    `durations` should be the duration PER section of the waveform, NON-CUMULATIVE.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # ramp our waveform up to a certain value, hold it\n    # then ramp down. In this case, we ramp up to 2.0 rad/us in 0.3 us,\n    # then hold it for 1.5 us before ramping down in 0.3 us back to 0.0 rad/us.\n    &gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...piecewise_linear([durations], [values])\n            .linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...piecewise_linear([durations], [values]).constant(value, duration)`:\n            to append a constant waveform\n        - `...piecewise_linear([durations], [values])\n            .piecewise_linear(durations, values)`:\n            to append a piecewise linear waveform\n        - `...piecewise_linear([durations], [values])\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...piecewise_linear([durations], [values])\n            .poly([coefficients], duration)`: to append a polynomial waveform\n        - `...piecewise_linear([durations], [values]).apply(waveform)`:\n            to append a pre-defined waveform\n        - `...piecewise_linear([durations], [values]).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...piecewise_linear([durations], [values])\n            .slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...piecewise_linear([durations], [values])\n            .record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...piecewise_linear([durations], [values]).uniform`:\n            To address all atoms in the field\n        - `...piecewise_linear([durations], [values]).scale(...)`:\n            To address an atom at a specific location via index\n        - `...piecewise_linear([durations], [values]).location(int)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning it a\n                list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...piecewise_linear([durations], [values])\n            .assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...piecewise_linear([durations], [values])\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...piecewise_linear([durations], [values])\n            .args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...piecewise_linear([durations], [values]).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...piecewise_linear([durations], [values]).bloqade`:\n            to run on the Bloqade local emulator\n        - `...piecewise_linear([durations], [values]).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...piecewise_linear([durations], [values]).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...piecewise_linear([durations], [values]).rydberg`:\n            to target the Rydberg level coupling\n        - `...piecewise_linear([durations], [values]).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...piecewise_linear([durations], [values]).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...piecewise_linear([durations], [values]).phase`:\n            to target the real-valued Rabi Phase field\n        - `...piecewise_linear([durations], [values]).detuning`:\n            to target the Detuning field\n        - `....rabi`: to target the complex-valued Rabi field\n    \"\"\"\n    return PiecewiseLinear(durations, values, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.poly","title":"poly","text":"<pre><code>poly(coeffs, duration)\n</code></pre> <p>Append or assign a waveform with a polynomial profile to current location(s).</p> <p>You pass in a list of coefficients and a duration to this method which obeys the following expression:</p> <p><code>wv(t) = coeffs[0] + coeffs[1]*t + coeffs[2]*t^2 + ... + coeffs[n]*t^n</code></p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.poly--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n&gt;&gt;&gt; coeffs = [-1, 0.5, 1.2]\n# resulting polynomial is:\n# f(t) = -1 + 0.5*t + 1.2*t^2 with duration of\n# 0.5 us\n&gt;&gt;&gt; prog.poly(coeffs, duration=0.5)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...poly([coeffs], duration).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...poly([coeffs], duration).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...poly([coeffs], duration)     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...poly([coeffs], duration)     .piecewise_constant([durations],[values])</code>:     to append a piecewise constant waveform</li> <li><code>...poly([coeffs], duration).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...poly([coeffs], duration).apply(waveform)</code>:     to append a pre-defined waveform</li> <li><code>...poly([coeffs], duration).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...poly([coeffs], duration).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...poly([coeffs], duration).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...poly([coeffs], duration).uniform</code>:     To address all atoms in the field</li> <li><code>...poly([coeffs], duration).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...poly([coeffs], duration).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning     it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...poly([coeffs], duration).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...poly([coeffs], duration)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...poly([coeffs], duration).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...poly([coeffs], duration).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...poly([coeffs], duration).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...poly([coeffs], duration).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...poly([coeffs], duration).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...poly([coeffs], duration).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...poly([coeffs], duration).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level   coupling (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...poly([coeffs], duration).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...poly([coeffs], duration).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...poly([coeffs], duration).detuning</code>:     to target the Detuning field</li> <li><code>...poly([coeffs], duration).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef poly(self, coeffs: List[ScalarType], duration: ScalarType) -&gt; \"Poly\":\n    \"\"\"\n    Append or assign a waveform with a polynomial profile to current location(s).\n\n    You pass in a list of coefficients and a duration to this method which obeys\n    the following expression:\n\n    `\n    wv(t) = coeffs[0] + coeffs[1]*t + coeffs[2]*t^2 + ... + coeffs[n]*t^n\n    `\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    &gt;&gt;&gt; coeffs = [-1, 0.5, 1.2]\n    # resulting polynomial is:\n    # f(t) = -1 + 0.5*t + 1.2*t^2 with duration of\n    # 0.5 us\n    &gt;&gt;&gt; prog.poly(coeffs, duration=0.5)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...poly([coeffs], duration).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...poly([coeffs], duration).constant(value, duration)`:\n            to append a constant waveform\n        - `...poly([coeffs], duration)\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...poly([coeffs], duration)\n            .piecewise_constant([durations],[values])`:\n            to append a piecewise constant waveform\n        - `...poly([coeffs], duration).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...poly([coeffs], duration).apply(waveform)`:\n            to append a pre-defined waveform\n        - `...poly([coeffs], duration).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...poly([coeffs], duration).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...poly([coeffs], duration).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...poly([coeffs], duration).uniform`:\n            To address all atoms in the field\n        - `...poly([coeffs], duration).location(int)`:\n            To address an atom at a specific location via index\n        - `...poly([coeffs], duration).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning\n                it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...poly([coeffs], duration).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...poly([coeffs], duration)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...poly([coeffs], duration).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...poly([coeffs], duration).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...poly([coeffs], duration).bloqade`:\n            to run on the Bloqade local emulator\n        - `...poly([coeffs], duration).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...poly([coeffs], duration).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...poly([coeffs], duration).rydberg`:\n            to target the Rydberg level coupling\n        - `...poly([coeffs], duration).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level\n      coupling (previously selected as `rydberg` or `hyperfine`):\n        - `...poly([coeffs], duration).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...poly([coeffs], duration).phase`:\n            to target the real-valued Rabi Phase field\n        - `...poly([coeffs], duration).detuning`:\n            to target the Detuning field\n        - `...poly([coeffs], duration).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return Poly(coeffs, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/backend/","title":"Index","text":""},{"location":"reference/bloqade/builder/backend/#bloqade.builder.backend.BackendRoute","title":"BackendRoute","text":"<pre><code>BackendRoute(parent=None)\n</code></pre> <p>             Bases: <code>QuEraService</code>, <code>BraketService</code>, <code>BloqadeService</code></p> <p>Specify the backend to run your program on via a string (versus more formal builder syntax) of specifying the vendor/product first (Bloqade/Braket) and narrowing it down (e.g: ...device(\"quera.aquila\") versus ...quera.aquila()) - You can pass the following arguments:     - <code>\"braket.aquila\"</code>     - <code>\"braket.local_emulator\"</code>     - <code>\"bloqade.python\"</code>     - <code>\"bloqade.julia\"</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/backend/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeDeviceRoute","title":"BloqadeDeviceRoute","text":"<pre><code>BloqadeDeviceRoute(parent=None)\n</code></pre> <p>             Bases: <code>Builder</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeDeviceRoute.python","title":"python","text":"<pre><code>python()\n</code></pre> <p>Specify the Bloqade Python backend.</p> <ul> <li>Possible Next Steps:<ul> <li><code>...python().run(shots)</code>:     to submit to the python emulator and await results</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/backend/bloqade.py</code> <pre><code>def python(self):\n    \"\"\"\n    Specify the Bloqade Python backend.\n\n    - Possible Next Steps:\n        - `...python().run(shots)`:\n            to submit to the python emulator and await results\n    \"\"\"\n    return self.parse().bloqade.python()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeService","title":"BloqadeService","text":"<pre><code>BloqadeService(parent=None)\n</code></pre> <p>             Bases: <code>Builder</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeService.bloqade","title":"bloqade  <code>property</code>","text":"<pre><code>bloqade\n</code></pre> <p>Specify the Bloqade backend.</p> <ul> <li>Possible Next Steps:<ul> <li><code>...bloqade.python()</code>: target submission to the Bloqade python backend</li> <li><code>...bloqade.julia()</code>: (CURRENTLY NOT IMPLEMENTED!)target     submission to the Bloqade.jl backend</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/backend/braket/","title":"Braket","text":""},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute","title":"BraketDeviceRoute","text":"<pre><code>BraketDeviceRoute(parent=None)\n</code></pre> <p>             Bases: <code>Builder</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute.aquila","title":"aquila","text":"<pre><code>aquila()\n</code></pre> <p>Specify QuEra's Aquila QPU on Braket to submit your program to.</p> <p>The number of shots you specify in the subsequent <code>.run</code> method will either:     - dictate the number of times your program is run     - dictate the number of times per parameter your program is run if       you have a variable with batch assignments/intend to conduct       a parameter sweep</p> <ul> <li>Possible next steps are:<ul> <li><code>...aquila().run(shots)</code>: To submit to hardware and WAIT for     results (blocking)</li> <li><code>...aquila().run_async(shots)</code>: To submit to hardware and immediately     allow for other operations to occur</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/backend/braket.py</code> <pre><code>def aquila(self) -&gt; \"BraketHardwareRoutine\":\n    \"\"\"\n    Specify QuEra's Aquila QPU on Braket to submit your program to.\n\n    The number of shots you specify in the subsequent `.run` method will either:\n        - dictate the number of times your program is run\n        - dictate the number of times per parameter your program is run if\n          you have a variable with batch assignments/intend to conduct\n          a parameter sweep\n\n\n    - Possible next steps are:\n        - `...aquila().run(shots)`: To submit to hardware and WAIT for\n            results (blocking)\n        - `...aquila().run_async(shots)`: To submit to hardware and immediately\n            allow for other operations to occur\n    \"\"\"\n    return self.parse().braket.aquila()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute.device","title":"device","text":"<pre><code>device(device_arn)\n</code></pre> <p>Specify QPU based on the device ARN on Braket to submit your program to.</p> <p>The number of shots you specify in the subsequent <code>.run</code> method will either:     - dictate the number of times your program is run     - dictate the number of times per parameter your program is run if         you have a variable with batch assignments/intend to conduct         a parameter sweep</p> <ul> <li>Possible next steps are:<ul> <li><code>...device(arn).run(shots)</code>: To submit to hardware and WAIT for     results (blocking)</li> <li><code>...device(arn).run_async(shots)</code>: To submit to hardware and immediately     allow for other operations to occur</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/backend/braket.py</code> <pre><code>def device(self, device_arn) -&gt; \"BraketHardwareRoutine\":\n    \"\"\"\n    Specify QPU based on the device ARN on Braket to submit your program to.\n\n    The number of shots you specify in the subsequent `.run` method will either:\n        - dictate the number of times your program is run\n        - dictate the number of times per parameter your program is run if\n            you have a variable with batch assignments/intend to conduct\n            a parameter sweep\n\n\n    - Possible next steps are:\n        - `...device(arn).run(shots)`: To submit to hardware and WAIT for\n            results (blocking)\n        - `...device(arn).run_async(shots)`: To submit to hardware and immediately\n            allow for other operations to occur\n    \"\"\"\n    return self.parse().braket.device(device_arn)\n</code></pre>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute.local_emulator","title":"local_emulator","text":"<pre><code>local_emulator()\n</code></pre> <p>Specify the Braket local emulator to submit your program to.</p> <ul> <li>The number of shots you specify in the subsequent <code>.run</code> method will either:<ul> <li>dictate the number of times your program is run</li> <li>dictate the number of times per parameter your program is run if   you have a variable with batch assignments/intend to   conduct a parameter sweep</li> </ul> </li> <li>Possible next steps are:<ul> <li><code>...local_emulator().run(shots)</code>: to submit to the emulator     and await results</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/backend/braket.py</code> <pre><code>def local_emulator(self) -&gt; \"BraketLocalEmulatorRoutine\":\n    \"\"\"\n    Specify the Braket local emulator to submit your program to.\n\n    - The number of shots you specify in the subsequent `.run` method will either:\n        - dictate the number of times your program is run\n        - dictate the number of times per parameter your program is run if\n          you have a variable with batch assignments/intend to\n          conduct a parameter sweep\n    - Possible next steps are:\n        - `...local_emulator().run(shots)`: to submit to the emulator\n            and await results\n\n    \"\"\"\n    return self.parse().braket.local_emulator()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketService","title":"BraketService","text":"<pre><code>BraketService(parent=None)\n</code></pre> <p>             Bases: <code>Builder</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketService.braket","title":"braket  <code>property</code>","text":"<pre><code>braket\n</code></pre> <p>Specify the Braket backend. This allows you to access the AWS Braket local emulator OR go submit things to QuEra hardware on AWS Braket service.</p> <ul> <li>Possible Next Steps are:<ul> <li><code>...braket.aquila()</code>: target submission to the QuEra Aquila QPU</li> <li><code>...braket.local_emulator()</code>: target submission to the Braket local emulator</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/backend/quera/","title":"Quera","text":""},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute","title":"QuEraDeviceRoute","text":"<pre><code>QuEraDeviceRoute(parent=None)\n</code></pre> <p>             Bases: <code>Builder</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.aquila","title":"aquila","text":"<pre><code>aquila()\n</code></pre> <p>Specify QuEra's Aquila QPU</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def aquila(self):\n    \"\"\"\n    Specify QuEra's Aquila QPU\n\n    Return:\n        QuEraHardwareRoutine\n\n\n    - Possible Next:\n\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n    \"\"\"\n    return self.parse().quera.aquila()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.cloud_mock","title":"cloud_mock","text":"<pre><code>cloud_mock()\n</code></pre> <p>Specify QuEra's Remote Mock QPU</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def cloud_mock(self):\n    \"\"\"\n    Specify QuEra's Remote Mock QPU\n\n    Return:\n        QuEraHardwareRoutine\n\n    - Possible Next:\n\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n\n    \"\"\"\n    return self.parse().quera.cloud_mock()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.custom","title":"custom","text":"<pre><code>custom()\n</code></pre> <p>Specify custom backend</p> Return <p>CustomSubmissionRoutine</p> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def custom(self):\n    \"\"\"\n    Specify custom backend\n\n    Return:\n        CustomSubmissionRoutine\n\n    \"\"\"\n\n    return self.parse().quera.custom()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.device","title":"device","text":"<pre><code>device(config_file=None, **api_config)\n</code></pre> <p>Specify QuEra's QPU device,</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>file that speficy the target hardware</p> <code>None</code> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...device().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...device().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...device().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def device(self, config_file: Optional[str] = None, **api_config):\n    \"\"\"\n    Specify QuEra's QPU device,\n\n    Args:\n        config_file (str): file that speficy the target hardware\n\n    Return:\n        QuEraHardwareRoutine\n\n    - Possible Next:\n\n        -&gt; `...device().submit`\n            :: submit aync remote job\n\n        -&gt; `...device().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...device().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n    \"\"\"\n    return self.parse().quera.device(config_file, **api_config)\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.mock","title":"mock","text":"<pre><code>mock(state_file='.mock_state.txt', submission_error=False)\n</code></pre> <p>Specify mock, testing locally.</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def mock(self, state_file: str = \".mock_state.txt\", submission_error: bool = False):\n    \"\"\"\n    Specify mock, testing locally.\n\n    Return:\n        QuEraHardwareRoutine\n\n    - Possible Next:\n\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n\n    \"\"\"\n    return self.parse().quera.mock(\n        state_file=state_file, submission_error=submission_error\n    )\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraService","title":"QuEraService","text":"<pre><code>QuEraService(parent=None)\n</code></pre> <p>             Bases: <code>Builder</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraService.quera","title":"quera  <code>property</code>","text":"<pre><code>quera\n</code></pre> <ul> <li>Specify Quera backend</li> <li> <p>Possible Next:</p> <p>-&gt; <code>...quera.aquila</code>     :: Aquila QPU</p> <p>-&gt; <code>...quera.mock</code>     :: mock backend, meant for testings</p> <p>-&gt; <code>...quera.device</code>     :: QuEra QPU, specifiy by config_file</p> </li> </ul>"},{"location":"reference/bloqade/builder/parse/","title":"Index","text":""},{"location":"reference/bloqade/builder/parse/builder/","title":"Builder","text":"<p>Module for parsing builder definitions into intermediate representation (IR) using the bloqade library.</p> <p>This module provides a Parser class for parsing various components of a quantum computing program, including atom arrangements, pulse sequences, analog circuits, and routines. It also defines utility functions for reading addresses, waveforms, drives, sequences, registers, and pragmas from a builder stream.</p>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser","title":"Parser","text":"<p>A class for parsing quantum computing program components into intermediate representation (IR).</p>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser.parse","title":"parse","text":"<pre><code>parse(builder)\n</code></pre> <p>Parse a routine from the builder.</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Builder</code> <p>The builder instance.</p> required <p>Returns:</p> Name Type Description <code>Routine</code> <code>Routine</code> <p>The parsed routine.</p> Source code in <code>src/bloqade/builder/parse/builder.py</code> <pre><code>def parse(self, builder: Builder) -&gt; \"Routine\":\n    \"\"\"\n    Parse a routine from the builder.\n\n    Args:\n        builder (Builder): The builder instance.\n\n    Returns:\n        Routine: The parsed routine.\n    \"\"\"\n    from bloqade.ir.analog_circuit import AnalogCircuit\n    from bloqade.ir.routine.params import Params, ScalarArg, VectorArg\n    from bloqade.ir.routine.base import Routine\n    from bloqade.compiler.analysis.common.scan_variables import ScanVariables\n\n    self.reset(builder)\n    self.read_register()\n    self.read_sequence()\n    self.read_pragmas()\n\n    circuit = AnalogCircuit(self.register, self.sequence)\n\n    var_res = ScanVariables().scan(circuit)\n    # mark vector and scalar arguments\n    args_list = [\n        (VectorArg(name) if name in var_res.vector_vars else ScalarArg(name))\n        for name in self.order\n    ]\n\n    params = Params(\n        n_sites=self.register.n_sites,\n        static_params=self.static_params,\n        batch_params=self.batch_params,\n        args_list=args_list,\n    )\n\n    return Routine(builder, circuit, params)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser.parse_circuit","title":"parse_circuit","text":"<pre><code>parse_circuit(builder)\n</code></pre> <p>Parse an analog circuit from the builder.</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Builder</code> <p>The builder instance.</p> required <p>Returns:</p> Name Type Description <code>AnalogCircuit</code> <code>AnalogCircuit</code> <p>The parsed analog circuit.</p> Source code in <code>src/bloqade/builder/parse/builder.py</code> <pre><code>def parse_circuit(self, builder: Builder) -&gt; \"AnalogCircuit\":\n    \"\"\"\n    Parse an analog circuit from the builder.\n\n    Args:\n        builder (Builder): The builder instance.\n\n    Returns:\n        AnalogCircuit: The parsed analog circuit.\n    \"\"\"\n    from bloqade.ir.analog_circuit import AnalogCircuit\n\n    self.reset(builder)\n    self.read_register()\n    self.read_sequence()\n\n    circuit = AnalogCircuit(self.register, self.sequence)\n\n    return circuit\n</code></pre>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser.parse_register","title":"parse_register","text":"<pre><code>parse_register(builder)\n</code></pre> <p>Parse an atom arrangement register from the builder.</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Builder</code> <p>The builder instance.</p> required <p>Returns:</p> Type Description <code>Union[AtomArrangement, ParallelRegister]</code> <p>Union[ir.AtomArrangement, ir.ParallelRegister]: The parsed atom arrangement or parallel register.</p> Source code in <code>src/bloqade/builder/parse/builder.py</code> <pre><code>def parse_register(\n    self, builder: Builder\n) -&gt; Union[ir.AtomArrangement, ir.ParallelRegister]:\n    \"\"\"\n    Parse an atom arrangement register from the builder.\n\n    Args:\n        builder (Builder): The builder instance.\n\n    Returns:\n        Union[ir.AtomArrangement, ir.ParallelRegister]: The parsed atom arrangement or parallel register.\n    \"\"\"\n    self.reset(builder)\n    self.read_register()\n    self.read_pragmas()\n    return self.register\n</code></pre>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser.parse_sequence","title":"parse_sequence","text":"<pre><code>parse_sequence(builder)\n</code></pre> <p>Parse a sequence from the builder.</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Builder</code> <p>The builder instance.</p> required <p>Returns:</p> Type Description <code>Sequence</code> <p>ir.Sequence: The parsed sequence.</p> Source code in <code>src/bloqade/builder/parse/builder.py</code> <pre><code>def parse_sequence(self, builder: Builder) -&gt; ir.Sequence:\n    \"\"\"\n    Parse a sequence from the builder.\n\n    Args:\n        builder (Builder): The builder instance.\n\n    Returns:\n        ir.Sequence: The parsed sequence.\n    \"\"\"\n    self.reset(builder)\n    self.read_sequence()\n    return self.sequence\n</code></pre>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser.read_address","title":"read_address","text":"<pre><code>read_address(stream)\n</code></pre> <p>Read an address from the builder stream.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <p>The builder stream.</p> required <p>Returns:</p> Type Description <code>Tuple[LevelCoupling, Field, BuilderNode]</code> <p>Tuple[LevelCoupling, Field, BuilderNode]: A tuple containing the level coupling, field, and spatial modulation.</p> Source code in <code>src/bloqade/builder/parse/builder.py</code> <pre><code>def read_address(self, stream) -&gt; Tuple[LevelCoupling, Field, BuilderNode]:\n    \"\"\"\n    Read an address from the builder stream.\n\n    Args:\n        stream: The builder stream.\n\n    Returns:\n        Tuple[LevelCoupling, Field, BuilderNode]: A tuple containing the level coupling, field, and spatial modulation.\n    \"\"\"\n    spatial = stream.read_next([Location, Uniform, Scale])\n    curr = spatial\n\n    if curr is None:\n        return (None, None, None)\n\n    while curr.next is not None:\n        if not isinstance(curr.node, SpatialModulation):\n            break\n        curr = curr.next\n\n    if type(spatial.node.__parent__) in [Detuning, RabiAmplitude, RabiPhase]:\n        field = spatial.node.__parent__  # field is updated\n        if type(field) in [RabiAmplitude, RabiPhase]:\n            coupling = field.__parent__.__parent__  # skip Rabi\n        else:\n            coupling = field.__parent__\n\n        # coupling not updated\n        if type(coupling) not in [Rydberg, Hyperfine]:\n            coupling = None\n        return (coupling, field, spatial)\n    else:  # only spatial is updated\n        return (None, None, spatial)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser.read_drive","title":"read_drive","text":"<pre><code>read_drive(head)\n</code></pre> <p>Read a drive from the builder stream.</p> <p>Parameters:</p> Name Type Description Default <code>head</code> <p>The head of the builder stream.</p> required <p>Returns:</p> Type Description <code>Field</code> <p>ir.Field: The drive field.</p> Source code in <code>src/bloqade/builder/parse/builder.py</code> <pre><code>def read_drive(self, head) -&gt; ir.Field:\n    \"\"\"\n    Read a drive from the builder stream.\n\n    Args:\n        head: The head of the builder stream.\n\n    Returns:\n        ir.Field: The drive field.\n    \"\"\"\n    if head is None:\n        return ir.Field({})\n\n    sm = head.node.__bloqade_ir__()\n    wf, _ = self.read_waveform(head.next)\n\n    return ir.Field({sm: wf})\n</code></pre>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser.read_pragmas","title":"read_pragmas","text":"<pre><code>read_pragmas()\n</code></pre> <p>Read pragmas from the builder stream.</p> Source code in <code>src/bloqade/builder/parse/builder.py</code> <pre><code>def read_pragmas(self) -&gt; None:\n    \"\"\"Read pragmas from the builder stream.\"\"\"\n    pragma_types = (\n        Assign,\n        BatchAssign,\n        ListAssign,\n        Args,\n        Parallelize,\n    )\n\n    stream = self.stream.copy()\n    curr = stream.read_next(pragma_types)\n\n    while curr is not None:\n        node = curr.node\n\n        if isinstance(node, Assign):\n            self.static_params = dict(node._static_params)\n        elif isinstance(node, BatchAssign) or isinstance(node, ListAssign):\n            self.batch_params = node._batch_params\n        elif isinstance(node, Args):\n            order = node._order\n\n            seen = set()\n            dup = []\n            for x in order:\n                if x not in seen:\n                    seen.add(x)\n                else:\n                    dup.append(x)\n\n            if dup:\n                raise ValueError(f\"Cannot have duplicate names {dup}.\")\n\n            self.order = order\n\n        elif isinstance(node, Parallelize):\n            self.register = ir.ParallelRegister(\n                self.register, node._cluster_spacing\n            )\n        else:\n            break\n\n        curr = curr.next\n</code></pre>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser.read_register","title":"read_register","text":"<pre><code>read_register()\n</code></pre> <p>Read an atom arrangement register from the builder stream.</p> <p>Returns:</p> Type Description <code>AtomArrangement</code> <p>ir.AtomArrangement: The parsed atom arrangement.</p> Source code in <code>src/bloqade/builder/parse/builder.py</code> <pre><code>def read_register(self) -&gt; ir.AtomArrangement:\n    \"\"\"\n    Read an atom arrangement register from the builder stream.\n\n    Returns:\n        ir.AtomArrangement: The parsed atom arrangement.\n    \"\"\"\n    # register is always head of the stream\n    register_node = self.stream.read()\n    self.register = register_node.node\n\n    return self.register\n</code></pre>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser.read_sequence","title":"read_sequence","text":"<pre><code>read_sequence()\n</code></pre> <p>Read a sequence from the builder stream.</p> <p>Returns:</p> Type Description <code>Sequence</code> <p>ir.Sequence: The parsed sequence.</p> Source code in <code>src/bloqade/builder/parse/builder.py</code> <pre><code>def read_sequence(self) -&gt; ir.Sequence:\n    \"\"\"\n    Read a sequence from the builder stream.\n\n    Returns:\n        ir.Sequence: The parsed sequence.\n    \"\"\"\n    if isinstance(self.stream.curr.node, SequenceBuilder):\n        # case with sequence builder object.\n        self.sequence = self.stream.read().node._sequence\n        return self.sequence\n\n    stream = self.stream.copy()\n    while stream.curr is not None:\n        coupling_builder, field_builder, spatial_head = self.read_address(stream)\n\n        if coupling_builder is not None:\n            # update to new pulse coupling\n            self.coupling_name = coupling_builder.__bloqade_ir__()\n\n        if field_builder is not None:\n            # update to new field coupling\n            self.field_name = field_builder.__bloqade_ir__()\n\n        if spatial_head is None:\n            break\n\n        pulse = self.sequence.pulses.get(self.coupling_name, ir.Pulse({}))\n        field = pulse.fields.get(self.field_name, ir.Field({}))\n\n        drive = self.read_drive(spatial_head)\n        field = field.add(drive)\n\n        pulse = ir.Pulse.create(pulse.fields | {self.field_name: field})\n        self.sequence = ir.Sequence.create(\n            self.sequence.pulses | {self.coupling_name: pulse}\n        )\n\n    return self.sequence\n</code></pre>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser.read_waveform","title":"read_waveform","text":"<pre><code>read_waveform(head)\n</code></pre> <p>Read a waveform from the builder stream.</p> <p>Parameters:</p> Name Type Description Default <code>head</code> <code>BuilderNode</code> <p>The head of the builder stream.</p> required <p>Returns:</p> Type Description <code>Tuple[Waveform, BuilderNode]</code> <p>Tuple[ir.Waveform, BuilderNode]: A tuple containing the waveform and the next builder node.</p> Source code in <code>src/bloqade/builder/parse/builder.py</code> <pre><code>def read_waveform(self, head: BuilderNode) -&gt; Tuple[ir.Waveform, BuilderNode]:\n    \"\"\"\n    Read a waveform from the builder stream.\n\n    Args:\n        head (BuilderNode): The head of the builder stream.\n\n    Returns:\n        Tuple[ir.Waveform, BuilderNode]: A tuple containing the waveform and the next builder node.\n    \"\"\"\n    curr = head\n    waveform = None\n    while curr is not None:\n        node = curr.node\n\n        if isinstance(node, Slice):\n            waveform = waveform[node._start : node._stop]\n        elif isinstance(node, Record):\n            waveform = waveform.record(node._name)\n        elif isinstance(node, Sample):\n            interpolation = node._interpolation\n            if interpolation is None:\n                if self.field_name == ir.rabi.phase:\n                    interpolation = ir.Interpolation.Constant\n                else:\n                    interpolation = ir.Interpolation.Linear\n            fn_waveform = node.__parent__.__bloqade_ir__()\n            sample_waveform = ir.Sample(fn_waveform, interpolation, node._dt)\n            if waveform is None:\n                waveform = sample_waveform\n            else:\n                waveform = waveform.append(sample_waveform)\n        elif (\n            isinstance(node, Fn)\n            and curr.next is not None\n            and isinstance(curr.next.node, Sample)\n        ):\n            pass\n        elif isinstance(node, WaveformPrimitive):\n            if waveform is None:\n                waveform = node.__bloqade_ir__()\n            else:\n                waveform = waveform.append(node.__bloqade_ir__())\n        else:\n            break\n\n        curr = curr.next\n\n    return waveform, curr\n</code></pre>"},{"location":"reference/bloqade/builder/parse/builder/#bloqade.builder.parse.builder.Parser.reset","title":"reset","text":"<pre><code>reset(builder)\n</code></pre> <p>Reset the parser's state.</p> Source code in <code>src/bloqade/builder/parse/builder.py</code> <pre><code>def reset(self, builder: Builder):\n    \"\"\"Reset the parser's state.\"\"\"\n    self.stream = BuilderStream.create(builder)\n    self.vector_node_names = set()\n    self.sequence = ir.Sequence.create()\n    self.register = None\n    self.batch_params = [{}]\n    self.static_params = {}\n    self.order = ()\n</code></pre>"},{"location":"reference/bloqade/builder/parse/stream/","title":"Stream","text":"<p>Module for managing a stream of builder nodes.</p> <p>This module provides classes to represent builder nodes and builder streams. A builder node is a single element in the stream, representing a step in a construction process. A builder stream is a sequence of builder nodes, allowing traversal and manipulation of the construction steps.</p>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderNode","title":"BuilderNode  <code>dataclass</code>","text":"<p>A node in the builder stream.</p>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderNode.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Representation of the BuilderNode.</p> Source code in <code>src/bloqade/builder/parse/stream.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Representation of the BuilderNode.\"\"\"\n    return repr(self.node)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream","title":"BuilderStream  <code>dataclass</code>","text":"<p>Represents a stream of builder nodes.</p>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterator method to iterate over the builder stream.</p> Source code in <code>src/bloqade/builder/parse/stream.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterator method to iterate over the builder stream.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream.__next__","title":"__next__","text":"<pre><code>__next__()\n</code></pre> <p>Next method to get the next item in the builder stream.</p> Source code in <code>src/bloqade/builder/parse/stream.py</code> <pre><code>def __next__(self):\n    \"\"\"Next method to get the next item in the builder stream.\"\"\"\n    node = self.read()\n    if node is None:\n        raise StopIteration\n    return node\n</code></pre>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream.build_nodes","title":"build_nodes  <code>staticmethod</code>","text":"<pre><code>build_nodes(node)\n</code></pre> <p>Build BuilderNode instances from the provided Builder.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Builder</code> <p>The root Builder instance.</p> required <p>Returns:</p> Name Type Description <code>BuilderNode</code> <code>BuilderNode</code> <p>The head of the linked list of BuilderNodes.</p> Source code in <code>src/bloqade/builder/parse/stream.py</code> <pre><code>@staticmethod\ndef build_nodes(node: Builder) -&gt; \"BuilderNode\":\n    \"\"\"\n    Build BuilderNode instances from the provided Builder.\n\n    Args:\n        node (Builder): The root Builder instance.\n\n    Returns:\n        BuilderNode: The head of the linked list of BuilderNodes.\n    \"\"\"\n    curr = node\n    node = None\n    while curr is not None:\n        next = curr\n        curr = curr.__parent__ if hasattr(curr, \"__parent__\") else None\n        node = BuilderNode(next, node)\n\n    return node\n</code></pre>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Create a copy of the builder stream.</p> Source code in <code>src/bloqade/builder/parse/stream.py</code> <pre><code>def copy(self) -&gt; \"BuilderStream\":\n    \"\"\"Create a copy of the builder stream.\"\"\"\n    return BuilderStream(head=self.head, curr=self.curr)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream.create","title":"create  <code>staticmethod</code>","text":"<pre><code>create(builder)\n</code></pre> <p>Create a BuilderStream instance from a Builder.</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Builder</code> <p>The root Builder instance.</p> required <p>Returns:</p> Name Type Description <code>BuilderStream</code> <code>BuilderStream</code> <p>The created BuilderStream instance.</p> Source code in <code>src/bloqade/builder/parse/stream.py</code> <pre><code>@staticmethod\ndef create(builder: Builder) -&gt; \"BuilderStream\":\n    \"\"\"\n    Create a BuilderStream instance from a Builder.\n\n    Args:\n        builder (Builder): The root Builder instance.\n\n    Returns:\n        BuilderStream: The created BuilderStream instance.\n    \"\"\"\n    head = BuilderStream.build_nodes(builder)\n    return BuilderStream(head=head, curr=head)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream.eat","title":"eat","text":"<pre><code>eat(types, skips=None)\n</code></pre> <p>Move the stream pointer until a node of specified types is found.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>List[Type[Builder]]</code> <p>List of types to move the stream pointer to.</p> required <code>skips</code> <code>List[Type[Builder]] | None</code> <p>List of types to end the stream scan.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BuilderNode</code> <code>BuilderNode</code> <p>The beginning of the stream which matches a type in <code>types</code>.</p> Source code in <code>src/bloqade/builder/parse/stream.py</code> <pre><code>def eat(\n    self, types: List[Type[Builder]], skips: Optional[List[Type[Builder]]] = None\n) -&gt; BuilderNode:\n    \"\"\"\n    Move the stream pointer until a node of specified types is found.\n\n    Args:\n        types (List[Type[Builder]]): List of types to move the stream pointer to.\n        skips (List[Type[Builder]] | None, optional): List of types to end the stream scan.\n\n    Returns:\n        BuilderNode: The beginning of the stream which matches a type in `types`.\n    \"\"\"\n    head = self.read_next(types)\n    curr = head\n    while curr is not None:\n        if type(curr.node) not in types:\n            if skips and type(curr.node) not in skips:\n                break\n        curr = curr.next\n    self.curr = curr\n    return head\n</code></pre>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream.read","title":"read","text":"<pre><code>read()\n</code></pre> <p>Read the next builder node from the stream.</p> Source code in <code>src/bloqade/builder/parse/stream.py</code> <pre><code>def read(self) -&gt; Optional[BuilderNode]:\n    \"\"\"Read the next builder node from the stream.\"\"\"\n    if self.curr is None:\n        return None\n\n    node = self.curr\n    self.curr = self.curr.next\n    return node\n</code></pre>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream.read_next","title":"read_next","text":"<pre><code>read_next(builder_types)\n</code></pre> <p>Read the next builder node of specified types from the stream.</p> <p>Parameters:</p> Name Type Description Default <code>builder_types</code> <code>List[type[Builder]]</code> <p>List of builder types to read from the stream.</p> required <p>Returns:</p> Type Description <code>Optional[BuilderNode]</code> <p>Optional[BuilderNode]: The next builder node matching one of the specified types, or None if not found.</p> Source code in <code>src/bloqade/builder/parse/stream.py</code> <pre><code>def read_next(self, builder_types: List[type[Builder]]) -&gt; Optional[BuilderNode]:\n    \"\"\"\n    Read the next builder node of specified types from the stream.\n\n    Args:\n        builder_types (List[type[Builder]]): List of builder types to read from the stream.\n\n    Returns:\n        Optional[BuilderNode]: The next builder node matching one of the specified types, or None if not found.\n    \"\"\"\n    node = self.read()\n    while node is not None:\n        if type(node.node) in builder_types:\n            return node\n        node = self.read()\n    return None\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/","title":"Trait","text":"<p>Module for parsing and displaying quantum computing program components using the bloqade library.</p>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.Parse","title":"Parse","text":"<p>             Bases: <code>ParseRegister</code>, <code>ParseSequence</code>, <code>ParseCircuit</code>, <code>ParseRoutine</code></p> <p>A composite class inheriting from ParseRegister, ParseSequence, ParseCircuit, and ParseRoutine. Provides a unified interface for parsing different components of the program.</p>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.Parse.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>Return the number of atoms in the program.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of atoms in the parsed register.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the register type is unsupported.</p> Note <p>If the register is of type ParallelRegister, the number of atoms is extracted from its internal register.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Parse):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; n_atoms = builder.n_atoms\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseCircuit","title":"ParseCircuit","text":"<p>A class providing functionality to parse the analog circuit from the program.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(ParseCircuit):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; analog_circuit = builder.parse_circuit()\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseCircuit.parse_circuit","title":"parse_circuit","text":"<pre><code>parse_circuit()\n</code></pre> <p>Parse the analog circuit from the program.</p> <p>Returns:</p> Name Type Description <code>AnalogCircuit</code> <code>AnalogCircuit</code> <p>The parsed analog circuit.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the circuit cannot be parsed.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def parse_circuit(self: \"Builder\") -&gt; \"AnalogCircuit\":\n    \"\"\"\n    Parse the analog circuit from the program.\n\n    Returns:\n        AnalogCircuit: The parsed analog circuit.\n\n    Raises:\n        ValueError: If the circuit cannot be parsed.\n    \"\"\"\n    from bloqade.builder.parse.builder import Parser\n\n    return Parser().parse_circuit(self)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseRegister","title":"ParseRegister","text":"<p>A class providing functionality to parse the arrangement of atoms in the program.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(ParseRegister):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; atom_arrangement = builder.parse_register()\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseRegister.parse_register","title":"parse_register","text":"<pre><code>parse_register()\n</code></pre> <p>Parse the arrangement of atoms in the program.</p> <p>Returns:</p> Type Description <code>Union[AtomArrangement, ParallelRegister]</code> <p>Union[AtomArrangement, ParallelRegister]: The parsed atom arrangement or parallel register.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the register cannot be parsed.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def parse_register(self: \"Builder\") -&gt; Union[\"AtomArrangement\", \"ParallelRegister\"]:\n    \"\"\"\n    Parse the arrangement of atoms in the program.\n\n    Returns:\n        Union[AtomArrangement, ParallelRegister]: The parsed atom arrangement or parallel register.\n\n    Raises:\n        ValueError: If the register cannot be parsed.\n    \"\"\"\n    from bloqade.builder.parse.builder import Parser\n\n    return Parser().parse_register(self)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseRoutine","title":"ParseRoutine","text":"<p>A class providing functionality to parse the program and return a Routine object.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(ParseRoutine):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; routine = builder.parse()\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseRoutine.parse","title":"parse","text":"<pre><code>parse()\n</code></pre> <p>Parse the program to return a Routine object.</p> <p>Returns:</p> Name Type Description <code>Routine</code> <code>Routine</code> <p>The parsed routine object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the routine cannot be parsed.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def parse(self: \"Builder\") -&gt; \"Routine\":\n    \"\"\"\n    Parse the program to return a Routine object.\n\n    Returns:\n        Routine: The parsed routine object.\n\n    Raises:\n        ValueError: If the routine cannot be parsed.\n    \"\"\"\n    from bloqade.builder.parse.builder import Parser\n\n    return Parser().parse(self)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseSequence","title":"ParseSequence","text":"<p>A class providing functionality to parse the pulse sequence part of the program.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(ParseSequence):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; sequence = builder.parse_sequence()\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseSequence.parse_sequence","title":"parse_sequence","text":"<pre><code>parse_sequence()\n</code></pre> <p>Parse the pulse sequence part of the program.</p> <p>Returns:</p> Name Type Description <code>Sequence</code> <code>Sequence</code> <p>The parsed pulse sequence.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sequence cannot be parsed.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def parse_sequence(self: \"Builder\") -&gt; \"Sequence\":\n    \"\"\"\n    Parse the pulse sequence part of the program.\n\n    Returns:\n        Sequence: The parsed pulse sequence.\n\n    Raises:\n        ValueError: If the sequence cannot be parsed.\n    \"\"\"\n    from bloqade.builder.parse.builder import Parser\n\n    return Parser().parse_sequence(self)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.Show","title":"Show","text":"<p>A mixin class providing functionality to display the builder with given arguments and batch ID.</p>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.Show.show","title":"show","text":"<pre><code>show(*args, batch_id=0)\n</code></pre> <p>Display the current program being defined with the given arguments and batch ID.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Additional arguments for display.</p> <code>()</code> <code>batch_id</code> <code>int</code> <p>The batch ID to be displayed. Defaults to 0.</p> <code>0</code> Note <p>This method uses the <code>display_builder</code> function to render the builder's state.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Show):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; builder.show()\n&gt;&gt;&gt; builder.show(batch_id=1)\n&gt;&gt;&gt; builder.show('arg1', 'arg2', batch_id=2)\n</code></pre> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def show(self, *args, batch_id: int = 0):\n    \"\"\"\n    Display the current program being defined with the given arguments and batch ID.\n\n    Args:\n        *args: Additional arguments for display.\n        batch_id (int, optional): The batch ID to be displayed. Defaults to 0.\n\n    Note:\n        This method uses the `display_builder` function to render the builder's state.\n\n    Example:\n\n    ```python\n    &gt;&gt;&gt; class MyBuilder(Show):\n    ...     pass\n    &gt;&gt;&gt; builder = MyBuilder()\n    &gt;&gt;&gt; builder.show()\n    &gt;&gt;&gt; builder.show(batch_id=1)\n    &gt;&gt;&gt; builder.show('arg1', 'arg2', batch_id=2)\n    ```\n    \"\"\"\n    display_builder(self, batch_id, *args)\n</code></pre>"},{"location":"reference/bloqade/compiler/","title":"Index","text":""},{"location":"reference/bloqade/compiler/analysis/","title":"Index","text":""},{"location":"reference/bloqade/compiler/analysis/common/","title":"Index","text":""},{"location":"reference/bloqade/compiler/analysis/common/assignment_scan/","title":"Assignment scan","text":""},{"location":"reference/bloqade/compiler/analysis/common/check_slices/","title":"Check slices","text":""},{"location":"reference/bloqade/compiler/analysis/common/is_constant/","title":"Is constant","text":""},{"location":"reference/bloqade/compiler/analysis/common/is_hyperfine/","title":"Is hyperfine","text":""},{"location":"reference/bloqade/compiler/analysis/common/scan_channels/","title":"Scan channels","text":""},{"location":"reference/bloqade/compiler/analysis/common/scan_variables/","title":"Scan variables","text":""},{"location":"reference/bloqade/compiler/analysis/hardware/","title":"Index","text":""},{"location":"reference/bloqade/compiler/analysis/hardware/#bloqade.compiler.analysis.hardware.BasicLatticeValidation","title":"BasicLatticeValidation","text":"<pre><code>BasicLatticeValidation(capabilities)\n</code></pre> <p>             Bases: <code>BloqadeIRVisitor</code></p> <p>This visitor checks that the AtomArrangement is within the bounds of the lattice and that the number of sites is within the maximum number of sites.</p> Source code in <code>src/bloqade/compiler/analysis/hardware/lattice.py</code> <pre><code>def __init__(self, capabilities: QuEraCapabilities):\n    self.capabilities = capabilities\n</code></pre>"},{"location":"reference/bloqade/compiler/analysis/hardware/#bloqade.compiler.analysis.hardware.ValidateChannels","title":"ValidateChannels","text":"<pre><code>ValidateChannels()\n</code></pre> <p>             Bases: <code>BloqadeIRVisitor</code></p> <p>Checks to make sure the given sequence can be compiled to hardware.</p> <p>This check looks at the spatial modulations and the level coupling to determine if the sequence can be compiled to hardware.</p> Source code in <code>src/bloqade/compiler/analysis/hardware/channels.py</code> <pre><code>def __init__(self):\n    self.field_name = None\n</code></pre>"},{"location":"reference/bloqade/compiler/analysis/hardware/channels/","title":"Channels","text":""},{"location":"reference/bloqade/compiler/analysis/hardware/channels/#bloqade.compiler.analysis.hardware.channels.ValidateChannels","title":"ValidateChannels","text":"<pre><code>ValidateChannels()\n</code></pre> <p>             Bases: <code>BloqadeIRVisitor</code></p> <p>Checks to make sure the given sequence can be compiled to hardware.</p> <p>This check looks at the spatial modulations and the level coupling to determine if the sequence can be compiled to hardware.</p> Source code in <code>src/bloqade/compiler/analysis/hardware/channels.py</code> <pre><code>def __init__(self):\n    self.field_name = None\n</code></pre>"},{"location":"reference/bloqade/compiler/analysis/hardware/lattice/","title":"Lattice","text":""},{"location":"reference/bloqade/compiler/analysis/hardware/lattice/#bloqade.compiler.analysis.hardware.lattice.BasicLatticeValidation","title":"BasicLatticeValidation","text":"<pre><code>BasicLatticeValidation(capabilities)\n</code></pre> <p>             Bases: <code>BloqadeIRVisitor</code></p> <p>This visitor checks that the AtomArrangement is within the bounds of the lattice and that the number of sites is within the maximum number of sites.</p> Source code in <code>src/bloqade/compiler/analysis/hardware/lattice.py</code> <pre><code>def __init__(self, capabilities: QuEraCapabilities):\n    self.capabilities = capabilities\n</code></pre>"},{"location":"reference/bloqade/compiler/analysis/hardware/piecewise_constant/","title":"Piecewise constant","text":""},{"location":"reference/bloqade/compiler/analysis/hardware/piecewise_linear/","title":"Piecewise linear","text":""},{"location":"reference/bloqade/compiler/analysis/python/","title":"Index","text":""},{"location":"reference/bloqade/compiler/analysis/python/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade/compiler/passes/","title":"Index","text":""},{"location":"reference/bloqade/compiler/passes/emulator/","title":"Emulator","text":""},{"location":"reference/bloqade/compiler/passes/hardware/","title":"Index","text":""},{"location":"reference/bloqade/compiler/passes/hardware/#bloqade.compiler.passes.hardware.analyze_channels","title":"analyze_channels","text":"<pre><code>analyze_channels(circuit)\n</code></pre> <ol> <li>Scan channels</li> </ol> <p>This pass checks to make sure that: * There is no hyperfine coupling in the sequence * There are no non-uniform spatial modulation for rabi phase and amplitude * there is no more than one non-uniform spatial modulation for detuning</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to analyze</p> required <p>Returns:</p> Name Type Description <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the required channels for the sequence. Note that this will insert a uniform field for any missing channels.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is hyperfine coupling in the sequence.</p> <code>ValueError</code> <p>If there is more than one non-uniform spatial modulation for detuning.</p> <code>ValueError</code> <p>If there are non-uniform spatial modulations for rabi phase and amplitude.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def analyze_channels(circuit: analog_circuit.AnalogCircuit) -&gt; Dict:\n    \"\"\"1. Scan channels\n\n    This pass checks to make sure that:\n    * There is no hyperfine coupling in the sequence\n    * There are no non-uniform spatial modulation for rabi phase and amplitude\n    * there is no more than one non-uniform spatial modulation for detuning\n\n    Args:\n        circuit: AnalogCircuit to analyze\n\n    Returns:\n        level_couplings: Dictionary containing the required channels for the\n            sequence. Note that this will insert a uniform field for any missing\n            channels.\n\n    Raises:\n        ValueError: If there is hyperfine coupling in the sequence.\n        ValueError: If there is more than one non-uniform spatial modulation for\n            detuning.\n        ValueError: If there are non-uniform spatial modulations for rabi phase\n            and amplitude.\n\n    \"\"\"\n    from bloqade.compiler.analysis.hardware import ValidateChannels\n    from bloqade.compiler.analysis.common import ScanChannels\n\n    ValidateChannels().scan(circuit)\n    level_couplings = ScanChannels().scan(circuit)\n\n    # add missing channels\n    fields = level_couplings[sequence.rydberg]\n    # detuning, phase and amplitude are required\n    # to have at least a uniform field\n    updated_fields = {\n        field_name: fields.get(field_name, {field.Uniform}).union({field.Uniform})\n        for field_name in [pulse.detuning, pulse.rabi.amplitude, pulse.rabi.phase]\n    }\n\n    return {sequence.rydberg: updated_fields}\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/#bloqade.compiler.passes.hardware.assign_circuit","title":"assign_circuit","text":"<pre><code>assign_circuit(circuit, assignments)\n</code></pre> <ol> <li>Assign variables and validate assignment</li> </ol> <p>This pass assigns variables to the circuit and validates that all variables have been assigned.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to assign variables to</p> required <code>assignments</code> <code>Dict[str, ParamType]</code> <p>Dictionary containing the assignments for the variables in the circuit.</p> required <p>Returns:</p> Name Type Description <code>assigned_circuit</code> <code>Tuple[AnalogCircuit, Dict]</code> <p>AnalogCircuit with variables assigned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are any variables that have not been assigned.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def assign_circuit(\n    circuit: analog_circuit.AnalogCircuit, assignments: Dict[str, ParamType]\n) -&gt; Tuple[analog_circuit.AnalogCircuit, Dict]:\n    \"\"\"3. Assign variables and validate assignment\n\n    This pass assigns variables to the circuit and validates that all variables\n    have been assigned.\n\n    Args:\n        circuit: AnalogCircuit to assign variables to\n        assignments: Dictionary containing the assignments for the variables in\n            the circuit.\n\n    Returns:\n        assigned_circuit: AnalogCircuit with variables assigned.\n\n    Raises:\n        ValueError: If there are any variables that have not been assigned.\n\n    \"\"\"\n    from bloqade.compiler.analysis.common import AssignmentScan, ScanVariables\n    from bloqade.compiler.rewrite.common import AssignBloqadeIR\n\n    final_assignments = AssignmentScan(assignments).scan(circuit)\n\n    assigned_circuit = AssignBloqadeIR(final_assignments).visit(circuit)\n\n    assignment_analysis = ScanVariables().scan(assigned_circuit)\n\n    if not assignment_analysis.is_assigned:\n        missing_vars = assignment_analysis.scalar_vars.union(\n            assignment_analysis.vector_vars\n        )\n        raise ValueError(\n            \"Missing assignments for variables:\\n\"\n            + (\"\\n\".join(f\"{var}\" for var in missing_vars))\n            + \"\\n\"\n        )\n\n    return assigned_circuit, final_assignments\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/#bloqade.compiler.passes.hardware.canonicalize_circuit","title":"canonicalize_circuit","text":"<pre><code>canonicalize_circuit(circuit, level_couplings)\n</code></pre> <ol> <li>Insert zero waveform in the explicit time intervals missing a waveform</li> </ol> <p>This pass inserts a zero waveform in the explicit time intervals missing a waveform. This is required for later analysis passes to check that the waveforms are compatible with the hardware.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to add padding to</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <p>Return     circuit: AnalogCircuit with zero waveforms inserted in the explicit time         intervals missing a waveform.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def canonicalize_circuit(\n    circuit: analog_circuit.AnalogCircuit, level_couplings: Dict\n) -&gt; analog_circuit.AnalogCircuit:\n    \"\"\"2. Insert zero waveform in the explicit time intervals missing a waveform\n\n    This pass inserts a zero waveform in the explicit time intervals missing a\n    waveform. This is required for later analysis passes to check that the\n    waveforms are compatible with the hardware.\n\n    Args:\n        circuit: AnalogCircuit to add padding to\n        level_couplings: Dictionary containing the given channels for the\n            sequence.\n\n    Return\n        circuit: AnalogCircuit with zero waveforms inserted in the explicit time\n            intervals missing a waveform.\n\n    \"\"\"\n    from bloqade.compiler.rewrite.common import (\n        AddPadding,\n        AssignToLiteral,\n        Canonicalizer,\n    )\n\n    circuit = AddPadding(level_couplings).visit(circuit)\n    # these two passes are equivalent to a constant propagation pass\n    circuit = AssignToLiteral().visit(circuit)\n    circuit = Canonicalizer().visit(circuit)\n\n    return circuit\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/#bloqade.compiler.passes.hardware.generate_ahs_code","title":"generate_ahs_code","text":"<pre><code>generate_ahs_code(capabilities, level_couplings, circuit)\n</code></pre> <ol> <li>generate ahs code</li> </ol> <p>Generates the AHS code for the given circuit. This includes generating the lattice data, global detuning, global amplitude, global phase, local detuning and lattice site coefficients (if applicable).</p> <p>Parameters:</p> Name Type Description Default <code>capabilities</code> <code>QuEraCapabilities | None</code> <p>Capabilities of the hardware.</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to generate AHS code for.</p> required <p>Returns:</p> Name Type Description <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit. Can be used to generate the QuEra and Braket IR.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the capabilities are not provided but the circuit has a ParallelRegister. This is because the ParallelRegister requires the capabilities to generate the lattice data.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def generate_ahs_code(\n    capabilities: Optional[QuEraCapabilities],\n    level_couplings: Dict,\n    circuit: analog_circuit.AnalogCircuit,\n) -&gt; AHSComponents:\n    \"\"\"5. generate ahs code\n\n    Generates the AHS code for the given circuit. This includes generating the\n    lattice data, global detuning, global amplitude, global phase, local\n    detuning and lattice site coefficients (if applicable).\n\n    Args:\n        capabilities (QuEraCapabilities | None): Capabilities of the hardware.\n        level_couplings (Dict): Dictionary containing the given channels for the\n            sequence.\n        circuit (AnalogCircuit): AnalogCircuit to generate AHS code for.\n\n    Returns:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit. Can be used to generate the QuEra\n            and Braket IR.\n\n    Raises:\n        ValueError: If the capabilities are not provided but the circuit has\n            a ParallelRegister. This is because the ParallelRegister requires\n            the capabilities to generate the lattice data.\n\n    \"\"\"\n    from bloqade.compiler.codegen.hardware import (\n        GenerateLattice,\n        GenerateLatticeSiteCoefficients,\n        GeneratePiecewiseLinearChannel,\n        GeneratePiecewiseConstantChannel,\n    )\n    from bloqade.compiler.analysis.hardware import BasicLatticeValidation\n\n    if capabilities is not None:\n        # only validate the lattice if capabilities are provided\n        BasicLatticeValidation(capabilities).visit(circuit)\n\n    ahs_lattice_data = GenerateLattice(capabilities).emit(circuit)\n\n    global_detuning = GeneratePiecewiseLinearChannel(\n        sequence.rydberg, pulse.detuning, field.Uniform\n    ).visit(circuit)\n\n    global_amplitude = GeneratePiecewiseLinearChannel(\n        sequence.rydberg, pulse.rabi.amplitude, field.Uniform\n    ).visit(circuit)\n\n    global_phase = GeneratePiecewiseConstantChannel(\n        sequence.rydberg, pulse.rabi.phase, field.Uniform\n    ).visit(circuit)\n\n    local_detuning = None\n    lattice_site_coefficients = None\n\n    extra_sm = set(level_couplings[sequence.rydberg][pulse.detuning]) - {field.Uniform}\n\n    if extra_sm:\n        if capabilities is not None and capabilities.capabilities.rydberg.local is None:\n            raise ValueError(\n                \"Device does not support local detuning, but the program has a \"\n                \"non-uniform spatial modulation for detuning.\"\n            )\n\n        sm = extra_sm.pop()\n\n        lattice_site_coefficients = GenerateLatticeSiteCoefficients(\n            parallel_decoder=ahs_lattice_data.parallel_decoder\n        ).emit(circuit)\n\n        local_detuning = GeneratePiecewiseLinearChannel(\n            sequence.rydberg, pulse.detuning, sm\n        ).visit(circuit)\n\n    return AHSComponents(\n        lattice_data=ahs_lattice_data,\n        global_detuning=global_detuning,\n        global_amplitude=global_amplitude,\n        global_phase=global_phase,\n        local_detuning=local_detuning,\n        lattice_site_coefficients=lattice_site_coefficients,\n    )\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/#bloqade.compiler.passes.hardware.generate_braket_ir","title":"generate_braket_ir","text":"<pre><code>generate_braket_ir(ahs_components, shots)\n</code></pre> <ol> <li>generate braket ir</li> </ol> <p>This pass takes the AHS components and generates the Braket IR.</p> <p>Parameters:</p> Name Type Description Default <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit.</p> required <code>shots</code> <code>int</code> <p>Number of shots to run the circuit for.</p> required <p>Returns:</p> Name Type Description <code>task_specification</code> <code>BraketTaskSpecification</code> <p>Braket IR for the given circuit.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def generate_braket_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; BraketTaskSpecification:\n    \"\"\"7. generate braket ir\n\n    This pass takes the AHS components and generates the Braket IR.\n\n    Args:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit.\n        shots (int): Number of shots to run the circuit for.\n\n    Returns:\n        task_specification (BraketTaskSpecification): Braket IR for the given\n            circuit.\n\n    \"\"\"\n    import braket.ir.ahs as ahs\n    from bloqade.compiler.passes.hardware.units import (\n        convert_time_units,\n        convert_energy_units,\n        convert_coordinate_units,\n    )\n\n    ahs_register = ahs.AtomArrangement(\n        sites=list(map(convert_coordinate_units, ahs_components.lattice_data.sites)),\n        filling=ahs_components.lattice_data.filling,\n    )\n\n    global_detuning_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_detuning.times)),\n        values=list(map(convert_energy_units, ahs_components.global_detuning.values)),\n    )\n\n    local_detuning_time_series = None\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning_time_series = ahs.TimeSeries(\n            times=list(map(convert_time_units, ahs_components.local_detuning.times)),\n            values=list(\n                map(convert_energy_units, ahs_components.local_detuning.values)\n            ),\n        )\n\n    amplitude_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_amplitude.times)),\n        values=list(map(convert_energy_units, ahs_components.global_amplitude.values)),\n    )\n\n    phase_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_phase.times)),\n        values=ahs_components.global_phase.values,\n    )\n\n    detuning = ahs.PhysicalField(\n        time_series=global_detuning_time_series,\n        pattern=\"uniform\",\n    )\n\n    amplitude = ahs.PhysicalField(\n        time_series=amplitude_time_series,\n        pattern=\"uniform\",\n    )\n\n    phase = ahs.PhysicalField(\n        time_series=phase_time_series,\n        pattern=\"uniform\",\n    )\n\n    local_detuning = None\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning = ahs.PhysicalField(\n            time_series=local_detuning_time_series,\n            pattern=ahs_components.lattice_site_coefficients,\n        )\n\n    driving_field = ahs.DrivingField(\n        detuning=detuning,\n        amplitude=amplitude,\n        phase=phase,\n    )\n\n    shiftingFields = []\n    if ahs_components.lattice_site_coefficients is not None:\n        shiftingFields = [ahs.ShiftingField(magnitude=local_detuning)]\n\n    program = ahs.Program(\n        setup=ahs.Setup(ahs_register=ahs_register),\n        hamiltonian=ahs.Hamiltonian(\n            drivingFields=[driving_field],\n            shiftingFields=shiftingFields,\n        ),\n    )\n\n    return BraketTaskSpecification(nshots=shots, program=program)\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/#bloqade.compiler.passes.hardware.generate_quera_ir","title":"generate_quera_ir","text":"<pre><code>generate_quera_ir(ahs_components, shots)\n</code></pre> <ol> <li>generate quera ir</li> </ol> <p>This pass takes the AHS components and generates the QuEra IR.</p> <p>Parameters:</p> Name Type Description Default <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit.</p> required <code>shots</code> <code>int</code> <p>Number of shots to run the circuit for.</p> required <p>Returns:</p> Name Type Description <code>task_specification</code> <code>QuEraTaskSpecification</code> <p>QuEra IR for the given circuit.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def generate_quera_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; QuEraTaskSpecification:\n    \"\"\"7. generate quera ir\n\n    This pass takes the AHS components and generates the QuEra IR.\n\n    Args:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit.\n        shots (int): Number of shots to run the circuit for.\n\n    Returns:\n        task_specification (QuEraTaskSpecification): QuEra IR for the given\n            circuit.\n\n    \"\"\"\n    import bloqade.submission.ir.task_specification as task_spec\n    from bloqade.compiler.passes.hardware.units import (\n        convert_time_units,\n        convert_energy_units,\n        convert_coordinate_units,\n    )\n\n    lattice = task_spec.Lattice(\n        sites=list(\n            map(\n                convert_coordinate_units,\n                ahs_components.lattice_data.sites,\n            )\n        ),\n        filling=ahs_components.lattice_data.filling,\n    )\n\n    global_detuning = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_detuning.times)),\n        values=list(map(convert_energy_units, ahs_components.global_detuning.values)),\n    )\n\n    local_detuning = None\n\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning = task_spec.LocalField(\n            times=list(map(convert_time_units, ahs_components.local_detuning.times)),\n            values=list(\n                map(convert_energy_units, ahs_components.local_detuning.values)\n            ),\n            lattice_site_coefficients=ahs_components.lattice_site_coefficients,\n        )\n\n    rabi_frequency_amplitude_field = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_amplitude.times)),\n        values=list(map(convert_energy_units, ahs_components.global_amplitude.values)),\n    )\n\n    rabi_frequency_phase_field = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_phase.times)),\n        values=ahs_components.global_phase.values,\n    )\n\n    detuning = task_spec.Detuning(\n        global_=global_detuning,\n        local=local_detuning,\n    )\n\n    rabi_frequency_amplitude = task_spec.RabiFrequencyAmplitude(\n        global_=rabi_frequency_amplitude_field,\n    )\n\n    rabi_frequency_phase = task_spec.RabiFrequencyPhase(\n        global_=rabi_frequency_phase_field,\n    )\n\n    rydberg = task_spec.RydbergHamiltonian(\n        rabi_frequency_amplitude=rabi_frequency_amplitude,\n        rabi_frequency_phase=rabi_frequency_phase,\n        detuning=detuning,\n    )\n\n    effective_hamiltonian = task_spec.EffectiveHamiltonian(\n        rydberg=rydberg,\n    )\n\n    return task_spec.QuEraTaskSpecification(\n        nshots=shots,\n        lattice=lattice,\n        effective_hamiltonian=effective_hamiltonian,\n    )\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/#bloqade.compiler.passes.hardware.validate_waveforms","title":"validate_waveforms","text":"<pre><code>validate_waveforms(level_couplings, circuit)\n</code></pre> <ol> <li>validate piecewise linear and piecewise constant pieces of pulses</li> </ol> <p>This pass check to make sure that the waveforms are compatible with the hardware. This includes checking that the waveforms are piecewise linear or piecewise constant. It also checks that the waveforms are compatible with the given channels.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to validate waveforms for</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the waveforms are not piecewise linear or piecewise constant, e.g. the waveform is not continuous.</p> <code>ValueError</code> <p>If a waveform segment is not compatible with the given channels.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def validate_waveforms(\n    level_couplings: Dict, circuit: analog_circuit.AnalogCircuit\n) -&gt; None:\n    \"\"\"4. validate piecewise linear and piecewise constant pieces of pulses\n\n    This pass check to make sure that the waveforms are compatible with the\n    hardware. This includes checking that the waveforms are piecewise linear or\n    piecewise constant. It also checks that the waveforms are compatible with\n    the given channels.\n\n    Args:\n        circuit: AnalogCircuit to validate waveforms for\n        level_couplings: Dictionary containing the given channels for the\n            sequence.\n\n    Raises:\n        ValueError: If the waveforms are not piecewise linear or piecewise\n            constant, e.g. the waveform is not continuous.\n        ValueError: If a waveform segment is not compatible with the given\n            channels.\n\n    \"\"\"\n    from bloqade.compiler.analysis.hardware import (\n        ValidatePiecewiseConstantChannel,\n        ValidatePiecewiseLinearChannel,\n    )\n    from bloqade.compiler.analysis.common import CheckSlices\n\n    channel_iter = (\n        (level_coupling, field_name, sm)\n        for level_coupling, fields in level_couplings.items()\n        for field_name, spatial_modulations in fields.items()\n        for sm in spatial_modulations\n    )\n    for channel in channel_iter:\n        if channel[1] in [pulse.detuning, pulse.rabi.amplitude]:\n            ValidatePiecewiseLinearChannel(*channel).visit(circuit)\n        else:\n            ValidatePiecewiseConstantChannel(*channel).visit(circuit)\n\n    CheckSlices().visit(circuit)\n\n    if circuit.sequence.duration() == 0:\n        raise ValueError(\"Circuit Duration must be be non-zero\")\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/components/","title":"Components","text":""},{"location":"reference/bloqade/compiler/passes/hardware/define/","title":"Define","text":""},{"location":"reference/bloqade/compiler/passes/hardware/define/#bloqade.compiler.passes.hardware.define.analyze_channels","title":"analyze_channels","text":"<pre><code>analyze_channels(circuit)\n</code></pre> <ol> <li>Scan channels</li> </ol> <p>This pass checks to make sure that: * There is no hyperfine coupling in the sequence * There are no non-uniform spatial modulation for rabi phase and amplitude * there is no more than one non-uniform spatial modulation for detuning</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to analyze</p> required <p>Returns:</p> Name Type Description <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the required channels for the sequence. Note that this will insert a uniform field for any missing channels.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is hyperfine coupling in the sequence.</p> <code>ValueError</code> <p>If there is more than one non-uniform spatial modulation for detuning.</p> <code>ValueError</code> <p>If there are non-uniform spatial modulations for rabi phase and amplitude.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def analyze_channels(circuit: analog_circuit.AnalogCircuit) -&gt; Dict:\n    \"\"\"1. Scan channels\n\n    This pass checks to make sure that:\n    * There is no hyperfine coupling in the sequence\n    * There are no non-uniform spatial modulation for rabi phase and amplitude\n    * there is no more than one non-uniform spatial modulation for detuning\n\n    Args:\n        circuit: AnalogCircuit to analyze\n\n    Returns:\n        level_couplings: Dictionary containing the required channels for the\n            sequence. Note that this will insert a uniform field for any missing\n            channels.\n\n    Raises:\n        ValueError: If there is hyperfine coupling in the sequence.\n        ValueError: If there is more than one non-uniform spatial modulation for\n            detuning.\n        ValueError: If there are non-uniform spatial modulations for rabi phase\n            and amplitude.\n\n    \"\"\"\n    from bloqade.compiler.analysis.hardware import ValidateChannels\n    from bloqade.compiler.analysis.common import ScanChannels\n\n    ValidateChannels().scan(circuit)\n    level_couplings = ScanChannels().scan(circuit)\n\n    # add missing channels\n    fields = level_couplings[sequence.rydberg]\n    # detuning, phase and amplitude are required\n    # to have at least a uniform field\n    updated_fields = {\n        field_name: fields.get(field_name, {field.Uniform}).union({field.Uniform})\n        for field_name in [pulse.detuning, pulse.rabi.amplitude, pulse.rabi.phase]\n    }\n\n    return {sequence.rydberg: updated_fields}\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/define/#bloqade.compiler.passes.hardware.define.assign_circuit","title":"assign_circuit","text":"<pre><code>assign_circuit(circuit, assignments)\n</code></pre> <ol> <li>Assign variables and validate assignment</li> </ol> <p>This pass assigns variables to the circuit and validates that all variables have been assigned.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to assign variables to</p> required <code>assignments</code> <code>Dict[str, ParamType]</code> <p>Dictionary containing the assignments for the variables in the circuit.</p> required <p>Returns:</p> Name Type Description <code>assigned_circuit</code> <code>Tuple[AnalogCircuit, Dict]</code> <p>AnalogCircuit with variables assigned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are any variables that have not been assigned.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def assign_circuit(\n    circuit: analog_circuit.AnalogCircuit, assignments: Dict[str, ParamType]\n) -&gt; Tuple[analog_circuit.AnalogCircuit, Dict]:\n    \"\"\"3. Assign variables and validate assignment\n\n    This pass assigns variables to the circuit and validates that all variables\n    have been assigned.\n\n    Args:\n        circuit: AnalogCircuit to assign variables to\n        assignments: Dictionary containing the assignments for the variables in\n            the circuit.\n\n    Returns:\n        assigned_circuit: AnalogCircuit with variables assigned.\n\n    Raises:\n        ValueError: If there are any variables that have not been assigned.\n\n    \"\"\"\n    from bloqade.compiler.analysis.common import AssignmentScan, ScanVariables\n    from bloqade.compiler.rewrite.common import AssignBloqadeIR\n\n    final_assignments = AssignmentScan(assignments).scan(circuit)\n\n    assigned_circuit = AssignBloqadeIR(final_assignments).visit(circuit)\n\n    assignment_analysis = ScanVariables().scan(assigned_circuit)\n\n    if not assignment_analysis.is_assigned:\n        missing_vars = assignment_analysis.scalar_vars.union(\n            assignment_analysis.vector_vars\n        )\n        raise ValueError(\n            \"Missing assignments for variables:\\n\"\n            + (\"\\n\".join(f\"{var}\" for var in missing_vars))\n            + \"\\n\"\n        )\n\n    return assigned_circuit, final_assignments\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/define/#bloqade.compiler.passes.hardware.define.canonicalize_circuit","title":"canonicalize_circuit","text":"<pre><code>canonicalize_circuit(circuit, level_couplings)\n</code></pre> <ol> <li>Insert zero waveform in the explicit time intervals missing a waveform</li> </ol> <p>This pass inserts a zero waveform in the explicit time intervals missing a waveform. This is required for later analysis passes to check that the waveforms are compatible with the hardware.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to add padding to</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <p>Return     circuit: AnalogCircuit with zero waveforms inserted in the explicit time         intervals missing a waveform.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def canonicalize_circuit(\n    circuit: analog_circuit.AnalogCircuit, level_couplings: Dict\n) -&gt; analog_circuit.AnalogCircuit:\n    \"\"\"2. Insert zero waveform in the explicit time intervals missing a waveform\n\n    This pass inserts a zero waveform in the explicit time intervals missing a\n    waveform. This is required for later analysis passes to check that the\n    waveforms are compatible with the hardware.\n\n    Args:\n        circuit: AnalogCircuit to add padding to\n        level_couplings: Dictionary containing the given channels for the\n            sequence.\n\n    Return\n        circuit: AnalogCircuit with zero waveforms inserted in the explicit time\n            intervals missing a waveform.\n\n    \"\"\"\n    from bloqade.compiler.rewrite.common import (\n        AddPadding,\n        AssignToLiteral,\n        Canonicalizer,\n    )\n\n    circuit = AddPadding(level_couplings).visit(circuit)\n    # these two passes are equivalent to a constant propagation pass\n    circuit = AssignToLiteral().visit(circuit)\n    circuit = Canonicalizer().visit(circuit)\n\n    return circuit\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/define/#bloqade.compiler.passes.hardware.define.generate_ahs_code","title":"generate_ahs_code","text":"<pre><code>generate_ahs_code(capabilities, level_couplings, circuit)\n</code></pre> <ol> <li>generate ahs code</li> </ol> <p>Generates the AHS code for the given circuit. This includes generating the lattice data, global detuning, global amplitude, global phase, local detuning and lattice site coefficients (if applicable).</p> <p>Parameters:</p> Name Type Description Default <code>capabilities</code> <code>QuEraCapabilities | None</code> <p>Capabilities of the hardware.</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to generate AHS code for.</p> required <p>Returns:</p> Name Type Description <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit. Can be used to generate the QuEra and Braket IR.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the capabilities are not provided but the circuit has a ParallelRegister. This is because the ParallelRegister requires the capabilities to generate the lattice data.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def generate_ahs_code(\n    capabilities: Optional[QuEraCapabilities],\n    level_couplings: Dict,\n    circuit: analog_circuit.AnalogCircuit,\n) -&gt; AHSComponents:\n    \"\"\"5. generate ahs code\n\n    Generates the AHS code for the given circuit. This includes generating the\n    lattice data, global detuning, global amplitude, global phase, local\n    detuning and lattice site coefficients (if applicable).\n\n    Args:\n        capabilities (QuEraCapabilities | None): Capabilities of the hardware.\n        level_couplings (Dict): Dictionary containing the given channels for the\n            sequence.\n        circuit (AnalogCircuit): AnalogCircuit to generate AHS code for.\n\n    Returns:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit. Can be used to generate the QuEra\n            and Braket IR.\n\n    Raises:\n        ValueError: If the capabilities are not provided but the circuit has\n            a ParallelRegister. This is because the ParallelRegister requires\n            the capabilities to generate the lattice data.\n\n    \"\"\"\n    from bloqade.compiler.codegen.hardware import (\n        GenerateLattice,\n        GenerateLatticeSiteCoefficients,\n        GeneratePiecewiseLinearChannel,\n        GeneratePiecewiseConstantChannel,\n    )\n    from bloqade.compiler.analysis.hardware import BasicLatticeValidation\n\n    if capabilities is not None:\n        # only validate the lattice if capabilities are provided\n        BasicLatticeValidation(capabilities).visit(circuit)\n\n    ahs_lattice_data = GenerateLattice(capabilities).emit(circuit)\n\n    global_detuning = GeneratePiecewiseLinearChannel(\n        sequence.rydberg, pulse.detuning, field.Uniform\n    ).visit(circuit)\n\n    global_amplitude = GeneratePiecewiseLinearChannel(\n        sequence.rydberg, pulse.rabi.amplitude, field.Uniform\n    ).visit(circuit)\n\n    global_phase = GeneratePiecewiseConstantChannel(\n        sequence.rydberg, pulse.rabi.phase, field.Uniform\n    ).visit(circuit)\n\n    local_detuning = None\n    lattice_site_coefficients = None\n\n    extra_sm = set(level_couplings[sequence.rydberg][pulse.detuning]) - {field.Uniform}\n\n    if extra_sm:\n        if capabilities is not None and capabilities.capabilities.rydberg.local is None:\n            raise ValueError(\n                \"Device does not support local detuning, but the program has a \"\n                \"non-uniform spatial modulation for detuning.\"\n            )\n\n        sm = extra_sm.pop()\n\n        lattice_site_coefficients = GenerateLatticeSiteCoefficients(\n            parallel_decoder=ahs_lattice_data.parallel_decoder\n        ).emit(circuit)\n\n        local_detuning = GeneratePiecewiseLinearChannel(\n            sequence.rydberg, pulse.detuning, sm\n        ).visit(circuit)\n\n    return AHSComponents(\n        lattice_data=ahs_lattice_data,\n        global_detuning=global_detuning,\n        global_amplitude=global_amplitude,\n        global_phase=global_phase,\n        local_detuning=local_detuning,\n        lattice_site_coefficients=lattice_site_coefficients,\n    )\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/define/#bloqade.compiler.passes.hardware.define.generate_braket_ir","title":"generate_braket_ir","text":"<pre><code>generate_braket_ir(ahs_components, shots)\n</code></pre> <ol> <li>generate braket ir</li> </ol> <p>This pass takes the AHS components and generates the Braket IR.</p> <p>Parameters:</p> Name Type Description Default <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit.</p> required <code>shots</code> <code>int</code> <p>Number of shots to run the circuit for.</p> required <p>Returns:</p> Name Type Description <code>task_specification</code> <code>BraketTaskSpecification</code> <p>Braket IR for the given circuit.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def generate_braket_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; BraketTaskSpecification:\n    \"\"\"7. generate braket ir\n\n    This pass takes the AHS components and generates the Braket IR.\n\n    Args:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit.\n        shots (int): Number of shots to run the circuit for.\n\n    Returns:\n        task_specification (BraketTaskSpecification): Braket IR for the given\n            circuit.\n\n    \"\"\"\n    import braket.ir.ahs as ahs\n    from bloqade.compiler.passes.hardware.units import (\n        convert_time_units,\n        convert_energy_units,\n        convert_coordinate_units,\n    )\n\n    ahs_register = ahs.AtomArrangement(\n        sites=list(map(convert_coordinate_units, ahs_components.lattice_data.sites)),\n        filling=ahs_components.lattice_data.filling,\n    )\n\n    global_detuning_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_detuning.times)),\n        values=list(map(convert_energy_units, ahs_components.global_detuning.values)),\n    )\n\n    local_detuning_time_series = None\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning_time_series = ahs.TimeSeries(\n            times=list(map(convert_time_units, ahs_components.local_detuning.times)),\n            values=list(\n                map(convert_energy_units, ahs_components.local_detuning.values)\n            ),\n        )\n\n    amplitude_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_amplitude.times)),\n        values=list(map(convert_energy_units, ahs_components.global_amplitude.values)),\n    )\n\n    phase_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_phase.times)),\n        values=ahs_components.global_phase.values,\n    )\n\n    detuning = ahs.PhysicalField(\n        time_series=global_detuning_time_series,\n        pattern=\"uniform\",\n    )\n\n    amplitude = ahs.PhysicalField(\n        time_series=amplitude_time_series,\n        pattern=\"uniform\",\n    )\n\n    phase = ahs.PhysicalField(\n        time_series=phase_time_series,\n        pattern=\"uniform\",\n    )\n\n    local_detuning = None\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning = ahs.PhysicalField(\n            time_series=local_detuning_time_series,\n            pattern=ahs_components.lattice_site_coefficients,\n        )\n\n    driving_field = ahs.DrivingField(\n        detuning=detuning,\n        amplitude=amplitude,\n        phase=phase,\n    )\n\n    shiftingFields = []\n    if ahs_components.lattice_site_coefficients is not None:\n        shiftingFields = [ahs.ShiftingField(magnitude=local_detuning)]\n\n    program = ahs.Program(\n        setup=ahs.Setup(ahs_register=ahs_register),\n        hamiltonian=ahs.Hamiltonian(\n            drivingFields=[driving_field],\n            shiftingFields=shiftingFields,\n        ),\n    )\n\n    return BraketTaskSpecification(nshots=shots, program=program)\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/define/#bloqade.compiler.passes.hardware.define.generate_quera_ir","title":"generate_quera_ir","text":"<pre><code>generate_quera_ir(ahs_components, shots)\n</code></pre> <ol> <li>generate quera ir</li> </ol> <p>This pass takes the AHS components and generates the QuEra IR.</p> <p>Parameters:</p> Name Type Description Default <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit.</p> required <code>shots</code> <code>int</code> <p>Number of shots to run the circuit for.</p> required <p>Returns:</p> Name Type Description <code>task_specification</code> <code>QuEraTaskSpecification</code> <p>QuEra IR for the given circuit.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def generate_quera_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; QuEraTaskSpecification:\n    \"\"\"7. generate quera ir\n\n    This pass takes the AHS components and generates the QuEra IR.\n\n    Args:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit.\n        shots (int): Number of shots to run the circuit for.\n\n    Returns:\n        task_specification (QuEraTaskSpecification): QuEra IR for the given\n            circuit.\n\n    \"\"\"\n    import bloqade.submission.ir.task_specification as task_spec\n    from bloqade.compiler.passes.hardware.units import (\n        convert_time_units,\n        convert_energy_units,\n        convert_coordinate_units,\n    )\n\n    lattice = task_spec.Lattice(\n        sites=list(\n            map(\n                convert_coordinate_units,\n                ahs_components.lattice_data.sites,\n            )\n        ),\n        filling=ahs_components.lattice_data.filling,\n    )\n\n    global_detuning = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_detuning.times)),\n        values=list(map(convert_energy_units, ahs_components.global_detuning.values)),\n    )\n\n    local_detuning = None\n\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning = task_spec.LocalField(\n            times=list(map(convert_time_units, ahs_components.local_detuning.times)),\n            values=list(\n                map(convert_energy_units, ahs_components.local_detuning.values)\n            ),\n            lattice_site_coefficients=ahs_components.lattice_site_coefficients,\n        )\n\n    rabi_frequency_amplitude_field = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_amplitude.times)),\n        values=list(map(convert_energy_units, ahs_components.global_amplitude.values)),\n    )\n\n    rabi_frequency_phase_field = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_phase.times)),\n        values=ahs_components.global_phase.values,\n    )\n\n    detuning = task_spec.Detuning(\n        global_=global_detuning,\n        local=local_detuning,\n    )\n\n    rabi_frequency_amplitude = task_spec.RabiFrequencyAmplitude(\n        global_=rabi_frequency_amplitude_field,\n    )\n\n    rabi_frequency_phase = task_spec.RabiFrequencyPhase(\n        global_=rabi_frequency_phase_field,\n    )\n\n    rydberg = task_spec.RydbergHamiltonian(\n        rabi_frequency_amplitude=rabi_frequency_amplitude,\n        rabi_frequency_phase=rabi_frequency_phase,\n        detuning=detuning,\n    )\n\n    effective_hamiltonian = task_spec.EffectiveHamiltonian(\n        rydberg=rydberg,\n    )\n\n    return task_spec.QuEraTaskSpecification(\n        nshots=shots,\n        lattice=lattice,\n        effective_hamiltonian=effective_hamiltonian,\n    )\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/define/#bloqade.compiler.passes.hardware.define.validate_waveforms","title":"validate_waveforms","text":"<pre><code>validate_waveforms(level_couplings, circuit)\n</code></pre> <ol> <li>validate piecewise linear and piecewise constant pieces of pulses</li> </ol> <p>This pass check to make sure that the waveforms are compatible with the hardware. This includes checking that the waveforms are piecewise linear or piecewise constant. It also checks that the waveforms are compatible with the given channels.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to validate waveforms for</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the waveforms are not piecewise linear or piecewise constant, e.g. the waveform is not continuous.</p> <code>ValueError</code> <p>If a waveform segment is not compatible with the given channels.</p> Source code in <code>src/bloqade/compiler/passes/hardware/define.py</code> <pre><code>def validate_waveforms(\n    level_couplings: Dict, circuit: analog_circuit.AnalogCircuit\n) -&gt; None:\n    \"\"\"4. validate piecewise linear and piecewise constant pieces of pulses\n\n    This pass check to make sure that the waveforms are compatible with the\n    hardware. This includes checking that the waveforms are piecewise linear or\n    piecewise constant. It also checks that the waveforms are compatible with\n    the given channels.\n\n    Args:\n        circuit: AnalogCircuit to validate waveforms for\n        level_couplings: Dictionary containing the given channels for the\n            sequence.\n\n    Raises:\n        ValueError: If the waveforms are not piecewise linear or piecewise\n            constant, e.g. the waveform is not continuous.\n        ValueError: If a waveform segment is not compatible with the given\n            channels.\n\n    \"\"\"\n    from bloqade.compiler.analysis.hardware import (\n        ValidatePiecewiseConstantChannel,\n        ValidatePiecewiseLinearChannel,\n    )\n    from bloqade.compiler.analysis.common import CheckSlices\n\n    channel_iter = (\n        (level_coupling, field_name, sm)\n        for level_coupling, fields in level_couplings.items()\n        for field_name, spatial_modulations in fields.items()\n        for sm in spatial_modulations\n    )\n    for channel in channel_iter:\n        if channel[1] in [pulse.detuning, pulse.rabi.amplitude]:\n            ValidatePiecewiseLinearChannel(*channel).visit(circuit)\n        else:\n            ValidatePiecewiseConstantChannel(*channel).visit(circuit)\n\n    CheckSlices().visit(circuit)\n\n    if circuit.sequence.duration() == 0:\n        raise ValueError(\"Circuit Duration must be be non-zero\")\n</code></pre>"},{"location":"reference/bloqade/compiler/passes/hardware/units/","title":"Units","text":""},{"location":"reference/bloqade/compiler/rewrite/","title":"Index","text":""},{"location":"reference/bloqade/compiler/rewrite/common/","title":"Index","text":""},{"location":"reference/bloqade/compiler/rewrite/common/#bloqade.compiler.rewrite.common.AssignToLiteral","title":"AssignToLiteral","text":"<p>             Bases: <code>BloqadeIRTransformer</code></p> <p>Transform all assigned variables to literals.</p>"},{"location":"reference/bloqade/compiler/rewrite/common/add_padding/","title":"Add padding","text":""},{"location":"reference/bloqade/compiler/rewrite/common/assign_to_literal/","title":"Assign to literal","text":""},{"location":"reference/bloqade/compiler/rewrite/common/assign_to_literal/#bloqade.compiler.rewrite.common.assign_to_literal.AssignToLiteral","title":"AssignToLiteral","text":"<p>             Bases: <code>BloqadeIRTransformer</code></p> <p>Transform all assigned variables to literals.</p>"},{"location":"reference/bloqade/compiler/rewrite/common/assign_variables/","title":"Assign variables","text":""},{"location":"reference/bloqade/compiler/rewrite/common/canonicalize/","title":"Canonicalize","text":""},{"location":"reference/bloqade/compiler/rewrite/common/flatten/","title":"Flatten","text":""},{"location":"reference/bloqade/compiler/rewrite/python/","title":"Index","text":""},{"location":"reference/bloqade/compiler/rewrite/python/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade/emulate/","title":"Index","text":""},{"location":"reference/bloqade/emulate/sparse_operator/","title":"Sparse operator","text":""},{"location":"reference/bloqade/emulate/ir/","title":"Index","text":""},{"location":"reference/bloqade/emulate/ir/atom_type/","title":"Atom type","text":""},{"location":"reference/bloqade/emulate/ir/emulator/","title":"Emulator","text":""},{"location":"reference/bloqade/emulate/ir/emulator/#bloqade.emulate.ir.emulator.Register","title":"Register  <code>dataclass</code>","text":"<p>This class represents the of the atoms in the system.</p>"},{"location":"reference/bloqade/emulate/ir/space/","title":"Space","text":""},{"location":"reference/bloqade/emulate/ir/state_vector/","title":"State vector","text":""},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.AnalogGate","title":"AnalogGate  <code>dataclass</code>","text":""},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.AnalogGate.run","title":"run","text":"<pre><code>run(\n    shots=1,\n    solver_name=\"dop853\",\n    atol=1e-14,\n    rtol=1e-07,\n    nsteps=2147483647,\n    interaction_picture=False,\n    project_hyperfine=True,\n)\n</code></pre> <p>Run the emulation with all atoms in the ground state, sampling the final state vector.</p> Source code in <code>src/bloqade/emulate/ir/state_vector.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int = 1,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-14,\n    rtol: float = 1e-7,\n    nsteps: int = 2_147_483_647,\n    interaction_picture: bool = False,\n    project_hyperfine: bool = True,\n) -&gt; NDArray[np.uint8]:\n    \"\"\"Run the emulation with all atoms in the ground state,\n    sampling the final state vector.\"\"\"\n\n    options = dict(\n        solver_name=solver_name,\n        atol=atol,\n        rtol=rtol,\n        nsteps=nsteps,\n        interaction_picture=interaction_picture,\n    )\n\n    state = self.hamiltonian.space.zero_state()\n    (result,) = self.apply(state, **options)\n    result.normalize()\n\n    return result.sample(shots, project_hyperfine=project_hyperfine)\n</code></pre>"},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.RydbergHamiltonian","title":"RydbergHamiltonian  <code>dataclass</code>","text":""},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.RydbergHamiltonian.average","title":"average","text":"<pre><code>average(register, time=None)\n</code></pre> <p>Get energy average from RydbergHamiltonian object at time <code>time</code> with register <code>register</code></p> <p>Parameters:</p> Name Type Description Default <code>register</code> <code>StateVector</code> <p>The state vector to take average with</p> required <code>time</code> <code>Optional[float]</code> <p>Time value to evaluate average at.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>average energy at time <code>time</code></p> Source code in <code>src/bloqade/emulate/ir/state_vector.py</code> <pre><code>@beartype\ndef average(\n    self,\n    register: StateVector,\n    time: Optional[float] = None,\n) -&gt; float:\n    \"\"\"Get energy average from RydbergHamiltonian object at time `time` with\n    register `register`\n\n    Args:\n        register (StateVector): The state vector to take average with\n        time (Optional[float], optional): Time value to evaluate average at.\n        Defaults to duration of RydbergHamiltonian.\n\n    Returns:\n        float: average energy at time `time`\n    \"\"\"\n    return np.vdot(register.data, self._apply(register.data, time)).real\n</code></pre>"},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.RydbergHamiltonian.average_and_variance","title":"average_and_variance","text":"<pre><code>average_and_variance(register, time=None)\n</code></pre> <p>Get energy average and variance from RydbergHamiltonian object at time <code>time</code> with register <code>register</code></p> <p>Parameters:</p> Name Type Description Default <code>register</code> <code>StateVector</code> <p>The state vector to take average and variance with</p> required <code>time</code> <code>Optional[float]</code> <p>Time value to evaluate average at.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Tuple[float, float]: average and variance of energy at time <code>time</code></p> <code>float</code> <p>respectively.</p> Source code in <code>src/bloqade/emulate/ir/state_vector.py</code> <pre><code>@beartype\ndef average_and_variance(\n    self,\n    register: StateVector,\n    time: Optional[float] = None,\n) -&gt; Tuple[float, float]:\n    \"\"\"Get energy average and variance from RydbergHamiltonian object at time `time`\n    with register `register`\n\n    Args:\n        register (StateVector): The state vector to take average and variance with\n        time (Optional[float], optional): Time value to evaluate average at.\n        Defaults to duration of RydbergHamiltonian.\n\n    Returns:\n        Tuple[float, float]: average and variance of energy at time `time`\n        respectively.\n    \"\"\"\n    H_register_data = self._apply(register.data, time)\n\n    average = np.vdot(register.data, H_register_data).real\n    square_average = np.vdot(H_register_data, H_register_data).real\n\n    return average, square_average - average**2\n</code></pre>"},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.RydbergHamiltonian.tocsr","title":"tocsr","text":"<pre><code>tocsr(time)\n</code></pre> <p>Return the Hamiltonian as a csr matrix at time <code>time</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>time to evaluate the Hamiltonian at.</p> required <p>Returns:</p> Name Type Description <code>csr_matrix</code> <code>csr_matrix</code> <p>The Hamiltonian as a csr matrix.</p> Source code in <code>src/bloqade/emulate/ir/state_vector.py</code> <pre><code>def tocsr(self, time: float) -&gt; csr_matrix:\n    \"\"\"Return the Hamiltonian as a csr matrix at time `time`.\n\n    Args:\n        time (float): time to evaluate the Hamiltonian at.\n\n    Returns:\n        csr_matrix: The Hamiltonian as a csr matrix.\n\n    \"\"\"\n    diagonal = sum(\n        (detuning.get_diagonal(time) for detuning in self.detuning_ops),\n        start=self.rydberg,\n    )\n\n    hamiltonian = diags(diagonal).tocsr()\n    for rabi_op in self.rabi_ops:\n        hamiltonian = hamiltonian + rabi_op.tocsr(time)\n\n    return hamiltonian\n</code></pre>"},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.RydbergHamiltonian.variance","title":"variance","text":"<pre><code>variance(register, time=None)\n</code></pre> <p>Get the energy variance from RydbergHamiltonian object at time <code>time</code> with register <code>register</code></p> <p>Parameters:</p> Name Type Description Default <code>register</code> <code>StateVector</code> <p>The state vector to take variance with</p> required <code>time</code> <code>Optional[float]</code> <p>Time value to evaluate average at.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>complex</code> <code>float</code> <p>variance of energy at time <code>time</code> respectively.</p> Source code in <code>src/bloqade/emulate/ir/state_vector.py</code> <pre><code>@beartype\ndef variance(\n    self,\n    register: StateVector,\n    time: Optional[float] = None,\n) -&gt; float:\n    \"\"\"Get the energy variance from RydbergHamiltonian object at\n    time `time` with register `register`\n\n    Args:\n        register (StateVector): The state vector to take variance with\n        time (Optional[float], optional): Time value to evaluate average at.\n        Defaults to duration of RydbergHamiltonian.\n\n    Returns:\n        complex: variance of energy at time `time` respectively.\n    \"\"\"\n\n    _, var = self.average_and_variance(register, time)\n    return var\n</code></pre>"},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.StateVector","title":"StateVector  <code>dataclass</code>","text":""},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.StateVector.local_trace","title":"local_trace","text":"<pre><code>local_trace(matrix, site_index)\n</code></pre> <p>return trace of an operator over the StateVector.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>Square matrix representing operator in the local hilbert space.</p> required <code>site_index</code> <code>int | Tuple[int, int]</code> <p>sites to apply one body operator to.</p> required <p>Returns:</p> Name Type Description <code>complex</code> <code>complex</code> <p>the trace of the operator over the state-vector.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Error is raised when the dimension of <code>operator</code> is not</p> <code>ValueError</code> <p>Error is raised when the <code>site</code> argument is out of bounds.</p> Source code in <code>src/bloqade/emulate/ir/state_vector.py</code> <pre><code>@plum.dispatch\ndef local_trace(  # noqa: F811\n    self, matrix: np.ndarray, site_index: Union[int, Tuple[int, int]]\n) -&gt; complex:  # noqa: F811\n    \"\"\"return trace of an operator over the StateVector.\n\n    Args:\n        matrix (np.ndarray): Square matrix representing operator in the local\n            hilbert space.\n        site_index (int | Tuple[int, int]): sites to apply one body operator to.\n\n    Returns:\n        complex: the trace of the operator over the state-vector.\n\n    Raises:\n        ValueError: Error is raised when the dimension of `operator` is not\n        consistent with `site` argument. The size of the operator must fit\n        the size of the local hilbert space of `site` depending on the number\n        of sites and the number of levels inside each atom, e.g. for two site\n        expectation value with a three level atom the operator must be a 9 by\n        9 array.\n\n        ValueError: Error is raised when the `site` argument is out of bounds.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.StateVector.norm","title":"norm","text":"<pre><code>norm()\n</code></pre> <p>Return the norm of the state vector.</p> Source code in <code>src/bloqade/emulate/ir/state_vector.py</code> <pre><code>def norm(self) -&gt; float:\n    \"\"\"Return the norm of the state vector.\"\"\"\n    return np.linalg.norm(self.data)\n</code></pre>"},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.StateVector.normalize","title":"normalize","text":"<pre><code>normalize()\n</code></pre> <p>Normalize the state vector.</p> Source code in <code>src/bloqade/emulate/ir/state_vector.py</code> <pre><code>def normalize(self) -&gt; None:\n    \"\"\"Normalize the state vector.\"\"\"\n    data = self.data\n    data /= np.linalg.norm(data)\n</code></pre>"},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.StateVector.sample","title":"sample","text":"<pre><code>sample(shots, project_hyperfine=True)\n</code></pre> <p>Sample the state vector and return bitstrings.</p> Source code in <code>src/bloqade/emulate/ir/state_vector.py</code> <pre><code>def sample(self, shots: int, project_hyperfine: bool = True) -&gt; NDArray:\n    \"\"\"Sample the state vector and return bitstrings.\"\"\"\n    return self.space.sample_state_vector(\n        self.data, shots, project_hyperfine=project_hyperfine\n    )\n</code></pre>"},{"location":"reference/bloqade/ir/","title":"Index","text":""},{"location":"reference/bloqade/ir/#bloqade.ir.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <p>A Program starting point, alias of empty <code>ListOfLocations</code>.</p> <ul> <li>Next possible steps to build your program are:</li> <li>Specify which level coupling to address with:<ul> <li><code>start.rydberg</code>: for <code>Rydberg</code>     Level coupling</li> <li><code>start.hyperfine</code>: for <code>Hyperfine</code>     Level coupling</li> <li>LOCKOUT: You cannot add atoms to your geometry after specifying level coupling.</li> </ul> </li> <li>continue/start building your geometry with:<ul> <li><code>start.add_position()</code>: to add atom(s) to current register. It will accept:<ul> <li>A single coordinate, represented as a tuple (e.g. <code>(5,6)</code>) with a value that   can either be:<ul> <li>integers: <code>(5,6)</code></li> <li>floats: <code>(5.1, 2.5)</code></li> <li>strings (for later variable assignment): <code>(\"x\", \"y\")</code></li> <li><code>Scalar</code> objects: <code>(2*cast(\"x\"), 5+cast(\"y\"))</code></li> </ul> </li> <li>A list of coordinates, represented as a list of types mentioned previously.</li> <li>A numpy array with shape (n, 2) where n is the total number of atoms</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bloqade/ir/#bloqade.ir.AlignedWaveform","title":"AlignedWaveform","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;padded waveform&gt; ::= &lt;waveform&gt; | &lt;waveform&gt; &lt;alignment&gt; &lt;value&gt;\n\n&lt;alignment&gt; ::= 'left aligned' | 'right aligned'\n&lt;value&gt; ::= 'left value' | 'right value' | &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AnalogCircuit","title":"AnalogCircuit","text":"<p>AnalogCircuit is a dummy type that bundle register and sequence together.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AnalogCircuit.register","title":"register  <code>property</code>","text":"<pre><code>register\n</code></pre> <p>Get the register of the program.</p> <p>Returns:</p> Type Description <p>register (Union[\"AtomArrangement\", \"ParallelRegister\"])</p> Note <p>If the program is built with <code>parallelize()</code>, The the register will be a <code>ParallelRegister</code>. Otherwise it will be a <code>AtomArrangement</code>.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AnalogCircuit.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the program</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the program</p> <code>{}</code> Source code in <code>src/bloqade/ir/analog_circuit.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"Interactive visualization of the program\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the program\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement","title":"AtomArrangement","text":"<pre><code>AtomArrangement(parent=None)\n</code></pre> <p>             Bases: <code>ProgramStart</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.add_position","title":"add_position","text":"<pre><code>add_position(position, filling=None)\n</code></pre> <p>Add a position or multiple positions to a pre-existing geometry.</p> <p><code>add_position</code> is capable of accepting: - A single tuple for one atom coordinate: <code>(1.0, 2.5)</code> - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.] - A numpy array of shape (N, 2) where N is the number of atoms</p> <p>You may also intersperse variables anywhere a value may be present.</p> <p>You can also pass in an optional argument which determines the atom \"filling\" (whether or not at a specified coordinate an atom should be present).</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.add_position--usage-example","title":"Usage Example:","text":"<pre><code># single coordinate\n&gt;&gt;&gt; reg = start.add_position((0,0))\n# you may chain add_position calls\n&gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n# you can add variables anywhere a value may be present\n&gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n# and specify your atom fillings\n&gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n[True, False])\n# alternatively you could use one boolean to specify\n# all coordinates should be empty/filled\n&gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n(5.2, 2.2)], False)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def add_position(\n    self,\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[Union[BoolArray, List[bool], bool]] = None,\n) -&gt; \"ListOfLocations\":\n    \"\"\"\n    Add a position or multiple positions to a pre-existing geometry.\n\n    `add_position` is capable of accepting:\n    - A single tuple for one atom coordinate: `(1.0, 2.5)`\n    - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.]\n    - A numpy array of shape (N, 2) where N is the number of atoms\n\n    You may also intersperse variables anywhere a value may be present.\n\n    You can also pass in an optional argument which determines the atom \"filling\"\n    (whether or not at a specified coordinate an atom should be present).\n\n    ### Usage Example:\n    ```\n    # single coordinate\n    &gt;&gt;&gt; reg = start.add_position((0,0))\n    # you may chain add_position calls\n    &gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n    # you can add variables anywhere a value may be present\n    &gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n    # and specify your atom fillings\n    &gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n    [True, False])\n    # alternatively you could use one boolean to specify\n    # all coordinates should be empty/filled\n    &gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n    (5.2, 2.2)], False)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`: to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`: to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    if is_bearable(position, PositionArray) and is_bearable(\n        filling, Optional[BoolArray]\n    ):\n        return self.add_position_ndarray(position, filling)\n    elif is_bearable(position, List[Tuple[ScalarType, ScalarType]]) and is_bearable(\n        filling, Optional[List[bool]]\n    ):\n        return self.add_position_list_tuples(position, filling)\n    elif is_bearable(position, Tuple[ScalarType, ScalarType]) and is_bearable(\n        filling, Optional[bool]\n    ):\n        return self.add_position_single_tupe(position, filling)\n    else:\n        raise TypeError(\"Invalid input types for add_position provided!\")\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.apply_defect_count","title":"apply_defect_count","text":"<pre><code>apply_defect_count(n_defects, rng=np.random.default_rng())\n</code></pre> <p>Drop <code>n_defects</code> atoms from the geometry randomly. Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.apply_defect_count--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n# you may also chain apply_defect_count calls\n&gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n# you can also use apply_defect_count on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>:     to add more positions</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_density(defect_probability)</code>:     to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>:     to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify     Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>:     to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>:     shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_count(\n    self, n_defects: int, rng: np.random.Generator = np.random.default_rng()\n):\n    \"\"\"\n    Drop `n_defects` atoms from the geometry randomly. Internally this occurs\n    by setting certain sites to have a SiteFilling set to false indicating\n    no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n    # you may also chain apply_defect_count calls\n    &gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n    # you can also use apply_defect_count on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n            to add more positions\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_count(n_defects)`: to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_density(defect_probability)`:\n            to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n            to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`: to specify\n            Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n            to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n            shows your geometry in your web browser\n    \"\"\"\n\n    location_list = []\n    for location_info in self.enumerate():\n        location_list.append(location_info)\n\n    filled_sites = []\n\n    for index, location_info in enumerate(location_list):\n        if location_info.filling is SiteFilling.filled:\n            filled_sites.append(index)\n\n    if n_defects &gt;= len(filled_sites):\n        raise ValueError(\n            f\"n_defects {n_defects} must be less than the number of filled sites \"\n            f\"({len(filled_sites)})\"\n        )\n\n    for _ in range(n_defects):\n        index = rng.choice(filled_sites)\n        location_list[index] = LocationInfo.create(\n            location_list[index].position,\n            (False if location_list[index].filling is SiteFilling.filled else True),\n        )\n        filled_sites.remove(index)\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.apply_defect_density","title":"apply_defect_density","text":"<pre><code>apply_defect_density(\n    defect_probability, rng=np.random.default_rng()\n)\n</code></pre> <p>Drop atoms randomly with <code>defect_probability</code> probability (range of 0 to 1). Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.apply_defect_density--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n# you may also chain apply_defect_density calls\n&gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n# you can also use apply_defect_density on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n.apply_defect_density(0.5, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>: to add more positions</li> <li><code>...apply_defect_count(defect_counts).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts) .apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_density(\n    self,\n    defect_probability: float,\n    rng: np.random.Generator = np.random.default_rng(),\n):\n    \"\"\"\n    Drop atoms randomly with `defect_probability` probability (range of 0 to 1).\n    Internally this occurs by setting certain sites to have a SiteFilling\n    set to false indicating no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n    # you may also chain apply_defect_density calls\n    &gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n    # you can also use apply_defect_density on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n    .apply_defect_density(0.5, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n        to add more positions\n        - `...apply_defect_count(defect_counts).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n        .apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n        to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`:\n        to specify Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n        shows your geometry in your web browser\n    \"\"\"\n\n    p = min(1, max(0, defect_probability))\n    location_list = []\n\n    for location_info in self.enumerate():\n        if rng.random() &lt; p:\n            location_list.append(\n                LocationInfo.create(\n                    location_info.position,\n                    (\n                        False\n                        if location_info.filling is SiteFilling.filled\n                        else True\n                    ),\n                )\n            )\n        else:\n            location_list.append(location_info)\n\n    return ListOfLocations(location_list=location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs=fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments)\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.scale","title":"scale","text":"<pre><code>scale(scale)\n</code></pre> <p>Scale the geometry of your atoms.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n# atom positions are now (0,0), (2,2)\n&gt;&gt;&gt; new_reg = reg.scale(2)\n# you may also use scale on pre-defined geometries\n&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n# atoms in the chain will now be 2 um apart versus\n# the default 1 um\n&gt;&gt;&gt; Chain(11).scale(2)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef scale(self, scale: ScalarType):\n    \"\"\"\n    Scale the geometry of your atoms.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n    # atom positions are now (0,0), (2,2)\n    &gt;&gt;&gt; new_reg = reg.scale(2)\n    # you may also use scale on pre-defined geometries\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    # atoms in the chain will now be 2 um apart versus\n    # the default 1 um\n    &gt;&gt;&gt; Chain(11).scale(2)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`:\n        to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    scale = cast(scale)\n    location_list = []\n    for location_info in self.enumerate():\n        x, y = location_info.position\n        new_position = (scale * x, scale * y)\n        location_list.append(\n            LocationInfo.create(new_position, bool(location_info.filling.value))\n        )\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(parent=None)\n</code></pre> <p>             Bases: <code>AtomArrangement</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices <code>AtomArrangement</code>.</p> <ul> <li><code>Square</code></li> <li><code>Chain</code></li> <li><code>Honeycomb</code></li> <li><code>Triangular</code></li> <li><code>Lieb</code></li> <li><code>Kagome</code></li> <li><code>Rectangular</code></li> </ul>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index)\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n    \"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n    # damn! this is like stone age broadcasting\n    vectors = np.array(self.cell_vectors())\n    index = np.array(index)\n    pos = np.sum(vectors.T * index, axis=1)\n    return pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor)\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n    \"\"\"Scale the current location with a factor.\n\n    (x,y) -&gt; factor*(x,y)\n\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\n    factor = cast(factor)\n    obj = self.__new__(type(self))\n    for f in fields(self):\n        if f.name == \"lattice_spacing\":\n            obj.lattice_spacing = factor * self.lattice_spacing\n        else:\n            setattr(obj, f.name, getattr(self, f.name))\n    return obj\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Chain","title":"Chain","text":"<pre><code>Chain(L, *, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, *, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.L = L\n    self.lattice_spacing = cast(lattice_spacing)\n    self.vertical_chain = vertical_chain\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Constant","title":"Constant","text":"<pre><code>Constant(value, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;constant&gt; ::= 'constant' &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Scalar</code> <p>the constant value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the constant waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, value: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"value\", cast(value))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Field","title":"Field","text":"<p>             Bases: <code>FieldExpr</code></p> <p>Field node in the IR. Which contains collection(s) of <code>Waveform</code></p> <pre><code>&lt;field&gt; ::= ('field' &lt;spatial modulation&gt;  &lt;padded waveform&gt;)*\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Field.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Field</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Field</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/field.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Field\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Field\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Kagome","title":"Kagome","text":"<pre><code>Kagome(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Lieb","title":"Lieb","text":"<pre><code>Lieb(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Linear","title":"Linear","text":"<pre><code>Linear(start, stop, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;linear&gt; ::= 'linear' &lt;scalar expr&gt; &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = start + (stop-start)/duration * t</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Scalar</code> <p>start value</p> required <code>stop</code> <code>Scalar</code> <p>stop value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the linear waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, start: ScalarType, stop: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"start\", cast(start))\n    object.__setattr__(self, \"stop\", cast(stop))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Literal","title":"Literal","text":"<p>             Bases: <code>Real</code></p>"},{"location":"reference/bloqade/ir/#bloqade.ir.Literal.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre> <p>Scalar Literal, which stores a decimaal value instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>decimal value instance</p> required"},{"location":"reference/bloqade/ir/#bloqade.ir.Poly","title":"Poly","text":"<pre><code>Poly(coeffs, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;poly&gt; ::= &lt;scalar&gt;+\n</code></pre> <p>f(t=0:duration) = c[0] + c[1]t + c[2]t^2 + ... + c[n-1]t^n-1 + c[n]t^n</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>Tuple[Scalar]</code> <p>the coefficients c[] of the polynomial.</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, coeffs: Container[ScalarType], duration: ScalarType):\n    object.__setattr__(self, \"coeffs\", tuple(map(cast, coeffs)))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Pulse","title":"Pulse","text":"<p>             Bases: <code>PulseExpr</code></p> <pre><code>&lt;pulse&gt; ::= (&lt;field name&gt; &lt;field&gt;)+\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Pulse.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Pulse</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Pulse</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/pulse.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Pulse\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Pulse\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.PythonFn","title":"PythonFn","text":"<p>             Bases: <code>Instruction</code></p> <pre><code>&lt;python-fn&gt; ::= 'python-fn' &lt;python function def&gt; &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Record","title":"Record","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;record&gt; ::= 'record' &lt;waveform&gt; &lt;var&gt; &lt;side&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width,\n    height,\n    *,\n    lattice_spacing_x=1.0,\n    lattice_spacing_y=1.0\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0,\n):\n    self.width = width\n    self.height = height\n    self.lattice_spacing_x = cast(lattice_spacing_x)\n    self.lattice_spacing_y = (\n        cast(lattice_spacing_y)\n        if lattice_spacing_y is not None\n        else self.lattice_spacing_x\n    )\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Sample","title":"Sample","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;sample&gt; ::= 'sample' &lt;waveform&gt; &lt;interpolation&gt; &lt;scalar&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Scalar","title":"Scalar","text":"<p>Base class for all scalar expressions.</p> <pre><code>&lt;scalar&gt; ::= &lt;literal&gt;\n| &lt;variable&gt;\n| &lt;default&gt;\n| &lt;negative&gt;\n| &lt;add&gt;\n| &lt;mul&gt;\n| &lt;min&gt;\n| &lt;max&gt;\n| &lt;slice&gt;\n| &lt;inverval&gt;\n\n&lt;mul&gt; ::= &lt;scalar&gt; '*' &lt;scalar&gt;\n&lt;add&gt; ::= &lt;scalar&gt; '+' &lt;scalar&gt;\n&lt;min&gt; ::= 'min' &lt;scalar&gt;+\n&lt;max&gt; ::= 'max' &lt;scalar&gt;+\n&lt;slice&gt; ::= &lt;scalar expr&gt; '[' &lt;interval&gt; ']'\n&lt;interval&gt; ::= &lt;scalar expr&gt; '..' &lt;scalar expr&gt;\n&lt;real&gt; ::= &lt;literal&gt; | &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Sequence","title":"Sequence","text":"<p>             Bases: <code>SequenceExpr</code></p> <p>Sequence of a program, which includes pulses informations.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.Sequence.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Sequence</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Sequence</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/sequence.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Sequence\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Sequence\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Square","title":"Square","text":"<pre><code>Square(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Triangular","title":"Triangular","text":"<pre><code>Triangular(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Variable","title":"Variable","text":"<p>             Bases: <code>Real</code></p> <p>Variable, which stores a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>variable instance.</p> required"},{"location":"reference/bloqade/ir/#bloqade.ir.Waveform","title":"Waveform","text":"<p>             Bases: <code>HashTrait</code>, <code>CanonicalizeTrait</code></p> <p>Waveform node in the IR.</p> <ul> <li><code>&lt;instruction&gt;</code></li> <li><code>&lt;smooth&gt;</code></li> <li><code>&lt;slice&gt;</code></li> <li><code>&lt;apppend&gt;</code></li> <li><code>&lt;negative&gt;</code></li> <li><code>&lt;scale&gt;</code></li> <li><code>&lt;add&gt;</code></li> <li><code>&lt;record&gt;</code></li> <li><code>&lt;sample&gt;</code></li> </ul> <pre><code>&lt;waveform&gt; ::= &lt;instruction&gt;\n    | &lt;smooth&gt;\n    | &lt;slice&gt;\n    | &lt;append&gt;\n    | &lt;negative&gt;\n    | &lt;scale&gt;\n    | &lt;add&gt;\n    | &lt;record&gt;\n    | &lt;sample&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Waveform.figure","title":"figure","text":"<pre><code>figure(**assignments)\n</code></pre> <p>get figure of the plotting the waveform.</p> <p>Returns:</p> Name Type Description <code>figure</code> <p>a bokeh figure</p> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def figure(self, **assignments):\n    \"\"\"get figure of the plotting the waveform.\n\n    Returns:\n        figure: a bokeh figure\n    \"\"\"\n    return get_ir_figure(self, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.cast","title":"cast","text":"<pre><code>cast(py)\n</code></pre> <ol> <li> <p>cast Real number (or list/tuple of Real numbers) to <code>Scalar Literal</code>.</p> </li> <li> <p>cast str (or list/tuple of Real numbers) to <code>Scalar Variable</code>.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, Real, Tuple[Real], List[Real]]</code> <p>python object to cast</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>Scalar</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def cast(py) -&gt; \"Scalar\":\n    \"\"\"\n    1. cast Real number (or list/tuple of Real numbers)\n    to [`Scalar Literal`][bloqade.ir.scalar.Literal].\n\n    2. cast str (or list/tuple of Real numbers)\n    to [`Scalar Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str,Real,Tuple[Real],List[Real]]): python object to cast\n\n    Returns:\n        Scalar\n    \"\"\"\n    ret = trycast(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Scalar Literal\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.var","title":"var","text":"<pre><code>var(py)\n</code></pre> <p>cast string (or list/tuple of strings) to <code>Variable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, List[str]]</code> <p>a string or list/tuple of strings</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>Union[Variable]</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def var(py: str) -&gt; \"Variable\":\n    \"\"\"cast string (or list/tuple of strings)\n    to [`Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str, List[str]]): a string or list/tuple of strings\n\n    Returns:\n       Union[Variable]\n    \"\"\"\n    ret = tryvar(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Variable\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade/ir/analog_circuit/","title":"Analog circuit","text":""},{"location":"reference/bloqade/ir/analog_circuit/#bloqade.ir.analog_circuit.AnalogCircuit","title":"AnalogCircuit","text":"<p>AnalogCircuit is a dummy type that bundle register and sequence together.</p>"},{"location":"reference/bloqade/ir/analog_circuit/#bloqade.ir.analog_circuit.AnalogCircuit.register","title":"register  <code>property</code>","text":"<pre><code>register\n</code></pre> <p>Get the register of the program.</p> <p>Returns:</p> Type Description <p>register (Union[\"AtomArrangement\", \"ParallelRegister\"])</p> Note <p>If the program is built with <code>parallelize()</code>, The the register will be a <code>ParallelRegister</code>. Otherwise it will be a <code>AtomArrangement</code>.</p>"},{"location":"reference/bloqade/ir/analog_circuit/#bloqade.ir.analog_circuit.AnalogCircuit.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the program</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the program</p> <code>{}</code> Source code in <code>src/bloqade/ir/analog_circuit.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"Interactive visualization of the program\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the program\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/scalar/","title":"Scalar","text":""},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Literal","title":"Literal","text":"<p>             Bases: <code>Real</code></p>"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Literal.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre> <p>Scalar Literal, which stores a decimaal value instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>decimal value instance</p> required"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Scalar","title":"Scalar","text":"<p>Base class for all scalar expressions.</p> <pre><code>&lt;scalar&gt; ::= &lt;literal&gt;\n| &lt;variable&gt;\n| &lt;default&gt;\n| &lt;negative&gt;\n| &lt;add&gt;\n| &lt;mul&gt;\n| &lt;min&gt;\n| &lt;max&gt;\n| &lt;slice&gt;\n| &lt;inverval&gt;\n\n&lt;mul&gt; ::= &lt;scalar&gt; '*' &lt;scalar&gt;\n&lt;add&gt; ::= &lt;scalar&gt; '+' &lt;scalar&gt;\n&lt;min&gt; ::= 'min' &lt;scalar&gt;+\n&lt;max&gt; ::= 'max' &lt;scalar&gt;+\n&lt;slice&gt; ::= &lt;scalar expr&gt; '[' &lt;interval&gt; ']'\n&lt;interval&gt; ::= &lt;scalar expr&gt; '..' &lt;scalar expr&gt;\n&lt;real&gt; ::= &lt;literal&gt; | &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Variable","title":"Variable","text":"<p>             Bases: <code>Real</code></p> <p>Variable, which stores a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>variable instance.</p> required"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.cast","title":"cast","text":"<pre><code>cast(py)\n</code></pre> <ol> <li> <p>cast Real number (or list/tuple of Real numbers) to <code>Scalar Literal</code>.</p> </li> <li> <p>cast str (or list/tuple of Real numbers) to <code>Scalar Variable</code>.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, Real, Tuple[Real], List[Real]]</code> <p>python object to cast</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>Scalar</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def cast(py) -&gt; \"Scalar\":\n    \"\"\"\n    1. cast Real number (or list/tuple of Real numbers)\n    to [`Scalar Literal`][bloqade.ir.scalar.Literal].\n\n    2. cast str (or list/tuple of Real numbers)\n    to [`Scalar Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str,Real,Tuple[Real],List[Real]]): python object to cast\n\n    Returns:\n        Scalar\n    \"\"\"\n    ret = trycast(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Scalar Literal\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.var","title":"var","text":"<pre><code>var(py)\n</code></pre> <p>cast string (or list/tuple of strings) to <code>Variable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, List[str]]</code> <p>a string or list/tuple of strings</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>Union[Variable]</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def var(py: str) -&gt; \"Variable\":\n    \"\"\"cast string (or list/tuple of strings)\n    to [`Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str, List[str]]): a string or list/tuple of strings\n\n    Returns:\n       Union[Variable]\n    \"\"\"\n    ret = tryvar(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Variable\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade/ir/control/","title":"Index","text":""},{"location":"reference/bloqade/ir/control/field/","title":"Field","text":""},{"location":"reference/bloqade/ir/control/field/#bloqade.ir.control.field.Field","title":"Field","text":"<p>             Bases: <code>FieldExpr</code></p> <p>Field node in the IR. Which contains collection(s) of <code>Waveform</code></p> <pre><code>&lt;field&gt; ::= ('field' &lt;spatial modulation&gt;  &lt;padded waveform&gt;)*\n</code></pre>"},{"location":"reference/bloqade/ir/control/field/#bloqade.ir.control.field.Field.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Field</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Field</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/field.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Field\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Field\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/","title":"Pulse","text":""},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.Append","title":"Append","text":"<p>             Bases: <code>AppendTrait</code>, <code>PulseExpr</code></p> <pre><code>&lt;append&gt; ::= &lt;expr&gt;+\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.Pulse","title":"Pulse","text":"<p>             Bases: <code>PulseExpr</code></p> <pre><code>&lt;pulse&gt; ::= (&lt;field name&gt; &lt;field&gt;)+\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.Pulse.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Pulse</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Pulse</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/pulse.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Pulse\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Pulse\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.PulseExpr","title":"PulseExpr","text":"<p>             Bases: <code>HashTrait</code>, <code>CanonicalizeTrait</code></p> <pre><code>&lt;expr&gt; ::= &lt;pulse&gt;\n  | &lt;append&gt;\n  | &lt;slice&gt;\n  | &lt;named&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/sequence/","title":"Sequence","text":""},{"location":"reference/bloqade/ir/control/sequence/#bloqade.ir.control.sequence.Sequence","title":"Sequence","text":"<p>             Bases: <code>SequenceExpr</code></p> <p>Sequence of a program, which includes pulses informations.</p>"},{"location":"reference/bloqade/ir/control/sequence/#bloqade.ir.control.sequence.Sequence.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Sequence</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Sequence</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/sequence.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Sequence\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Sequence\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Add","title":"Add","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;add&gt; ::= &lt;waveform&gt; '+' &lt;waveform&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.AlignedWaveform","title":"AlignedWaveform","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;padded waveform&gt; ::= &lt;waveform&gt; | &lt;waveform&gt; &lt;alignment&gt; &lt;value&gt;\n\n&lt;alignment&gt; ::= 'left aligned' | 'right aligned'\n&lt;value&gt; ::= 'left value' | 'right value' | &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Append","title":"Append","text":"<p>             Bases: <code>AppendTrait</code>, <code>Waveform</code></p> <pre><code>&lt;append&gt; ::= &lt;waveform&gt;+\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Constant","title":"Constant","text":"<pre><code>Constant(value, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;constant&gt; ::= 'constant' &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Scalar</code> <p>the constant value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the constant waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, value: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"value\", cast(value))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Instruction","title":"Instruction","text":"<p>             Bases: <code>Waveform</code></p> <p>Instruction node in the IR.</p> <ul> <li><code>&lt;linear&gt;</code></li> <li><code>&lt;constant&gt;</code></li> <li><code>&lt;poly&gt;</code></li> <li><code>&lt;python-fn&gt;</code></li> </ul> <pre><code>&lt;instruction&gt; ::= &lt;linear&gt;\n    | &lt;constant&gt;\n    | &lt;poly&gt;\n    | &lt;python-fn&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Linear","title":"Linear","text":"<pre><code>Linear(start, stop, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;linear&gt; ::= 'linear' &lt;scalar expr&gt; &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = start + (stop-start)/duration * t</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Scalar</code> <p>start value</p> required <code>stop</code> <code>Scalar</code> <p>stop value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the linear waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, start: ScalarType, stop: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"start\", cast(start))\n    object.__setattr__(self, \"stop\", cast(stop))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Negative","title":"Negative","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;negative&gt; ::= '-' &lt;waveform&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Poly","title":"Poly","text":"<pre><code>Poly(coeffs, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;poly&gt; ::= &lt;scalar&gt;+\n</code></pre> <p>f(t=0:duration) = c[0] + c[1]t + c[2]t^2 + ... + c[n-1]t^n-1 + c[n]t^n</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>Tuple[Scalar]</code> <p>the coefficients c[] of the polynomial.</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, coeffs: Container[ScalarType], duration: ScalarType):\n    object.__setattr__(self, \"coeffs\", tuple(map(cast, coeffs)))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.PythonFn","title":"PythonFn","text":"<p>             Bases: <code>Instruction</code></p> <pre><code>&lt;python-fn&gt; ::= 'python-fn' &lt;python function def&gt; &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Record","title":"Record","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;record&gt; ::= 'record' &lt;waveform&gt; &lt;var&gt; &lt;side&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Sample","title":"Sample","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;sample&gt; ::= 'sample' &lt;waveform&gt; &lt;interpolation&gt; &lt;scalar&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Scale","title":"Scale","text":"<pre><code>Scale(scalar, waveform)\n</code></pre> <p>             Bases: <code>Waveform</code></p> <pre><code>&lt;scale&gt; ::= &lt;scalar expr&gt; '*' &lt;waveform&gt;\n</code></pre> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, scalar, waveform: Waveform):\n    object.__setattr__(self, \"scalar\", cast(scalar))\n    object.__setattr__(self, \"waveform\", waveform)\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Slice","title":"Slice","text":"<p>             Bases: <code>SliceTrait</code>, <code>Waveform</code></p> <pre><code>&lt;slice&gt; ::= &lt;waveform&gt; &lt;scalar.interval&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Smooth","title":"Smooth","text":"<pre><code>Smooth(radius, kernel, waveform)\n</code></pre> <p>             Bases: <code>Waveform</code></p> <pre><code>&lt;smooth&gt; ::= 'smooth' &lt;kernel&gt; &lt;waveform&gt;\n</code></pre> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, radius, kernel, waveform):\n    if isinstance(kernel, str):\n        if kernel == \"Gaussian\":\n            kernel = GaussianKernel\n        elif kernel == \"Logistic\":\n            kernel = LogisticKernel\n        elif kernel == \"Sigmoid\":\n            kernel = SigmoidKernel\n        elif kernel == \"Triangle\":\n            kernel = TriangleKernel\n        elif kernel == \"Uniform\":\n            kernel = UniformKernel\n        elif kernel == \"Parabolic\":\n            kernel = ParabolicKernel\n        elif kernel == \"Biweight\":\n            kernel = BiweightKernel\n        elif kernel == \"Triweight\":\n            kernel = TriweightKernel\n        elif kernel == \"Tricube\":\n            kernel = TricubeKernel\n        elif kernel == \"Cosine\":\n            kernel = CosineKernel\n        else:\n            raise ValueError(f\"Invalid kernel: {kernel}\")\n\n    object.__setattr__(self, \"radius\", cast(radius))\n    object.__setattr__(self, \"kernel\", kernel)\n    object.__setattr__(self, \"waveform\", waveform)\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Waveform","title":"Waveform","text":"<p>             Bases: <code>HashTrait</code>, <code>CanonicalizeTrait</code></p> <p>Waveform node in the IR.</p> <ul> <li><code>&lt;instruction&gt;</code></li> <li><code>&lt;smooth&gt;</code></li> <li><code>&lt;slice&gt;</code></li> <li><code>&lt;apppend&gt;</code></li> <li><code>&lt;negative&gt;</code></li> <li><code>&lt;scale&gt;</code></li> <li><code>&lt;add&gt;</code></li> <li><code>&lt;record&gt;</code></li> <li><code>&lt;sample&gt;</code></li> </ul> <pre><code>&lt;waveform&gt; ::= &lt;instruction&gt;\n    | &lt;smooth&gt;\n    | &lt;slice&gt;\n    | &lt;append&gt;\n    | &lt;negative&gt;\n    | &lt;scale&gt;\n    | &lt;add&gt;\n    | &lt;record&gt;\n    | &lt;sample&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Waveform.figure","title":"figure","text":"<pre><code>figure(**assignments)\n</code></pre> <p>get figure of the plotting the waveform.</p> <p>Returns:</p> Name Type Description <code>figure</code> <p>a bokeh figure</p> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def figure(self, **assignments):\n    \"\"\"get figure of the plotting the waveform.\n\n    Returns:\n        figure: a bokeh figure\n    \"\"\"\n    return get_ir_figure(self, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/control/traits/","title":"Index","text":""},{"location":"reference/bloqade/ir/control/traits/#bloqade.ir.control.traits.SliceTrait","title":"SliceTrait","text":""},{"location":"reference/bloqade/ir/control/traits/#bloqade.ir.control.traits.SliceTrait.start","title":"start  <code>cached</code> <code>property</code>","text":"<pre><code>start\n</code></pre> <p>Start time of the sliced object</p> <p>Returns:</p> Name Type Description <code>Scalar</code> <code>Scalar</code> <p>The starting time of the sliced object as a</p> <code>Scalar</code> <p>Scalar Expression</p>"},{"location":"reference/bloqade/ir/control/traits/#bloqade.ir.control.traits.SliceTrait.stop","title":"stop  <code>cached</code> <code>property</code>","text":"<pre><code>stop\n</code></pre> <p>Stop time of the sliced object</p> <p>Returns:</p> Name Type Description <code>Scalar</code> <code>Scalar</code> <p>The stopping time of the sliced object as a</p> <code>Scalar</code> <p>Scalar Expression</p>"},{"location":"reference/bloqade/ir/control/traits/append/","title":"Append","text":""},{"location":"reference/bloqade/ir/control/traits/canonicalize/","title":"Canonicalize","text":""},{"location":"reference/bloqade/ir/control/traits/hash/","title":"Hash","text":""},{"location":"reference/bloqade/ir/control/traits/slice/","title":"Slice","text":""},{"location":"reference/bloqade/ir/control/traits/slice/#bloqade.ir.control.traits.slice.SliceTrait","title":"SliceTrait","text":""},{"location":"reference/bloqade/ir/control/traits/slice/#bloqade.ir.control.traits.slice.SliceTrait.start","title":"start  <code>cached</code> <code>property</code>","text":"<pre><code>start\n</code></pre> <p>Start time of the sliced object</p> <p>Returns:</p> Name Type Description <code>Scalar</code> <code>Scalar</code> <p>The starting time of the sliced object as a</p> <code>Scalar</code> <p>Scalar Expression</p>"},{"location":"reference/bloqade/ir/control/traits/slice/#bloqade.ir.control.traits.slice.SliceTrait.stop","title":"stop  <code>cached</code> <code>property</code>","text":"<pre><code>stop\n</code></pre> <p>Stop time of the sliced object</p> <p>Returns:</p> Name Type Description <code>Scalar</code> <code>Scalar</code> <p>The stopping time of the sliced object as a</p> <code>Scalar</code> <p>Scalar Expression</p>"},{"location":"reference/bloqade/ir/location/","title":"Index","text":""},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <p>A Program starting point, alias of empty <code>ListOfLocations</code>.</p> <ul> <li>Next possible steps to build your program are:</li> <li>Specify which level coupling to address with:<ul> <li><code>start.rydberg</code>: for <code>Rydberg</code>     Level coupling</li> <li><code>start.hyperfine</code>: for <code>Hyperfine</code>     Level coupling</li> <li>LOCKOUT: You cannot add atoms to your geometry after specifying level coupling.</li> </ul> </li> <li>continue/start building your geometry with:<ul> <li><code>start.add_position()</code>: to add atom(s) to current register. It will accept:<ul> <li>A single coordinate, represented as a tuple (e.g. <code>(5,6)</code>) with a value that   can either be:<ul> <li>integers: <code>(5,6)</code></li> <li>floats: <code>(5.1, 2.5)</code></li> <li>strings (for later variable assignment): <code>(\"x\", \"y\")</code></li> <li><code>Scalar</code> objects: <code>(2*cast(\"x\"), 5+cast(\"y\"))</code></li> </ul> </li> <li>A list of coordinates, represented as a list of types mentioned previously.</li> <li>A numpy array with shape (n, 2) where n is the total number of atoms</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement","title":"AtomArrangement","text":"<pre><code>AtomArrangement(parent=None)\n</code></pre> <p>             Bases: <code>ProgramStart</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.add_position","title":"add_position","text":"<pre><code>add_position(position, filling=None)\n</code></pre> <p>Add a position or multiple positions to a pre-existing geometry.</p> <p><code>add_position</code> is capable of accepting: - A single tuple for one atom coordinate: <code>(1.0, 2.5)</code> - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.] - A numpy array of shape (N, 2) where N is the number of atoms</p> <p>You may also intersperse variables anywhere a value may be present.</p> <p>You can also pass in an optional argument which determines the atom \"filling\" (whether or not at a specified coordinate an atom should be present).</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.add_position--usage-example","title":"Usage Example:","text":"<pre><code># single coordinate\n&gt;&gt;&gt; reg = start.add_position((0,0))\n# you may chain add_position calls\n&gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n# you can add variables anywhere a value may be present\n&gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n# and specify your atom fillings\n&gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n[True, False])\n# alternatively you could use one boolean to specify\n# all coordinates should be empty/filled\n&gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n(5.2, 2.2)], False)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def add_position(\n    self,\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[Union[BoolArray, List[bool], bool]] = None,\n) -&gt; \"ListOfLocations\":\n    \"\"\"\n    Add a position or multiple positions to a pre-existing geometry.\n\n    `add_position` is capable of accepting:\n    - A single tuple for one atom coordinate: `(1.0, 2.5)`\n    - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.]\n    - A numpy array of shape (N, 2) where N is the number of atoms\n\n    You may also intersperse variables anywhere a value may be present.\n\n    You can also pass in an optional argument which determines the atom \"filling\"\n    (whether or not at a specified coordinate an atom should be present).\n\n    ### Usage Example:\n    ```\n    # single coordinate\n    &gt;&gt;&gt; reg = start.add_position((0,0))\n    # you may chain add_position calls\n    &gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n    # you can add variables anywhere a value may be present\n    &gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n    # and specify your atom fillings\n    &gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n    [True, False])\n    # alternatively you could use one boolean to specify\n    # all coordinates should be empty/filled\n    &gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n    (5.2, 2.2)], False)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`: to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`: to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    if is_bearable(position, PositionArray) and is_bearable(\n        filling, Optional[BoolArray]\n    ):\n        return self.add_position_ndarray(position, filling)\n    elif is_bearable(position, List[Tuple[ScalarType, ScalarType]]) and is_bearable(\n        filling, Optional[List[bool]]\n    ):\n        return self.add_position_list_tuples(position, filling)\n    elif is_bearable(position, Tuple[ScalarType, ScalarType]) and is_bearable(\n        filling, Optional[bool]\n    ):\n        return self.add_position_single_tupe(position, filling)\n    else:\n        raise TypeError(\"Invalid input types for add_position provided!\")\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.apply_defect_count","title":"apply_defect_count","text":"<pre><code>apply_defect_count(n_defects, rng=np.random.default_rng())\n</code></pre> <p>Drop <code>n_defects</code> atoms from the geometry randomly. Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.apply_defect_count--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n# you may also chain apply_defect_count calls\n&gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n# you can also use apply_defect_count on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>:     to add more positions</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_density(defect_probability)</code>:     to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>:     to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify     Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>:     to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>:     shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_count(\n    self, n_defects: int, rng: np.random.Generator = np.random.default_rng()\n):\n    \"\"\"\n    Drop `n_defects` atoms from the geometry randomly. Internally this occurs\n    by setting certain sites to have a SiteFilling set to false indicating\n    no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n    # you may also chain apply_defect_count calls\n    &gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n    # you can also use apply_defect_count on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n            to add more positions\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_count(n_defects)`: to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_density(defect_probability)`:\n            to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n            to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`: to specify\n            Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n            to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n            shows your geometry in your web browser\n    \"\"\"\n\n    location_list = []\n    for location_info in self.enumerate():\n        location_list.append(location_info)\n\n    filled_sites = []\n\n    for index, location_info in enumerate(location_list):\n        if location_info.filling is SiteFilling.filled:\n            filled_sites.append(index)\n\n    if n_defects &gt;= len(filled_sites):\n        raise ValueError(\n            f\"n_defects {n_defects} must be less than the number of filled sites \"\n            f\"({len(filled_sites)})\"\n        )\n\n    for _ in range(n_defects):\n        index = rng.choice(filled_sites)\n        location_list[index] = LocationInfo.create(\n            location_list[index].position,\n            (False if location_list[index].filling is SiteFilling.filled else True),\n        )\n        filled_sites.remove(index)\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.apply_defect_density","title":"apply_defect_density","text":"<pre><code>apply_defect_density(\n    defect_probability, rng=np.random.default_rng()\n)\n</code></pre> <p>Drop atoms randomly with <code>defect_probability</code> probability (range of 0 to 1). Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.apply_defect_density--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n# you may also chain apply_defect_density calls\n&gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n# you can also use apply_defect_density on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n.apply_defect_density(0.5, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>: to add more positions</li> <li><code>...apply_defect_count(defect_counts).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts) .apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_density(\n    self,\n    defect_probability: float,\n    rng: np.random.Generator = np.random.default_rng(),\n):\n    \"\"\"\n    Drop atoms randomly with `defect_probability` probability (range of 0 to 1).\n    Internally this occurs by setting certain sites to have a SiteFilling\n    set to false indicating no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n    # you may also chain apply_defect_density calls\n    &gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n    # you can also use apply_defect_density on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n    .apply_defect_density(0.5, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n        to add more positions\n        - `...apply_defect_count(defect_counts).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n        .apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n        to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`:\n        to specify Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n        shows your geometry in your web browser\n    \"\"\"\n\n    p = min(1, max(0, defect_probability))\n    location_list = []\n\n    for location_info in self.enumerate():\n        if rng.random() &lt; p:\n            location_list.append(\n                LocationInfo.create(\n                    location_info.position,\n                    (\n                        False\n                        if location_info.filling is SiteFilling.filled\n                        else True\n                    ),\n                )\n            )\n        else:\n            location_list.append(location_info)\n\n    return ListOfLocations(location_list=location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs=fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments)\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.scale","title":"scale","text":"<pre><code>scale(scale)\n</code></pre> <p>Scale the geometry of your atoms.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n# atom positions are now (0,0), (2,2)\n&gt;&gt;&gt; new_reg = reg.scale(2)\n# you may also use scale on pre-defined geometries\n&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n# atoms in the chain will now be 2 um apart versus\n# the default 1 um\n&gt;&gt;&gt; Chain(11).scale(2)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef scale(self, scale: ScalarType):\n    \"\"\"\n    Scale the geometry of your atoms.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n    # atom positions are now (0,0), (2,2)\n    &gt;&gt;&gt; new_reg = reg.scale(2)\n    # you may also use scale on pre-defined geometries\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    # atoms in the chain will now be 2 um apart versus\n    # the default 1 um\n    &gt;&gt;&gt; Chain(11).scale(2)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`:\n        to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    scale = cast(scale)\n    location_list = []\n    for location_info in self.enumerate():\n        x, y = location_info.position\n        new_position = (scale * x, scale * y)\n        location_list.append(\n            LocationInfo.create(new_position, bool(location_info.filling.value))\n        )\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(parent=None)\n</code></pre> <p>             Bases: <code>AtomArrangement</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices <code>AtomArrangement</code>.</p> <ul> <li><code>Square</code></li> <li><code>Chain</code></li> <li><code>Honeycomb</code></li> <li><code>Triangular</code></li> <li><code>Lieb</code></li> <li><code>Kagome</code></li> <li><code>Rectangular</code></li> </ul>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index)\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n    \"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n    # damn! this is like stone age broadcasting\n    vectors = np.array(self.cell_vectors())\n    index = np.array(index)\n    pos = np.sum(vectors.T * index, axis=1)\n    return pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor)\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n    \"\"\"Scale the current location with a factor.\n\n    (x,y) -&gt; factor*(x,y)\n\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\n    factor = cast(factor)\n    obj = self.__new__(type(self))\n    for f in fields(self):\n        if f.name == \"lattice_spacing\":\n            obj.lattice_spacing = factor * self.lattice_spacing\n        else:\n            setattr(obj, f.name, getattr(self, f.name))\n    return obj\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Chain","title":"Chain","text":"<pre><code>Chain(L, *, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, *, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.L = L\n    self.lattice_spacing = cast(lattice_spacing)\n    self.vertical_chain = vertical_chain\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Kagome","title":"Kagome","text":"<pre><code>Kagome(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Lieb","title":"Lieb","text":"<pre><code>Lieb(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width,\n    height,\n    *,\n    lattice_spacing_x=1.0,\n    lattice_spacing_y=1.0\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0,\n):\n    self.width = width\n    self.height = height\n    self.lattice_spacing_x = cast(lattice_spacing_x)\n    self.lattice_spacing_y = (\n        cast(lattice_spacing_y)\n        if lattice_spacing_y is not None\n        else self.lattice_spacing_x\n    )\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Square","title":"Square","text":"<pre><code>Square(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Triangular","title":"Triangular","text":"<pre><code>Triangular(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/","title":"Bravais","text":""},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(parent=None)\n</code></pre> <p>             Bases: <code>AtomArrangement</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices <code>AtomArrangement</code>.</p> <ul> <li><code>Square</code></li> <li><code>Chain</code></li> <li><code>Honeycomb</code></li> <li><code>Triangular</code></li> <li><code>Lieb</code></li> <li><code>Kagome</code></li> <li><code>Rectangular</code></li> </ul>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index)\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n    \"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n    # damn! this is like stone age broadcasting\n    vectors = np.array(self.cell_vectors())\n    index = np.array(index)\n    pos = np.sum(vectors.T * index, axis=1)\n    return pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor)\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n    \"\"\"Scale the current location with a factor.\n\n    (x,y) -&gt; factor*(x,y)\n\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\n    factor = cast(factor)\n    obj = self.__new__(type(self))\n    for f in fields(self):\n        if f.name == \"lattice_spacing\":\n            obj.lattice_spacing = factor * self.lattice_spacing\n        else:\n            setattr(obj, f.name, getattr(self, f.name))\n    return obj\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Chain","title":"Chain","text":"<pre><code>Chain(L, *, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, *, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.L = L\n    self.lattice_spacing = cast(lattice_spacing)\n    self.vertical_chain = vertical_chain\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Kagome","title":"Kagome","text":"<pre><code>Kagome(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Lieb","title":"Lieb","text":"<pre><code>Lieb(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width,\n    height,\n    *,\n    lattice_spacing_x=1.0,\n    lattice_spacing_y=1.0\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0,\n):\n    self.width = width\n    self.height = height\n    self.lattice_spacing_x = cast(lattice_spacing_x)\n    self.lattice_spacing_y = (\n        cast(lattice_spacing_y)\n        if lattice_spacing_y is not None\n        else self.lattice_spacing_x\n    )\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Square","title":"Square","text":"<pre><code>Square(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Triangular","title":"Triangular","text":"<pre><code>Triangular(L1, L2=None, *, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/location/","title":"Location","text":""},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement","title":"AtomArrangement","text":"<pre><code>AtomArrangement(parent=None)\n</code></pre> <p>             Bases: <code>ProgramStart</code></p> Source code in <code>src/bloqade/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.add_position","title":"add_position","text":"<pre><code>add_position(position, filling=None)\n</code></pre> <p>Add a position or multiple positions to a pre-existing geometry.</p> <p><code>add_position</code> is capable of accepting: - A single tuple for one atom coordinate: <code>(1.0, 2.5)</code> - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.] - A numpy array of shape (N, 2) where N is the number of atoms</p> <p>You may also intersperse variables anywhere a value may be present.</p> <p>You can also pass in an optional argument which determines the atom \"filling\" (whether or not at a specified coordinate an atom should be present).</p>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.add_position--usage-example","title":"Usage Example:","text":"<pre><code># single coordinate\n&gt;&gt;&gt; reg = start.add_position((0,0))\n# you may chain add_position calls\n&gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n# you can add variables anywhere a value may be present\n&gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n# and specify your atom fillings\n&gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n[True, False])\n# alternatively you could use one boolean to specify\n# all coordinates should be empty/filled\n&gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n(5.2, 2.2)], False)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def add_position(\n    self,\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[Union[BoolArray, List[bool], bool]] = None,\n) -&gt; \"ListOfLocations\":\n    \"\"\"\n    Add a position or multiple positions to a pre-existing geometry.\n\n    `add_position` is capable of accepting:\n    - A single tuple for one atom coordinate: `(1.0, 2.5)`\n    - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.]\n    - A numpy array of shape (N, 2) where N is the number of atoms\n\n    You may also intersperse variables anywhere a value may be present.\n\n    You can also pass in an optional argument which determines the atom \"filling\"\n    (whether or not at a specified coordinate an atom should be present).\n\n    ### Usage Example:\n    ```\n    # single coordinate\n    &gt;&gt;&gt; reg = start.add_position((0,0))\n    # you may chain add_position calls\n    &gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n    # you can add variables anywhere a value may be present\n    &gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n    # and specify your atom fillings\n    &gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n    [True, False])\n    # alternatively you could use one boolean to specify\n    # all coordinates should be empty/filled\n    &gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n    (5.2, 2.2)], False)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`: to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`: to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    if is_bearable(position, PositionArray) and is_bearable(\n        filling, Optional[BoolArray]\n    ):\n        return self.add_position_ndarray(position, filling)\n    elif is_bearable(position, List[Tuple[ScalarType, ScalarType]]) and is_bearable(\n        filling, Optional[List[bool]]\n    ):\n        return self.add_position_list_tuples(position, filling)\n    elif is_bearable(position, Tuple[ScalarType, ScalarType]) and is_bearable(\n        filling, Optional[bool]\n    ):\n        return self.add_position_single_tupe(position, filling)\n    else:\n        raise TypeError(\"Invalid input types for add_position provided!\")\n</code></pre>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.apply_defect_count","title":"apply_defect_count","text":"<pre><code>apply_defect_count(n_defects, rng=np.random.default_rng())\n</code></pre> <p>Drop <code>n_defects</code> atoms from the geometry randomly. Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.apply_defect_count--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n# you may also chain apply_defect_count calls\n&gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n# you can also use apply_defect_count on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>:     to add more positions</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_density(defect_probability)</code>:     to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>:     to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify     Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>:     to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>:     shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_count(\n    self, n_defects: int, rng: np.random.Generator = np.random.default_rng()\n):\n    \"\"\"\n    Drop `n_defects` atoms from the geometry randomly. Internally this occurs\n    by setting certain sites to have a SiteFilling set to false indicating\n    no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n    # you may also chain apply_defect_count calls\n    &gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n    # you can also use apply_defect_count on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n            to add more positions\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_count(n_defects)`: to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_density(defect_probability)`:\n            to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n            to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`: to specify\n            Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n            to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n            shows your geometry in your web browser\n    \"\"\"\n\n    location_list = []\n    for location_info in self.enumerate():\n        location_list.append(location_info)\n\n    filled_sites = []\n\n    for index, location_info in enumerate(location_list):\n        if location_info.filling is SiteFilling.filled:\n            filled_sites.append(index)\n\n    if n_defects &gt;= len(filled_sites):\n        raise ValueError(\n            f\"n_defects {n_defects} must be less than the number of filled sites \"\n            f\"({len(filled_sites)})\"\n        )\n\n    for _ in range(n_defects):\n        index = rng.choice(filled_sites)\n        location_list[index] = LocationInfo.create(\n            location_list[index].position,\n            (False if location_list[index].filling is SiteFilling.filled else True),\n        )\n        filled_sites.remove(index)\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.apply_defect_density","title":"apply_defect_density","text":"<pre><code>apply_defect_density(\n    defect_probability, rng=np.random.default_rng()\n)\n</code></pre> <p>Drop atoms randomly with <code>defect_probability</code> probability (range of 0 to 1). Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.apply_defect_density--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n# you may also chain apply_defect_density calls\n&gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n# you can also use apply_defect_density on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n.apply_defect_density(0.5, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>: to add more positions</li> <li><code>...apply_defect_count(defect_counts).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts) .apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_density(\n    self,\n    defect_probability: float,\n    rng: np.random.Generator = np.random.default_rng(),\n):\n    \"\"\"\n    Drop atoms randomly with `defect_probability` probability (range of 0 to 1).\n    Internally this occurs by setting certain sites to have a SiteFilling\n    set to false indicating no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n    # you may also chain apply_defect_density calls\n    &gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n    # you can also use apply_defect_density on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n    .apply_defect_density(0.5, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n        to add more positions\n        - `...apply_defect_count(defect_counts).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n        .apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n        to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`:\n        to specify Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n        shows your geometry in your web browser\n    \"\"\"\n\n    p = min(1, max(0, defect_probability))\n    location_list = []\n\n    for location_info in self.enumerate():\n        if rng.random() &lt; p:\n            location_list.append(\n                LocationInfo.create(\n                    location_info.position,\n                    (\n                        False\n                        if location_info.filling is SiteFilling.filled\n                        else True\n                    ),\n                )\n            )\n        else:\n            location_list.append(location_info)\n\n    return ListOfLocations(location_list=location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs=fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments)\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.scale","title":"scale","text":"<pre><code>scale(scale)\n</code></pre> <p>Scale the geometry of your atoms.</p>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.AtomArrangement.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n# atom positions are now (0,0), (2,2)\n&gt;&gt;&gt; new_reg = reg.scale(2)\n# you may also use scale on pre-defined geometries\n&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n# atoms in the chain will now be 2 um apart versus\n# the default 1 um\n&gt;&gt;&gt; Chain(11).scale(2)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>@beartype\ndef scale(self, scale: ScalarType):\n    \"\"\"\n    Scale the geometry of your atoms.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n    # atom positions are now (0,0), (2,2)\n    &gt;&gt;&gt; new_reg = reg.scale(2)\n    # you may also use scale on pre-defined geometries\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    # atoms in the chain will now be 2 um apart versus\n    # the default 1 um\n    &gt;&gt;&gt; Chain(11).scale(2)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`:\n        to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    scale = cast(scale)\n    location_list = []\n    for location_info in self.enumerate():\n        x, y = location_info.position\n        new_position = (scale * x, scale * y)\n        location_list.append(\n            LocationInfo.create(new_position, bool(location_info.filling.value))\n        )\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/location/location/#bloqade.ir.location.location.ParallelRegisterInfo","title":"ParallelRegisterInfo","text":"<pre><code>ParallelRegisterInfo(parallel_register)\n</code></pre> <p>ParallelRegisterInfo</p> Source code in <code>src/bloqade/ir/location/location.py</code> <pre><code>def __init__(self, parallel_register: ParallelRegister):\n    atom_arrangement = parallel_register.atom_arrangement\n    cluster_spacing = parallel_register.cluster_spacing\n\n    if atom_arrangement.n_atoms &gt; 0:\n        # calculate bounding box\n        # of this register\n        location_iter = atom_arrangement.enumerate()\n        (x, y) = next(location_iter).position\n        x_min = x\n        x_max = x\n        y_min = y\n        y_max = y\n\n        for location_info in location_iter:\n            (x, y) = location_info.position\n            x_min = x.min(x_min)\n            x_max = x.max(x_max)\n            y_min = y.min(y_min)\n            y_max = y.max(y_max)\n\n        shift_x = (x_max - x_min) + cluster_spacing\n        shift_y = (y_max - y_min) + cluster_spacing\n\n        register_locations = [\n            list(location_info.position)\n            for location_info in atom_arrangement.enumerate()\n        ]\n        register_filling = [\n            location_info.filling.value\n            for location_info in atom_arrangement.enumerate()\n        ]\n        shift_vectors = [[shift_x, cast(0)], [cast(0), shift_y]]\n    else:\n        raise ValueError(\"No locations to parallelize.\")\n\n    self.register_locations = register_locations\n    self.register_filling = register_filling\n    self.shift_vectors = shift_vectors\n</code></pre>"},{"location":"reference/bloqade/ir/routine/","title":"Index","text":""},{"location":"reference/bloqade/ir/routine/base/","title":"Base","text":""},{"location":"reference/bloqade/ir/routine/base/#bloqade.ir.routine.base.Routine","title":"Routine","text":"<p>             Bases: <code>RoutineBase</code></p> <p>Result of parsing a completed Builder string.</p>"},{"location":"reference/bloqade/ir/routine/base/#bloqade.ir.routine.base.RoutineShow","title":"RoutineShow","text":"<p>             Bases: <code>Show</code></p>"},{"location":"reference/bloqade/ir/routine/base/#bloqade.ir.routine.base.RoutineShow.show","title":"show","text":"<pre><code>show(*args, batch_index=0)\n</code></pre> <p>Show an interactive plot of the routine.</p> int <p>which parameter set out of the batch to use. Default is 0. If there are no batch parameters, use 0.</p> <p>*args: Any     Specify the parameters that are defined in the <code>.args([...])</code> build step.</p> Source code in <code>src/bloqade/ir/routine/base.py</code> <pre><code>def show(self: \"RoutineBase\", *args, batch_index: int = 0):\n    \"\"\"Show an interactive plot of the routine.\n\n    batch_index: int\n        which parameter set out of the batch to use. Default is 0.\n        If there are no batch parameters, use 0.\n\n    *args: Any\n        Specify the parameters that are defined in the `.args([...])` build step.\n\n    \"\"\"\n    if self.source is None:\n        raise ValueError(\"Cannot show a routine without a source Builder.\")\n\n    return self.source.show(*args, batch_id=batch_index)\n</code></pre>"},{"location":"reference/bloqade/ir/routine/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadeEmulation","title":"BloqadeEmulation  <code>dataclass</code>","text":"<p>Data class to hold the Hamiltonian and metadata for a given set of parameters</p>"},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadeEmulation.hamiltonian","title":"hamiltonian  <code>property</code>","text":"<pre><code>hamiltonian\n</code></pre> <p>Return the Hamiltonian object for the given task data.</p>"},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadeEmulation.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata\n</code></pre> <p>The metadata for the given task data.</p>"},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadeEmulation.evolve","title":"evolve","text":"<pre><code>evolve(\n    state=None,\n    solver_name=\"dop853\",\n    atol=1e-07,\n    rtol=1e-14,\n    nsteps=2147483647,\n    times=(),\n    interaction_picture=False,\n)\n</code></pre> <p>Evolve an initial state vector using the Hamiltonian</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Optional[StateVector]</code> <p>The initial state vector to</p> <code>None</code> <code>solver_name</code> <code>str</code> <p>Which SciPy Solver to use. Defaults to</p> <code>'dop853'</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for ODE solver. Defaults</p> <code>1e-07</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive step in</p> <code>1e-14</code> <code>nsteps</code> <code>int</code> <p>Maximum number of steps allowed per integration</p> <code>2147483647</code> <code>times</code> <code>Sequence[float]</code> <p>The times to evaluate the state vector</p> <code>()</code> <code>interaction_picture</code> <code>bool</code> <p>Use the interaction picture when</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterator[StateVector]</code> <p>Iterator[StateVector]: An iterator of the state vectors at each time step.</p> Source code in <code>src/bloqade/ir/routine/bloqade.py</code> <pre><code>def evolve(\n    self,\n    state: Optional[StateVector] = None,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-7,\n    rtol: float = 1e-14,\n    nsteps: int = 2147483647,\n    times: Sequence[float] = (),\n    interaction_picture: bool = False,\n) -&gt; Iterator[StateVector]:\n    \"\"\"Evolve an initial state vector using the Hamiltonian\n\n    Args:\n        state (Optional[StateVector], optional): The initial state vector to\n        evolve. if not provided, the zero state will be used. Defaults to None.\n        solver_name (str, optional): Which SciPy Solver to use. Defaults to\n        \"dop853\".\n        atol (float, optional): Absolute tolerance for ODE solver. Defaults\n        to 1e-14.\n        rtol (float, optional): Relative tolerance for adaptive step in\n        ODE solver. Defaults to 1e-7.\n        nsteps (int, optional): Maximum number of steps allowed per integration\n        step. Defaults to 2147483647.\n        times (Sequence[float], optional): The times to evaluate the state vector\n        at. Defaults to (). If not provided the state will be evaluated at\n        the end of the bloqade program.\n        interaction_picture (bool, optional): Use the interaction picture when\n        solving schrodinger equation. Defaults to False.\n\n    Returns:\n        Iterator[StateVector]: An iterator of the state vectors at each time step.\n\n    \"\"\"\n    state = self.zero_state(np.complex128) if state is None else state\n\n    U = AnalogGate(self.hamiltonian)\n\n    return U.apply(\n        state,\n        times=times,\n        solver_name=solver_name,\n        atol=atol,\n        rtol=rtol,\n        nsteps=nsteps,\n        interaction_picture=interaction_picture,\n    )\n</code></pre>"},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadeEmulation.fock_state","title":"fock_state","text":"<pre><code>fock_state(fock_state_str, dtype=np.float64)\n</code></pre> <p>Return the fock state for the given Hamiltonian.</p> Source code in <code>src/bloqade/ir/routine/bloqade.py</code> <pre><code>def fock_state(\n    self, fock_state_str: str, dtype: np.dtype = np.float64\n) -&gt; StateVector:\n    \"\"\"Return the fock state for the given Hamiltonian.\"\"\"\n    index = self.hamiltonian.space.fock_state_to_index(fock_state_str)\n    data = np.zeros(self.hamiltonian.space.size, dtype=dtype)\n    data[index] = 1\n    return StateVector(data, self.hamiltonian.space)\n</code></pre>"},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadeEmulation.zero_state","title":"zero_state","text":"<pre><code>zero_state(dtype=np.float64)\n</code></pre> <p>Return the zero state for the given Hamiltonian.</p> Source code in <code>src/bloqade/ir/routine/bloqade.py</code> <pre><code>def zero_state(self, dtype: np.dtype = np.float64) -&gt; StateVector:\n    \"\"\"Return the zero state for the given Hamiltonian.\"\"\"\n    return self.hamiltonian.space.zero_state(dtype)\n</code></pre>"},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadePythonRoutine","title":"BloqadePythonRoutine","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadePythonRoutine.run","title":"run","text":"<pre><code>run(\n    shots,\n    args=(),\n    name=None,\n    blockade_radius=0.0,\n    waveform_runtime=\"interpret\",\n    interaction_picture=False,\n    cache_matrices=False,\n    multiprocessing=False,\n    num_workers=None,\n    solver_name=\"dop853\",\n    atol=1e-07,\n    rtol=1e-14,\n    nsteps=2147483647,\n)\n</code></pre> <p>Run the current program using bloqade python backend</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots after running state vector simulation</p> required <code>args</code> <code>Tuple[LiteralType, ...]</code> <p>The values for parameters defined</p> <code>()</code> <code>name</code> <code>Optional[str]</code> <p>Name to give this run. Defaults to None.</p> <code>None</code> <code>blockade_radius</code> <code>float</code> <p>Use the Blockade subspace given a</p> <code>0.0</code> <code>waveform_runtime</code> <code>str</code> <p>(bool, optional): Use Numba to compile the waveforms,</p> <code>'interpret'</code> <code>interaction_picture</code> <code>bool</code> <p>Use the interaction picture when</p> <code>False</code> <code>cache_matrices</code> <code>bool</code> <p>Reuse previously evaluated matrcies when</p> <code>False</code> <code>multiprocessing</code> <code>bool</code> <p>Use multiple processes to process the</p> <code>False</code> <code>num_workers</code> <code>Optional[int]</code> <p>Number of processes to run with</p> <code>None</code> <code>solver_name</code> <code>str</code> <p>Which SciPy Solver to use. Defaults to</p> <code>'dop853'</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for ODE solver. Defaults to</p> <code>1e-07</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive step in ODE solver.</p> <code>1e-14</code> <code>nsteps</code> <code>int</code> <p>Maximum number of steps allowed per integration</p> <code>2147483647</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Cannot use multiprocessing and cache_matrices at the same time.</p> <p>Returns:</p> Name Type Description <code>LocalBatch</code> <code>LocalBatch</code> <p>Batch of local tasks that have been executed.</p> Source code in <code>src/bloqade/ir/routine/bloqade.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    blockade_radius: float = 0.0,\n    waveform_runtime: str = \"interpret\",\n    interaction_picture: bool = False,\n    cache_matrices: bool = False,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-7,\n    rtol: float = 1e-14,\n    nsteps: int = 2_147_483_647,\n) -&gt; LocalBatch:\n    \"\"\"Run the current program using bloqade python backend\n\n    Args:\n        shots (int): number of shots after running state vector simulation\n        args (Tuple[LiteralType, ...], optional): The values for parameters defined\n        in `args`. Defaults to ().\n        name (Optional[str], optional): Name to give this run. Defaults to None.\n        blockade_radius (float, optional): Use the Blockade subspace given a\n        particular radius. Defaults to 0.0.\n        waveform_runtime: (bool, optional): Use Numba to compile the waveforms,\n        Defaults to False.\n        interaction_picture (bool, optional): Use the interaction picture when\n        solving schrodinger equation. Defaults to False.\n        cache_matrices (bool, optional): Reuse previously evaluated matrcies when\n        possible. Defaults to False.\n        multiprocessing (bool, optional): Use multiple processes to process the\n        batches. Defaults to False.\n        num_workers (Optional[int], optional): Number of processes to run with\n        multiprocessing. Defaults to None.\n        solver_name (str, optional): Which SciPy Solver to use. Defaults to\n        \"dop853\".\n        atol (float, optional): Absolute tolerance for ODE solver. Defaults to\n        1e-14.\n        rtol (float, optional): Relative tolerance for adaptive step in ODE solver.\n        Defaults to 1e-7.\n        nsteps (int, optional): Maximum number of steps allowed per integration\n        step. Defaults to 2_147_483_647, the maximum value.\n\n    Raises:\n        ValueError: Cannot use multiprocessing and cache_matrices at the same time.\n\n    Returns:\n        LocalBatch: Batch of local tasks that have been executed.\n    \"\"\"\n    if multiprocessing and cache_matrices:\n        raise ValueError(\n            \"Cannot use multiprocessing and cache_matrices at the same time.\"\n        )\n\n    compile_options = dict(\n        shots=shots,\n        args=args,\n        name=name,\n        blockade_radius=blockade_radius,\n        cache_matrices=cache_matrices,\n        waveform_runtime=waveform_runtime,\n    )\n\n    solver_options = dict(\n        multiprocessing=multiprocessing,\n        num_workers=num_workers,\n        solver_name=solver_name,\n        atol=atol,\n        rtol=rtol,\n        nsteps=nsteps,\n        interaction_picture=interaction_picture,\n    )\n\n    batch = self._compile(**compile_options)\n    batch._run(**solver_options)\n\n    return batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadePythonRoutine.run_callback","title":"run_callback","text":"<pre><code>run_callback(\n    callback,\n    program_args=(),\n    callback_args=(),\n    ignore_exceptions=False,\n    blockade_radius=0.0,\n    waveform_runtime=\"interpret\",\n    interaction_picture=False,\n    cache_matrices=False,\n    multiprocessing=False,\n    num_workers=None,\n    solver_name=\"dop853\",\n    atol=1e-07,\n    rtol=1e-14,\n    nsteps=2147483647,\n    use_hyperfine=False,\n)\n</code></pre> <p>Run state-vector simulation with a callback to access full state-vector from emulator</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[StateVector, Metadata, RydbergHamiltonian, Any], Any]</code> required <code>program_args</code> <code>Tuple[LiteralType, ...]</code> <p>The values for parameters</p> <code>()</code> <code>callback_args</code> <code>Tuple[Any, ...]</code> <p>Extra arguments to pass into</p> <code>()</code> <code>ignore_exceptions</code> <code>bool</code> <p>(bool, optional) If <code>True</code> any exception raised during</p> <code>False</code> <code>blockade_radius</code> <code>float</code> <p>Use the Blockade subspace given a</p> <code>0.0</code> <code>waveform_runtime</code> <code>str</code> <p>(str, optional): Specify which runtime to use for</p> <code>'interpret'</code> <code>interaction_picture</code> <code>bool</code> <p>Use the interaction picture when</p> <code>False</code> <code>cache_matrices</code> <code>bool</code> <p>Reuse previously evaluated matrcies when</p> <code>False</code> <code>multiprocessing</code> <code>bool</code> <p>Use multiple processes to process the</p> <code>False</code> <code>num_workers</code> <code>Optional[int]</code> <p>Number of processes to run with</p> <code>None</code> <code>solver_name</code> <code>str</code> <p>Which SciPy Solver to use. Defaults to</p> <code>'dop853'</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for ODE solver. Defaults to</p> <code>1e-07</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive step in ODE solver.</p> <code>1e-14</code> <code>nsteps</code> <code>int</code> <p>Maximum number of steps allowed per integration</p> <code>2147483647</code> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>List of resulting outputs from the callbacks</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Raises the first error that occurs, only if</p> Note <p>For the <code>callback</code> function, first argument is the many-body wavefunction as a 1D complex numpy array, the second argument is of type <code>Metadata</code> which is a Named Tuple where the fields correspond to the parameters of that given task, RydbergHamiltonian is the object that contains the Hamiltonian used to generate the evolution for that task, Finally any optional positional arguments are allowed after that. The return value can be anything, the results will be collected in a list for each task in the batch.</p> Source code in <code>src/bloqade/ir/routine/bloqade.py</code> <pre><code>@beartype\ndef run_callback(\n    self,\n    callback: Callable[[StateVector, NamedTuple, RydbergHamiltonian, Any], Any],\n    program_args: Tuple[LiteralType, ...] = (),\n    callback_args: Tuple = (),\n    ignore_exceptions: bool = False,\n    blockade_radius: float = 0.0,\n    waveform_runtime: str = \"interpret\",\n    interaction_picture: bool = False,\n    cache_matrices: bool = False,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-7,\n    rtol: float = 1e-14,\n    nsteps: int = 2_147_483_647,\n    use_hyperfine: bool = False,\n) -&gt; List:\n    \"\"\"Run state-vector simulation with a callback to access full state-vector from\n    emulator\n\n    Args:\n        callback (Callable[[StateVector, Metadata, RydbergHamiltonian, Any], Any]):\n        The callback function to run for each task in batch. See note below for more\n        details about the signature of the function.\n        program_args (Tuple[LiteralType, ...], optional): The values for parameters\n        defined in `args`. Defaults to ().\n        callback_args (Tuple[Any,...], optional): Extra arguments to pass into\n        ignore_exceptions: (bool, optional) If `True` any exception raised during\n        a task will be saved instead of the resulting output of the callback,\n        otherwise the first exception by task number will be raised after *all*\n        tasks have executed. Defaults to False.\n        blockade_radius (float, optional): Use the Blockade subspace given a\n        particular radius. Defaults to 0.0.\n        waveform_runtime: (str, optional): Specify which runtime to use for\n        waveforms. Defaults to \"interpret\".\n        interaction_picture (bool, optional): Use the interaction picture when\n        solving schrodinger equation. Defaults to False.\n        cache_matrices (bool, optional): Reuse previously evaluated matrcies when\n        possible. Defaults to False.\n        multiprocessing (bool, optional): Use multiple processes to process the\n        batches. Defaults to False.\n        num_workers (Optional[int], optional): Number of processes to run with\n        multiprocessing. Defaults to None.\n        solver_name (str, optional): Which SciPy Solver to use. Defaults to\n        \"dop853\".\n        atol (float, optional): Absolute tolerance for ODE solver. Defaults to\n        1e-14.\n        rtol (float, optional): Relative tolerance for adaptive step in ODE solver.\n        Defaults to 1e-7.\n        nsteps (int, optional): Maximum number of steps allowed per integration\n        step. Defaults to 2_147_483_647, the maximum value.\n\n    Returns:\n        List: List of resulting outputs from the callbacks\n\n    Raises:\n        RuntimeError: Raises the first error that occurs, only if\n        `ignore_exceptions=False`.\n\n    Note:\n        For the `callback` function, first argument is the many-body wavefunction\n        as a 1D complex numpy array, the second argument is of type `Metadata` which\n        is a Named Tuple where the fields correspond to the parameters of that given\n        task, RydbergHamiltonian is the object that contains the Hamiltonian used to\n        generate the evolution for that task, Finally any optional positional\n        arguments are allowed after that. The return value can be anything, the\n        results will be collected in a list for each task in the batch.\n\n\n    \"\"\"\n    if multiprocessing:\n        from multiprocessing import Process, Queue, cpu_count\n    else:\n        from queue import Queue\n\n    if cache_matrices:\n        compile_cache = CompileCache()\n    else:\n        compile_cache = None\n\n    solver_args = dict(\n        solver_name=solver_name,\n        atol=atol,\n        rtol=rtol,\n        nsteps=nsteps,\n        interaction_picture=interaction_picture,\n    )\n\n    runner = self.EmuRunner(\n        compile_cache=compile_cache,\n        solver_args=solver_args,\n        callback=callback,\n        callback_args=callback_args,\n    )\n\n    tasks = Queue()\n    results = Queue()\n\n    total_tasks = 0\n    ir_iter = self._generate_ir(\n        program_args, blockade_radius, waveform_runtime, use_hyperfine\n    )\n    for task_data in ir_iter:\n        task_number = task_data.task_id\n        emulator_ir = task_data.emulator_ir\n        metadata = task_data.metadata_dict\n        total_tasks += 1\n        tasks.put((task_number, (emulator_ir, metadata)))\n\n    workers = []\n    if multiprocessing:\n        num_workers = max(int(num_workers or cpu_count()), 1)\n        num_workers = min(total_tasks, num_workers)\n\n        for _ in range(num_workers):\n            worker = Process(\n                target=BloqadePythonRoutine.process_tasks,\n                args=(runner, tasks, results),\n            )\n            worker.start()\n\n            workers.append(worker)\n    else:\n        self.process_tasks(runner, tasks, results)\n\n    # blocks until all\n    # results have been fetched\n    # from the id_results Queue\n    id_results = []\n    for i in range(total_tasks):\n        id_results.append(results.get())\n\n    if workers:\n        for worker in workers:\n            worker.join()\n\n        tasks.close()\n        results.close()\n\n    id_results.sort(key=lambda x: x[0])\n    results = []\n\n    for task_id, result in id_results:\n        if not ignore_exceptions and isinstance(result, BaseException):\n            try:\n                raise result\n            except BaseException:\n                raise RuntimeError(\n                    f\"{result.__class__.__name__} occured during child process \"\n                    f\"running for task number {task_id}:\\n{traceback.format_exc()}\"\n                )\n\n        results.append(result)\n\n    return results\n</code></pre>"},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.TaskData","title":"TaskData  <code>dataclass</code>","text":"<p>Data class to hold the program ir and metadata for a given set of parameters</p>"},{"location":"reference/bloqade/ir/routine/braket/","title":"Braket","text":""},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine","title":"BraketHardwareRoutine","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine.__call__","title":"__call__","text":"<pre><code>__call__(\n    *args, shots=1, name=None, shuffle=False, **kwargs\n)\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, run_async to Braket, and wait until the results are coming back.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> <code>1</code> <code>args</code> <code>LiteralType</code> <p>additional arguments for args variables.</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef __call__(\n    self,\n    *args: LiteralType,\n    shots: int = 1,\n    name: Optional[str] = None,\n    shuffle: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, run_async to Braket,\n    and wait until the results are coming back.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args: additional arguments for args variables.\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    return self.run(shots, args, name, shuffle, **kwargs)\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine.run","title":"run","text":"<pre><code>run(shots, args=(), name=None, shuffle=False, **kwargs)\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, run_async to Braket, and wait until the results are coming back.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>additional arguments</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    shuffle: bool = False,\n    **kwargs,\n) -&gt; RemoteBatch:\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, run_async to Braket,\n    and wait until the results are coming back.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args (Tuple): additional arguments\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n\n    batch = self.run_async(shots, args, name, shuffle, **kwargs)\n    batch.pull()\n    return batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine.run_async","title":"run_async","text":"<pre><code>run_async(\n    shots, args=(), name=None, shuffle=False, **kwargs\n)\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, and run_async to Braket.</p> Note <p>This is async.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>Values of the parameter defined in <code>args</code>, defaults to ()</p> <code>()</code> <code>name</code> <code>str | None</code> <p>custom name of the batch, defaults to None</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef run_async(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    shuffle: bool = False,\n    **kwargs,\n) -&gt; RemoteBatch:\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, and run_async to Braket.\n\n    Note:\n        This is async.\n\n    Args:\n        shots (int): number of shots\n        args (Tuple): Values of the parameter defined in `args`, defaults to ()\n        name (str | None): custom name of the batch, defaults to None\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n\n    batch = self._compile(shots, args, name)\n    batch._submit(shuffle, **kwargs)\n    return batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketLocalEmulatorRoutine","title":"BraketLocalEmulatorRoutine","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketLocalEmulatorRoutine.__call__","title":"__call__","text":"<pre><code>__call__(\n    *args,\n    shots=1,\n    name=None,\n    multiprocessing=False,\n    num_workers=None,\n    **kwargs\n)\n</code></pre> <p>Compile to a LocalBatch, and run. The LocalBatch contain tasks to run on local emulator.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> <code>1</code> <code>args</code> <code>LiteralType</code> <p>additional arguments for args variables.</p> <code>()</code> <code>multiprocessing</code> <code>bool</code> <p>enable multi-process</p> <code>False</code> <code>num_workers</code> <code>int</code> <p>number of workers to run the emulator</p> <code>None</code> Return <p>LocalBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef __call__(\n    self,\n    *args: LiteralType,\n    shots: int = 1,\n    name: Optional[str] = None,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    **kwargs,\n):\n    \"\"\"\n    Compile to a LocalBatch, and run.\n    The LocalBatch contain tasks to run on local emulator.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args: additional arguments for args variables.\n        multiprocessing (bool): enable multi-process\n        num_workers (int): number of workers to run the emulator\n\n    Return:\n        LocalBatch\n\n    \"\"\"\n    return self.run(\n        shots,\n        args,\n        name,\n        multiprocessing=multiprocessing,\n        num_workers=num_workers,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketLocalEmulatorRoutine.run","title":"run","text":"<pre><code>run(\n    shots,\n    args=(),\n    name=None,\n    multiprocessing=False,\n    num_workers=None,\n    **kwargs\n)\n</code></pre> <p>Compile to a LocalBatch, and run. The LocalBatch contain tasks to run on local emulator.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple[LiteralType, ...]</code> <p>additional arguments for args variables.</p> <code>()</code> <code>multiprocessing</code> <code>bool</code> <p>enable multi-process</p> <code>False</code> <code>num_workers</code> <code>int</code> <p>number of workers to run the emulator</p> <code>None</code> Return <p>LocalBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    **kwargs,\n) -&gt; LocalBatch:\n    \"\"\"\n    Compile to a LocalBatch, and run.\n    The LocalBatch contain tasks to run on local emulator.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args: additional arguments for args variables.\n        multiprocessing (bool): enable multi-process\n        num_workers (int): number of workers to run the emulator\n\n    Return:\n        LocalBatch\n\n    \"\"\"\n\n    batch = self._compile(shots, args, name)\n    batch._run(multiprocessing=multiprocessing, num_workers=num_workers, **kwargs)\n    return batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/params/","title":"Params","text":""},{"location":"reference/bloqade/ir/routine/quera/","title":"Quera","text":""},{"location":"reference/bloqade/ir/routine/quera/#bloqade.ir.routine.quera.CustomSubmissionRoutine","title":"CustomSubmissionRoutine","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/quera/#bloqade.ir.routine.quera.CustomSubmissionRoutine.submit","title":"submit","text":"<pre><code>submit(\n    shots,\n    url,\n    json_body_template,\n    method=\"POST\",\n    args=(),\n    request_options={},\n    sleep_time=0.1,\n)\n</code></pre> <p>Compile to QuEraTaskSpecification and submit to a custom service.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>url</code> <code>str</code> <p>url of the custom service</p> required <code>json_body_template</code> <code>str</code> <p>json body template, must contain '{task_ir}'</p> required <code>method</code> <code>str</code> <p>http method to be used. Defaults to \"POST\".</p> <code>'POST'</code> <code>args</code> <code>Tuple[LiteralType]</code> <p>additional arguments to be passed into the</p> <code>()</code> <code>request_options</code> <code>Dict[str, Any]</code> <p>additional options to be passed into the request method,</p> <code>{}</code> <code>sleep_time</code> <code>float</code> <p>time to sleep between each request. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Type Description <code>List[Tuple[NamedTuple, Response]]</code> <p>List[Tuple[NamedTuple, Response]]: List of parameters for each batch in</p> <code>List[Tuple[NamedTuple, Response]]</code> <p>the task and the response from the post request.</p> <p>Examples:</p> <p>Here is a simple example of how to use this method. Note the body_template has double curly braces on the outside to escape the string formatting.</p> <pre><code>&gt;&gt;&gt; body_template = \"{{\"token\": \"my_token\", \"task\": {task_ir}}}\"\n&gt;&gt;&gt; responses = (\n    program.quera.custom.submit(\n        100,\n        \"http://my_custom_service.com\",\n        body_template\n    )\n)\n</code></pre> Source code in <code>src/bloqade/ir/routine/quera.py</code> <pre><code>def submit(\n    self,\n    shots: int,\n    url: str,\n    json_body_template: str,\n    method: str = \"POST\",\n    args: Tuple[LiteralType] = (),\n    request_options: Dict[str, Any] = {},\n    sleep_time: float = 0.1,\n) -&gt; List[Tuple[NamedTuple, Response]]:\n    \"\"\"Compile to QuEraTaskSpecification and submit to a custom service.\n\n    Args:\n        shots (int): number of shots\n        url (str): url of the custom service\n        json_body_template (str): json body template, must contain '{task_ir}'\n        which is a placeholder for a string representation of the task ir.\n        The task ir string will be inserted into the template with\n        `json_body_template.format(task_ir=task_ir_string)`.\n        to be replaced by QuEraTaskSpecification\n        method (str): http method to be used. Defaults to \"POST\".\n        args (Tuple[LiteralType]): additional arguments to be passed into the\n        compiler coming from `args` option of the build. Defaults to ().\n        request_options: additional options to be passed into the request method,\n        Note the `data` option will be overwritten by the\n        `json_body_template.format(task_ir=task_ir_string)`.\n        sleep_time (float): time to sleep between each request. Defaults to 0.1.\n\n    Returns:\n        List[Tuple[NamedTuple, Response]]: List of parameters for each batch in\n        the task and the response from the post request.\n\n    Examples:\n        Here is a simple example of how to use this method. Note the body_template\n        has double curly braces on the outside to escape the string formatting.\n\n    ```python\n    &gt;&gt;&gt; body_template = \"{{\"token\": \"my_token\", \"task\": {task_ir}}}\"\n    &gt;&gt;&gt; responses = (\n        program.quera.custom.submit(\n            100,\n            \"http://my_custom_service.com\",\n            body_template\n        )\n    )\n    ```\n    \"\"\"\n\n    if r\"{task_ir}\" not in json_body_template:\n        raise ValueError(r\"body_template must contain '{task_ir}'\")\n\n    partial_eval = json_body_template.format(task_ir='\"task_ir\"')\n    try:\n        _ = json.loads(partial_eval)\n    except json.JSONDecodeError as e:\n        raise ValueError(\n            \"body_template must be a valid json template. \"\n            'When evaluating template with task_ir=\"task_ir\", '\n            f\"the template evaluated to: {partial_eval!r}.\\n\"\n            f\"JSONDecodeError: {e}\"\n        )\n\n    out = []\n    for metadata, task_ir in self._compile(shots, args):\n        json_request_body = json_body_template.format(\n            task_ir=task_ir.json(exclude_none=True, exclude_unset=True)\n        )\n        request_options.update(data=json_request_body)\n        response = request(method, url, **request_options)\n        out.append((metadata, response))\n        time.sleep(sleep_time)\n\n    return out\n</code></pre>"},{"location":"reference/bloqade/ir/routine/quera/#bloqade.ir.routine.quera.QuEraHardwareRoutine","title":"QuEraHardwareRoutine","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/quera/#bloqade.ir.routine.quera.QuEraHardwareRoutine.run_async","title":"run_async","text":"<pre><code>run_async(\n    shots, args=(), name=None, shuffle=False, **kwargs\n)\n</code></pre> <p>Compile to a RemoteBatch, which contain     QuEra backend specific tasks,     and run_async through QuEra service.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>additional arguments</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/quera.py</code> <pre><code>@beartype\ndef run_async(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    shuffle: bool = False,\n    **kwargs,\n) -&gt; RemoteBatch:\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n        QuEra backend specific tasks,\n        and run_async through QuEra service.\n\n    Args:\n        shots (int): number of shots\n        args (Tuple): additional arguments\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    batch = self._compile(shots, args, name)\n    batch._submit(shuffle, **kwargs)\n    return batch\n</code></pre>"},{"location":"reference/bloqade/submission/","title":"Index","text":""},{"location":"reference/bloqade/submission/base/","title":"Base","text":""},{"location":"reference/bloqade/submission/braket/","title":"Braket","text":""},{"location":"reference/bloqade/submission/load_config/","title":"Load config","text":""},{"location":"reference/bloqade/submission/mock/","title":"Mock","text":""},{"location":"reference/bloqade/submission/quera/","title":"Quera","text":""},{"location":"reference/bloqade/submission/ir/","title":"Index","text":""},{"location":"reference/bloqade/submission/ir/braket/","title":"Braket","text":""},{"location":"reference/bloqade/submission/ir/capabilities/","title":"Capabilities","text":""},{"location":"reference/bloqade/submission/ir/parallel/","title":"Parallel","text":""},{"location":"reference/bloqade/submission/ir/parallel/#bloqade.submission.ir.parallel.ClusterLocationInfo","title":"ClusterLocationInfo","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class that stores the mapping of batched jobs.</p> <p>Parameters:</p> Name Type Description Default <code>cluster_index</code> <code>int</code> <p>the index of the cluster a site belongs to</p> required <code>global_location_index</code> <code>int</code> <p>the index of the site in the multplexed system</p> required <code>cluster_location_index</code> <code>int</code> <p>the index of the site in the original system</p> required"},{"location":"reference/bloqade/submission/ir/task_results/","title":"Task results","text":""},{"location":"reference/bloqade/submission/ir/task_results/#bloqade.submission.ir.task_results.QuEraTaskResults","title":"QuEraTaskResults","text":"<p>             Bases: <code>BaseModel</code></p>"},{"location":"reference/bloqade/submission/ir/task_results/#bloqade.submission.ir.task_results.QuEraTaskResults.export_as_probabilities","title":"export_as_probabilities","text":"<pre><code>export_as_probabilities()\n</code></pre> <p>converts from shot results to probabilities</p> <p>Returns:</p> Name Type Description <code>TaskProbabilities</code> <code>TaskProbabilities</code> <p>The task results as probabilties</p> Source code in <code>src/bloqade/submission/ir/task_results.py</code> <pre><code>def export_as_probabilities(self) -&gt; TaskProbabilities:\n    \"\"\"converts from shot results to probabilities\n\n    Returns:\n        TaskProbabilities: The task results as probabilties\n    \"\"\"\n    counts = dict()\n    nshots = len(self.shot_outputs)\n    for shot_result in self.shot_outputs:\n        pre_sequence_str = \"\".join(str(bit) for bit in shot_result.pre_sequence)\n\n        post_sequence_str = \"\".join(str(bit) for bit in shot_result.post_sequence)\n\n        configuration = (pre_sequence_str, post_sequence_str)\n        # iterative average\n        current_count = counts.get(configuration, 0)\n        counts[configuration] = current_count + 1\n\n    probabilities = [(config, count / nshots) for config, count in counts.items()]\n    return TaskProbabilities(probabilities=probabilities)\n</code></pre>"},{"location":"reference/bloqade/submission/ir/task_specification/","title":"Task specification","text":""},{"location":"reference/bloqade/task/","title":"Index","text":""},{"location":"reference/bloqade/task/base/","title":"Base","text":""},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report","title":"Report","text":"<pre><code>Report(data, metas, geos, name='')\n</code></pre> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def __init__(self, data, metas, geos, name=\"\") -&gt; None:\n    self.dataframe = data  # df\n    self._bitstrings = None  # bitstring cache\n    self._counts = None  # counts cache\n    self.metas = metas\n    self.geos = geos\n    self.name = name + \" \" + str(datetime.datetime.now())\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.bitstrings","title":"bitstrings","text":"<pre><code>bitstrings(filter_perfect_filling=True, clusters=[])\n</code></pre> <p>Get the bitstrings from the data.</p> <p>Parameters:</p> Name Type Description Default <code>filter_perfect_filling</code> <code>bool</code> <p>whether return will</p> <code>True</code> <code>clusters</code> <code>Union[tuple[int, int], List[tuple[int, int]]]</code> <p>(tuple[int, int], Sequence[Tuple[int, int]]):</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>bitstrings</code> <code>list of ndarray</code> <p>list corresponding to each</p> <code>List[NDArray]</code> <p>task in the report. Each element is an ndarray of shape</p> <code>List[NDArray]</code> <p>(nshots, nsites) where nshots is the number of shots for</p> <code>List[NDArray]</code> <p>the task and nsites is the number of sites in the task.</p> Note <p>Note that nshots may vary between tasks if filter_perfect_filling is set to True.</p> Source code in <code>src/bloqade/task/base.py</code> <pre><code>@beartype\ndef bitstrings(\n    self,\n    filter_perfect_filling: bool = True,\n    clusters: Union[tuple[int, int], List[tuple[int, int]]] = [],\n) -&gt; List[NDArray]:\n    \"\"\"Get the bitstrings from the data.\n\n    Args:\n        filter_perfect_filling (bool): whether return will\n        only contain perfect filling shots. Defaults to True.\n        clusters: (tuple[int, int], Sequence[Tuple[int, int]]):\n        cluster index to filter shots from. If none are provided\n        all clusters are used, defaults to [].\n\n    Returns:\n        bitstrings (list of ndarray): list corresponding to each\n        task in the report. Each element is an ndarray of shape\n        (nshots, nsites) where nshots is the number of shots for\n        the task and nsites is the number of sites in the task.\n\n    Note:\n        Note that nshots may vary between tasks if filter_perfect_filling\n        is set to True.\n\n    \"\"\"\n\n    task_numbers = self.dataframe.index.get_level_values(\"task_number\").unique()\n\n    bitstrings = []\n    for task_number in task_numbers:\n        mask = self._filter(\n            task_number=task_number,\n            filter_perfect_filling=filter_perfect_filling,\n            clusters=clusters,\n        )\n        if np.any(mask):\n            bitstrings.append(self.dataframe.loc[mask].to_numpy())\n        else:\n            bitstrings.append(\n                np.zeros((0, self.dataframe.shape[1]), dtype=np.uint8)\n            )\n\n    return bitstrings\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.counts","title":"counts","text":"<pre><code>counts(filter_perfect_filling=True, clusters=[])\n</code></pre> <p>Get the counts of unique bit strings.</p> <p>Parameters:</p> Name Type Description Default <code>filter_perfect_filling</code> <code>bool</code> <p>whether return will</p> <code>True</code> <code>clusters</code> <code>Union[tuple[int, int], List[tuple[int, int]]]</code> <p>(tuple[int, int], Sequence[Tuple[int, int]]):</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>bitstrings</code> <code>list of ndarray</code> <p>list corresponding to each</p> <code>List[OrderedDict[str, int]]</code> <p>task in the report. Each element is an ndarray of shape</p> <code>List[OrderedDict[str, int]]</code> <p>(nshots, nsites) where nshots is the number of shots for</p> <code>List[OrderedDict[str, int]]</code> <p>the task and nsites is the number of sites in the task.</p> Note <p>Note that nshots may vary between tasks if filter_perfect_filling is set to True.</p> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def counts(\n    self,\n    filter_perfect_filling: bool = True,\n    clusters: Union[tuple[int, int], List[tuple[int, int]]] = [],\n) -&gt; List[OrderedDict[str, int]]:\n    \"\"\"Get the counts of unique bit strings.\n\n    Args:\n        filter_perfect_filling (bool): whether return will\n        only contain perfect filling shots. Defaults to True.\n        clusters: (tuple[int, int], Sequence[Tuple[int, int]]):\n        cluster index to filter shots from. If none are provided\n        all clusters are used, defaults to [].\n\n    Returns:\n        bitstrings (list of ndarray): list corresponding to each\n        task in the report. Each element is an ndarray of shape\n        (nshots, nsites) where nshots is the number of shots for\n        the task and nsites is the number of sites in the task.\n\n    Note:\n        Note that nshots may vary between tasks if filter_perfect_filling\n        is set to True.\n\n    \"\"\"\n\n    def generate_counts(bitstring):\n        output = np.unique(bitstring, axis=0, return_counts=True)\n\n        count_list = [\n            (\"\".join(map(str, bitstring)), int(count))\n            for bitstring, count in zip(*output)\n        ]\n        count_list.sort(key=lambda x: x[1], reverse=True)\n        count = OrderedDict(count_list)\n\n        return count\n\n    return list(\n        map(generate_counts, self.bitstrings(filter_perfect_filling, clusters))\n    )\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.list_param","title":"list_param","text":"<pre><code>list_param(field_name)\n</code></pre> <p>List the parameters associate with the given variable field_name for each tasks.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>variable name</p> required Source code in <code>src/bloqade/task/base.py</code> <pre><code>def list_param(self, field_name: str) -&gt; List[Union[Number, None]]:\n    \"\"\"\n    List the parameters associate with the given variable field_name\n    for each tasks.\n\n    Args:\n        field_name (str): variable name\n\n    \"\"\"\n\n    def cast(x):\n        if x is None:\n            return None\n        elif isinstance(x, (list, tuple, np.ndarray)):\n            return list(map(cast, x))\n        else:\n            return float(x)\n\n    return list(map(cast, (meta.get(field_name) for meta in self.metas)))\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.rydberg_densities","title":"rydberg_densities","text":"<pre><code>rydberg_densities(filter_perfect_filling=True, clusters=[])\n</code></pre> <p>Get rydberg density for each task.</p> <p>Parameters:</p> Name Type Description Default <code>filter_perfect_filling</code> <code>bool</code> <p>whether return will</p> <code>True</code> Return <p>per-site rydberg density for each task as a pandas DataFrame or Series.</p> Source code in <code>src/bloqade/task/base.py</code> <pre><code>@beartype\ndef rydberg_densities(\n    self,\n    filter_perfect_filling: bool = True,\n    clusters: Union[tuple[int, int], List[tuple[int, int]]] = [],\n) -&gt; Union[pd.Series, pd.DataFrame]:\n    \"\"\"Get rydberg density for each task.\n\n    Args:\n        filter_perfect_filling (bool, optional): whether return will\n        only contain perfect filling shots. Defaults to True.\n\n    Return:\n        per-site rydberg density for each task as a pandas DataFrame or Series.\n\n    \"\"\"\n    mask = self._filter(\n        filter_perfect_filling=filter_perfect_filling, clusters=clusters\n    )\n    df = self.dataframe[mask]\n    return 1 - (df.groupby(\"task_number\").mean())\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Interactive Visualization of the Report</p> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def show(self):\n    \"\"\"\n    Interactive Visualization of the Report\n\n    \"\"\"\n    display_report(self)\n</code></pre>"},{"location":"reference/bloqade/task/batch/","title":"Batch","text":""},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.Filter","title":"Filter","text":""},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.Filter.filter_metadata","title":"filter_metadata","text":"<pre><code>filter_metadata(__match_any__=False, **metadata)\n</code></pre> <p>Create a Batch object that has tasks filtered based on the values of metadata.</p> <p>Parameters:</p> Name Type Description Default <code>__match_any__</code> <code>bool</code> <p>if True, then a task will be included if it matches any of the metadata filters. If False, then a task will be included only if it matches all of the metadata filters. Defaults to False.</p> <code>False</code> <code>**metadata</code> <code>MetadataFilterType</code> <p>the metadata to filter on. The keys are the metadata names and the values (as a set) are the values to filter on. The elements in the set can be Real, Decimal, Tuple[Real], or Tuple[Decimal].</p> <code>{}</code> Return <p>type(self): a Batch object with the filtered tasks, either     LocalBatch or RemoteBatch depending on the type of self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef filter_metadata(\n    self, __match_any__: bool = False, **metadata: MetadataFilterType\n) -&gt; Union[\"LocalBatch\", \"RemoteBatch\"]:\n    \"\"\"Create a Batch object that has tasks filtered based on the\n    values of metadata.\n\n    Args:\n        __match_any__: if True, then a task will be included if it\n            matches any of the metadata filters. If False, then a\n            task will be included only if it matches all of the\n            metadata filters. Defaults to False.\n\n        **metadata: the metadata to filter on. The keys are the metadata\n            names and the values (as a set) are the values to filter on.\n            The elements in the set can be Real, Decimal, Tuple[Real], or\n            Tuple[Decimal].\n\n    Return:\n        type(self): a Batch object with the filtered tasks, either\n            LocalBatch or RemoteBatch depending on the type of self\n\n    \"\"\"\n\n    def convert_to_decimal(element):\n        if isinstance(element, list):\n            return list(map(convert_to_decimal, element))\n        elif isinstance(element, (Real, Decimal)):\n            return Decimal(str(element))\n        else:\n            raise ValueError(\n                f\"Invalid value {element} for metadata filter. \"\n                \"Only Real, Decimal, List[Real], and List[Decimal] \"\n                \"are supported.\"\n            )\n\n    def metadata_match_all(task):\n        return all(\n            task.metadata.get(key) in value for key, value in metadata.items()\n        )\n\n    def metadata_match_any(task):\n        return any(\n            task.metadata.get(key) in value for key, value in metadata.items()\n        )\n\n    metadata = {k: list(map(convert_to_decimal, v)) for k, v in metadata.items()}\n\n    metadata_filter = metadata_match_any if __match_any__ else metadata_match_all\n\n    new_tasks = OrderedDict(\n        [(k, v) for k, v in self.tasks.items() if metadata_filter(v)]\n    )\n\n    kw = dict(self.__dict__)\n    kw[\"tasks\"] = new_tasks\n\n    return self.__class__(**kw)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.LocalBatch","title":"LocalBatch  <code>dataclass</code>","text":"<p>             Bases: <code>Serializable</code>, <code>Filter</code></p>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.LocalBatch.report","title":"report","text":"<pre><code>report()\n</code></pre> <p>Generate analysis report base on currently completed tasks in the LocalBatch.</p> Return <p>Report</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def report(self) -&gt; Report:\n    \"\"\"\n    Generate analysis report base on currently\n    completed tasks in the LocalBatch.\n\n    Return:\n        Report\n\n    \"\"\"\n\n    ## this potentially can be specialize/disatch\n    ## offline\n    index = []\n    data = []\n    metas = []\n    geos = []\n\n    for task_number, task in self.tasks.items():\n        geometry = task.geometry\n        perfect_sorting = \"\".join(map(str, geometry.filling))\n        parallel_decoder = geometry.parallel_decoder\n\n        if parallel_decoder:\n            cluster_indices = parallel_decoder.get_cluster_indices()\n        else:\n            cluster_indices = {(0, 0): list(range(len(perfect_sorting)))}\n\n        shot_iter = filter(\n            lambda shot: shot.shot_status == QuEraShotStatusCode.Completed,\n            task.result().shot_outputs,\n        )\n\n        for shot, (cluster_coordinate, cluster_index) in product(\n            shot_iter, cluster_indices.items()\n        ):\n            pre_sequence = \"\".join(\n                map(\n                    str,\n                    (shot.pre_sequence[index] for index in cluster_index),\n                )\n            )\n\n            post_sequence = np.asarray(\n                [shot.post_sequence[index] for index in cluster_index],\n                dtype=np.int8,\n            )\n\n            pfc_sorting = \"\".join(\n                [perfect_sorting[index] for index in cluster_index]\n            )\n\n            key = (\n                task_number,\n                cluster_coordinate,\n                pfc_sorting,\n                pre_sequence,\n            )\n\n            index.append(key)\n            data.append(post_sequence)\n\n        metas.append(task.metadata)\n        geos.append(task.geometry)\n\n    index = pd.MultiIndex.from_tuples(\n        index, names=[\"task_number\", \"cluster\", \"perfect_sorting\", \"pre_sequence\"]\n    )\n\n    df = pd.DataFrame(data, index=index)\n    df.sort_index(axis=\"index\")\n\n    rept = None\n    if self.name is None:\n        rept = Report(df, metas, geos, \"Local\")\n    else:\n        rept = Report(df, metas, geos, self.name)\n\n    return rept\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.LocalBatch.rerun","title":"rerun","text":"<pre><code>rerun(multiprocessing=False, num_workers=None, **kwargs)\n</code></pre> <p>Rerun all the tasks in the LocalBatch.</p> Return <p>Report</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef rerun(\n    self, multiprocessing: bool = False, num_workers: Optional[int] = None, **kwargs\n):\n    \"\"\"\n    Rerun all the tasks in the LocalBatch.\n\n    Return:\n        Report\n\n    \"\"\"\n\n    return self._run(\n        multiprocessing=multiprocessing, num_workers=num_workers, **kwargs\n    )\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch","title":"RemoteBatch  <code>dataclass</code>","text":"<p>             Bases: <code>Serializable</code>, <code>Filter</code></p>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.total_nshots","title":"total_nshots  <code>property</code>","text":"<pre><code>total_nshots\n</code></pre> <p>Total number of shots of all tasks in the RemoteBatch</p> Return <p>number of shots</p>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.cancel","title":"cancel","text":"<pre><code>cancel()\n</code></pre> <p>Cancel all the tasks in the Batch.</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def cancel(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Cancel all the tasks in the Batch.\n\n    Return:\n        self\n\n    \"\"\"\n    # cancel all jobs\n    for task in self.tasks.values():\n        task.cancel()\n\n    return self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.fetch","title":"fetch","text":"<pre><code>fetch()\n</code></pre> <p>Fetch the tasks in the Batch.</p> Note <p>Fetching will update the status of tasks, and only pull the results for those tasks that have completed.</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def fetch(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Fetch the tasks in the Batch.\n\n    Note:\n        Fetching will update the status of tasks,\n        and only pull the results for those tasks\n        that have completed.\n\n    Return:\n        self\n\n    \"\"\"\n    # online, non-blocking\n    # pull the results only when its ready\n    for task in self.tasks.values():\n        task.fetch()\n\n    return self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_completed_tasks","title":"get_completed_tasks","text":"<pre><code>get_completed_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain completed tasks from current Batch.</p> <p>Tasks consider completed with following status codes:</p> <ol> <li>Completed</li> <li>Partial</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def get_completed_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain completed tasks from current Batch.\n\n    Tasks consider completed with following status codes:\n\n    1. Completed\n    2. Partial\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    statuses = [\n        \"Completed\",\n        \"Partial\",\n    ]\n    return self.get_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_failed_tasks","title":"get_failed_tasks","text":"<pre><code>get_failed_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain failed tasks from current Batch.</p> <p>failed tasks with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def get_failed_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain failed tasks from current Batch.\n\n    failed tasks with following status codes:\n\n    1. Failed\n    2. Unaccepted\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # statuses that are in a state that are\n    # completed because of an error\n    statuses = [\"Failed\", \"Unaccepted\"]\n    return self.get_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_finished_tasks","title":"get_finished_tasks","text":"<pre><code>get_finished_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain finished tasks from current Batch.</p> <p>Tasks consider finished with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> <li>Completed</li> <li>Partial</li> <li>Cancelled</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def get_finished_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain finished tasks from current Batch.\n\n    Tasks consider finished with following status codes:\n\n    1. Failed\n    2. Unaccepted\n    3. Completed\n    4. Partial\n    5. Cancelled\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # statuses that are in a state that will\n    # not run going forward for any reason\n    statuses = [\"Completed\", \"Failed\", \"Unaccepted\", \"Partial\", \"Cancelled\"]\n    return self.get_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_tasks","title":"get_tasks","text":"<pre><code>get_tasks(*status_codes)\n</code></pre> <p>Get Tasks with specify status_codes.</p> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef get_tasks(self, *status_codes: str) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Get Tasks with specify status_codes.\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # offline:\n    st_codes = [QuEraTaskStatusCode(x) for x in status_codes]\n\n    new_task_results = OrderedDict()\n    for task_number, task in self.tasks.items():\n        if task.task_result_ir.task_status in st_codes:\n            new_task_results[task_number] = task\n\n    return RemoteBatch(self.source, new_task_results, name=self.name)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.pull","title":"pull","text":"<pre><code>pull()\n</code></pre> <p>Pull results of the tasks in the Batch.</p> Note <p>Pulling will pull the results for the tasks. If a given task(s) has not been completed, wait until it finished.</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def pull(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Pull results of the tasks in the Batch.\n\n    Note:\n        Pulling will pull the results for the tasks.\n        If a given task(s) has not been completed, wait\n        until it finished.\n\n    Return:\n        self\n    \"\"\"\n    # online, blocking\n    # pull the results. if its not ready, hanging\n    for task in self.tasks.values():\n        task.pull()\n\n    return self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.remove_failed_tasks","title":"remove_failed_tasks","text":"<pre><code>remove_failed_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain tasks from current Batch, with failed tasks removed.</p> <p>failed tasks with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def remove_failed_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain tasks from current Batch,\n    with failed tasks removed.\n\n    failed tasks with following status codes:\n\n    1. Failed\n    2. Unaccepted\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # statuses that are in a state that will\n    # not run going forward because of an error\n    statuses = [\"Failed\", \"Unaccepted\"]\n    return self.remove_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.remove_invalid_tasks","title":"remove_invalid_tasks","text":"<pre><code>remove_invalid_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain tasks from current Batch, with all Unaccepted tasks removed.</p> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def remove_invalid_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain tasks from current Batch,\n    with all Unaccepted tasks removed.\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    return self.remove_tasks(\"Unaccepted\")\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.remove_tasks","title":"remove_tasks","text":"<pre><code>remove_tasks(*status_codes)\n</code></pre> <p>Remove Tasks with specify status_codes.</p> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef remove_tasks(self, *status_codes: str) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Remove Tasks with specify status_codes.\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # offline:\n\n    st_codes = [QuEraTaskStatusCode(x) for x in status_codes]\n\n    new_results = OrderedDict()\n    for task_number, task in self.tasks.items():\n        if task.task_result_ir.task_status in st_codes:\n            continue\n\n        new_results[task_number] = task\n\n    return RemoteBatch(self.source, new_results, self.name)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.report","title":"report","text":"<pre><code>report()\n</code></pre> <p>Generate analysis report base on currently completed tasks in the RemoteBatch.</p> Return <p>Report</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def report(self) -&gt; \"Report\":\n    \"\"\"\n    Generate analysis report base on currently\n    completed tasks in the RemoteBatch.\n\n    Return:\n        Report\n\n    \"\"\"\n    ## this potentially can be specialize/disatch\n    ## offline\n    index = []\n    data = []\n    metas = []\n    geos = []\n\n    for task_number, task in self.tasks.items():\n        ## fliter not existing results tasks:\n        if (task.task_id is None) or (not task._result_exists()):\n            continue\n\n        ## filter has result but is not correctly completed.\n        if task.task_result_ir.task_status not in [\n            QuEraTaskStatusCode.Completed,\n            QuEraTaskStatusCode.Partial,\n        ]:\n            continue\n\n        geometry = task.geometry\n        perfect_sorting = \"\".join(map(str, geometry.filling))\n        parallel_decoder = geometry.parallel_decoder\n\n        if parallel_decoder:\n            cluster_indices = parallel_decoder.get_cluster_indices()\n        else:\n            cluster_indices = {(0, 0): list(range(len(perfect_sorting)))}\n\n        shot_iter = filter(\n            lambda shot: shot.shot_status == QuEraShotStatusCode.Completed,\n            task.result().shot_outputs,\n        )\n\n        for shot, (cluster_coordinate, cluster_index) in product(\n            shot_iter, cluster_indices.items()\n        ):\n            pre_sequence = \"\".join(\n                map(\n                    str,\n                    (shot.pre_sequence[index] for index in cluster_index),\n                )\n            )\n\n            post_sequence = np.asarray(\n                [shot.post_sequence[index] for index in cluster_index],\n                dtype=np.int8,\n            )\n\n            pfc_sorting = \"\".join(\n                [perfect_sorting[index] for index in cluster_index]\n            )\n\n            key = (\n                task_number,\n                cluster_coordinate,\n                pfc_sorting,\n                pre_sequence,\n            )\n\n            index.append(key)\n            data.append(post_sequence)\n\n        metas.append(task.metadata)\n        geos.append(task.geometry)\n\n    index = pd.MultiIndex.from_tuples(\n        index, names=[\"task_number\", \"cluster\", \"perfect_sorting\", \"pre_sequence\"]\n    )\n\n    df = pd.DataFrame(data, index=index)\n    df.sort_index(axis=\"index\")\n\n    rept = None\n    if self.name is None:\n        rept = Report(df, metas, geos, \"Remote\")\n    else:\n        rept = Report(df, metas, geos, self.name)\n\n    return rept\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.resubmit","title":"resubmit","text":"<pre><code>resubmit(shuffle_submit_order=True)\n</code></pre> <p>Resubmit all the tasks in the RemoteBatch</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef resubmit(self, shuffle_submit_order: bool = True) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Resubmit all the tasks in the RemoteBatch\n\n    Return:\n        self\n\n    \"\"\"\n    # online, non-blocking\n    self._submit(shuffle_submit_order, force=True)\n    return self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.retrieve","title":"retrieve","text":"<pre><code>retrieve()\n</code></pre> <p>Retrieve missing task results.</p> Note <p>Retrieve will update the status of tasks, and only pull the results for those tasks that have completed.</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def retrieve(self) -&gt; \"RemoteBatch\":\n    \"\"\"Retrieve missing task results.\n\n    Note:\n        Retrieve will update the status of tasks,\n        and only pull the results for those tasks\n        that have completed.\n\n    Return:\n        self\n\n    \"\"\"\n    # partially online, sometimes blocking\n    # pull the results for tasks that have\n    # not been pulled already.\n    for task in self.tasks.values():\n        if not task._result_exists():\n            task.pull()\n\n    return self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.tasks_metric","title":"tasks_metric","text":"<pre><code>tasks_metric()\n</code></pre> <p>Get current tasks status metric</p> Return <p>dataframe with [\"task id\", \"status\", \"shots\"]</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def tasks_metric(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Get current tasks status metric\n\n    Return:\n        dataframe with [\"task id\", \"status\", \"shots\"]\n\n    \"\"\"\n    # [TODO] more info on current status\n    # offline, non-blocking\n    tid = []\n    data = []\n    for int, task in self.tasks.items():\n        tid.append(int)\n\n        dat = [None, None, None]\n        dat[0] = task.task_id\n        if task.task_result_ir is not None:\n            dat[1] = task.task_result_ir.task_status.name\n        dat[2] = task.task_ir.nshots\n        data.append(dat)\n\n    return pd.DataFrame(data, index=tid, columns=[\"task ID\", \"status\", \"shots\"])\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.Serializable","title":"Serializable","text":""},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.Serializable.json","title":"json","text":"<pre><code>json(**options)\n</code></pre> <p>Serialize the object to JSON string.</p> Return <p>JSON string</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def json(self, **options) -&gt; str:\n    \"\"\"\n    Serialize the object to JSON string.\n\n    Return:\n        JSON string\n\n    \"\"\"\n    from bloqade import dumps\n\n    return dumps(self, **options)\n</code></pre>"},{"location":"reference/bloqade/task/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade/task/braket/","title":"Braket","text":""},{"location":"reference/bloqade/task/braket_simulator/","title":"Braket simulator","text":""},{"location":"reference/bloqade/task/quera/","title":"Quera","text":""}]}
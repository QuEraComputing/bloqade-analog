{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Bloqade -- QuEra's Neutral Atom SDK","text":""},{"location":"#what-is-bloqade","title":"What is Bloqade?","text":"<p>Bloqade is an SDK designed to be a simple, easy-to-use interface for writing, submitting, and analyzing results of analog quantum programs on QuEra's neutral atom quantum computers. Currently, QuEra's hardware is on Amazon Braket, the primary method of accessing QuEra's quantum hardware. Over the alpha phase, we plan to expand the emulator capabilities to include a performance Python emulator but also a direct integration with Julia via Bloqade.jl.</p>"},{"location":"#what-does-bloqade-do","title":"What does Bloqade do?","text":"<p>Bloqade is primarily a language for writing analog quantum programs for nuetral atom quantum computers. Our interface is designed to guide our users through the process of defining a analog quantum program as well as different methods to run the program, whether it is on a real quantum computer or a simulator. Bloqade also provides a simple interface for analyzing the results of the program, whether it is a single run or a batch of runs or even some types of hybrid quantum-classical algorithms.</p>"},{"location":"#how-do-i-get-started","title":"How do I get started?","text":"<p>To get started in more detail check out out Getting Started page.</p>"},{"location":"blog/2023/","title":"Bloqade Blog Posts 2023","text":"<p>Sept. 21, 2023 - Introducing Bloqade SDK for Python</p>"},{"location":"blog/2023/posts/bloqade-release/","title":"Introducing Bloqade SDK for Python","text":"<p>Greetings Neutral Atom QC experts, enthusiasts, and newcomers!</p> <p>We are excited to the Rydberg state thrilled to announce the Python version of our cutting-edge SDK, Bloqade. Originally developed in Julia, Bloqade has been a game-changer in the realm of Neutral Atom quantum computing. With the introduction of the Python version, we aim to make this revolutionary technology more accessible and user-friendly than ever before.</p>"},{"location":"blog/2023/posts/bloqade-release/#why-python","title":"Why Python?","text":"<p>Python is one of the most widely used programming languages, especially in the quantum computing community and broader scientific communities. By extending Bloqade to Python, we are opening doors to a broader audience, enabling more developers, researchers, and organizations to harness the power of Neutral Atom quantum computing.</p>"},{"location":"blog/2023/posts/bloqade-release/#neutral-atom-quantum-computing","title":"Neutral Atom Quantum Computing","text":"<p>Recently, the Neutral Atom platform has come on the QC scene in the form of Analog Hamiltonian Simulators that have a broad set of use cases beyond quantum circuits. Ranging from simulating unique quantum phases of matter, solving combinatorical optimization problems, and machine learning applications, the analog mode provides strong values in solving practical, interesting problems in the near term.</p> <p>These advances are crucial milestones on the way towards scalable digital gate-based architecture using atom shuttling. This new technology and its novel applications demand a paradigm shift in the way we not only think about quantum computing, but translate those ideas to real hardware. Enter Bloqade, a next-generation SDK designed to put the power of neutral atoms at your fingertips.</p>"},{"location":"blog/2023/posts/bloqade-release/#why-bloqade","title":"Why Bloqade?","text":"<p>Bloqade is designed with the primary goal of making it easier to compose programs for QuEra\u2019s hardware and analyze results.</p> <p>We've gained valuable insights into how users have used our neutral-atom hardware and with it, their struggles with existing tools. We took advantage of this knowledge to produce a tool that could take the \"hard\" out of \"hardware\". Bloqade is precision-balanced in both flexibility to empower novices to experiment with ease and power to let experts perform cutting-edge work without breaking a sweat.</p>"},{"location":"blog/2023/posts/bloqade-release/#highlights","title":"Highlights","text":""},{"location":"blog/2023/posts/bloqade-release/#smart-documentation","title":"Smart Documentation","text":"<p>With our commitment to enabling more seamless program development, we've put the relevant documentation you need right where and when you need it.</p> <p>No more obnoxious switching between your favorite coding environment and documentation in a separate window. Let Bloqade guide you where you'd like to go:</p> <p></p>"},{"location":"blog/2023/posts/bloqade-release/#fully-parameterized-analog-programs","title":"Fully Parameterized Analog Programs","text":"<p>Parameter sweeps are a common theme of programs for analog quantum computers, where a user would like to observe differences in output results by varying a value or values in their program.</p> <p>You used to have to manually crank out variations of your program with different values and then keep track of all the individual submissions to the emulator and hardware, a mess to keep track of and process the results of afterwards.</p> <p>Bloqade eliminates this with its own support for variables that can later be assigned single values or a whole sequence of values for trivial parameter sweeping. This isn't some feature that's constrained to a certain backend, you can take your program with all its variables and submit it to your choice of emulator or our hardware directly.</p> <pre><code>from bloqade import var\nfrom bloqade.atom_arrangement import Square\nimport numpy as np\nadiabatic_durations = [0.4, 3.2, 0.4]\n# create variables explicitly...\nmax_detuning = var(\"max_detuning\")\n# ...or implicitly inside the program definition.\nadiabatic_program = (\nSquare(3, \"lattice_spacing\")\n.rydberg.rabi.amplitude.uniform.piecewise_linear(\ndurations=adiabatic_durations, values=[0.0, \"max_rabi\", \"max_rabi\", 0.0]\n)\n.detuning.uniform.piecewise_linear(\ndurations=adiabatic_durations,\nvalues=[\n-max_detuning, # scalar variables support direct arithmetic operations\n-max_detuning,\nmax_detuning,\nmax_detuning,\n],\n)\n.assign(max_rabi=15.8, max_detuning=16.33)\n.batch_assign(lattice_spacing=np.arange(4.0, 7.0, 0.5))\n)\n# Launch your program on your choice of Braket or in-house emulator...\nemu_results = adiabatic_program.braket.local_emulator().run(10000)\nfaster_emu_results = adiabatic_program.bloqade.python().run(10000)\n# ...as well as hardware without stress\nhw_results = adiabatic_program.parallelize(24).braket.aquila().run_async(100)\n</code></pre>"},{"location":"blog/2023/posts/bloqade-release/#integrated-visualization-tools","title":"Integrated Visualization Tools","text":"<p>Instantly understand what your programs are doing faster than you can say \"neutral atoms rock!\" with Bloqade's built-in visualization tools:</p> <p></p> <p></p> <p>For your results, no more obnoxious manual compilation of results across different parameters or wrangling them into more useful forms. Get insights of experiment outcomes in the blink of an eye:</p> <p></p> <p></p> <p>Now that's what we call having your cake AND eating it.</p>"},{"location":"blog/2023/posts/bloqade-release/#bloqade-roadmap","title":"Bloqade Roadmap","text":""},{"location":"blog/2023/posts/bloqade-release/#bloqade-alpha-phase","title":"Bloqade Alpha Phase","text":"<p>During the next year, we plan on continuing development of Bloqade's python interface. If you are as excited about Neutral Atom quantum computing as us, or heck, even just quantum physics in general, give Bloqade a try! This is your opportunity to influence the direction of Bloqade and get in on the ground floor of the next Quantum Computing revolution.</p>"},{"location":"blog/2023/posts/bloqade-release/#but-what-about-julia","title":"But what about Julia?","text":"<p>Don't you guys already HAVE an SDK in Julia? Why do you need two SDKs?</p> <p>That's right! However, there's a key motivating factor for the reason we created Bloqade Python that's distinct for Bloqade.jl's existence.</p> <p>Bloqade.jl is primarily geared as a high-performance emulator. It allows you to design complex neutral-atom algorithms that may not necessarily run on our hardware BUT are excellent if you're exploring novel physical phenonema/algorithms or as a tool for pedagogical purposes.</p> <p>Bloqade.jl does have the ability to submit to Aquila, our flagship quantum computer, but for more complex tasks such as sweeping parameters (e.g. running the same program on hardware with slightly different parameters each time) or advanced post-processing, it becomes cumbersome quite quickly.</p> <p>There are no plans to drop support any time soon though. On the contrary, we plan on fully integrating Bloqade.jl into the Python package, which will enable you to program Neutral Atom quantum hardware without having to choose.</p> <p>We very much look forward to you trying out Bloqade!</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to the project! We welcome all contributions. There are many different ways to contribute to Bloqade, and we are always looking for more help. We accept contributions in the form of bug reports, feature requests, documentation improvements, and code contributions. For more information about how to contribute, please read the following sections.</p>"},{"location":"contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Reporting a Bug </li> <li>Documentation Issues</li> <li>Feature Requests</li> <li>Developing Bloqade</li> <li>Community Slack</li> <li>Ask a Question</li> </ul>"},{"location":"contributing/community-slack/","title":"Community Slack","text":"<p>You can join QuEra's Slack workspace with this link. Join the <code>#bloqade</code> channel to discuss anything related to Bloqade.</p>"},{"location":"contributing/developing-bloqade/","title":"Setting up Development Environment","text":"<p>Our development environment contains a set of tools we use for development, testing, and documentation. This section describes how to set up the development environment. We primarily use pdm to manage python environments and dependencies.</p>"},{"location":"contributing/developing-bloqade/#setting-up-python","title":"Setting up Python","text":"<p>We use pdm to manage dependencies and virtual environment. After cloning the repository, run the following command to install dependencies:</p> <pre><code>pdm install\n</code></pre> <p>You can also install different dependency groups:</p> <ul> <li>dev: dependencies for development</li> </ul> <pre><code>pdm install --dev\n# or\npdm install -d\n</code></pre> <ul> <li>doc: dependencies for building documentation</li> </ul> <pre><code>pdm install -G doc\n</code></pre>"},{"location":"contributing/developing-bloqade/#useful-pdm-scripts","title":"Useful PDM scripts","text":""},{"location":"contributing/developing-bloqade/#tests","title":"Tests","text":"<p>You can run tests via</p> <pre><code>pdm run test\n</code></pre> <p>Or run tests and generate coverage via</p> <pre><code>pdm run coverage\n</code></pre> <p>will print out the coverage file level report in terminal.</p> <pre><code>pdm run coverage-html\n</code></pre> <p>This command generates an interactive html report in <code>htmlcov</code> folder. This will show which specific lines are not covered by tests.</p>"},{"location":"contributing/developing-bloqade/#documentation","title":"Documentation","text":"<p>You can build documentation via</p> <pre><code>pdm run doc_build\n</code></pre> <p>Or run a local server to preview documentation via</p> <pre><code>pdm run doc\n</code></pre>"},{"location":"contributing/developing-bloqade/#jupytext","title":"Jupytext","text":"<p>You can sync jupyter notebooks and python scripts via</p> <pre><code>pdm run jupytext\n</code></pre> <p>this will help you development examples in jupyter notebook and python scripts simultaneously.</p>"},{"location":"contributing/developing-bloqade/#lint","title":"Lint","text":"<p>We primarily use ruff - an extremely fast linter for Python, and black as formatter. These have been configured into pre-commit hooks. After installing pre-commit on your own system, you can install pre-commit hooks to git via</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/developing-bloqade/#design-philosophy-and-architecture","title":"Design Philosophy and Architecture","text":"<p>Given the heterogeneous nature of the hardware we target, We have decided to use a compiler-based approach to our software stack, allowing us to target different hardware backends with the same high-level language. Below is a diagram of the software stack in Bloqade.</p> <pre><code>graph TD\n    Builder[\"Builder Representation\"]\n    PythonAST[\"Bloqade AST Python\"]\n    JuliaAST[\"Bloqade AST Julia\"]\n\n    EmulatorPy[\"Emulator IR Python\"]\n    EmulatorJL[\"Emulator IR Julia\"]\n\n    QuEra[\"QuEra IR\"]\n    Braket[\"Braket IR\"]\n    JuliaEmulator[\"Bloqade.jl\"]\n    PythonEmulator[\"Python Emulator\"]\n\n    Aquila[\"Aquila\"]\n\n    Builder --&gt;|parse| PythonAST\n    PythonAST --&gt;|lower| EmulatorPy\n    PythonAST --&gt;|lower| QuEra\n    PythonAST --&gt;|lower| Braket\n    PythonAST --&gt;|transpile| JuliaAST\n\n    QuEra --&gt;|execute| Aquila\n    Braket --&gt;|execute| Aquila\n\n    JuliaAST --&gt;|lower| EmulatorJL\n    EmulatorPy --&gt;|execute| PythonEmulator\n    EmulatorJL --&gt;|execute| JuliaEmulator\n</code></pre>"},{"location":"contributing/developing-bloqade/#high-level-builder-representation","title":"High-Level Builder Representation","text":"<p>When programming Bloqade using the Python API, the user constructs a representation of an analog quantum circuit. This representation is a flattened version of the actual analog circuit. Flattened means that the user input is a linear sequence of operations where the context of neighboring nodes in the sequence of instructions can determine the program tree structure. The Bloqade AST describes the actual analog circuit.</p>"},{"location":"contributing/developing-bloqade/#bloqade-ast","title":"Bloqade AST","text":"<p>The Bloqade AST is a representation of a quantum analog circuit for neutral atom computing. It is a directed acyclic graph (DAG) with nodes for different hierarchical levels of the circuit. The base node is the <code>AnalogCircuit</code> which contains the geometry of the atoms stored as a <code>AtomArragment</code> or <code>ParallelRegister</code> objects. The other part of the circuit is the <code>Sequence</code>, which contains the waveforms that describe the drives for the Ryberg/Hyperfine transitions of each Rydberg atom. Each transition is represented by a <code>Pulse</code> including a <code>Field</code> for the drive's detuning, Rabi amplitude, and Rabi phase . A <code>Field</code> relates the spatial and temporal dependence of a drive. The spatial modulates the temporal dependence of the waveform. A DAG also describes the <code>Waveform</code> object. Finally, we have basic <code>Scalar</code> expressions as well for describing the syntax of real-valued continuous numbers.</p>"},{"location":"contributing/developing-bloqade/#bloqade-compilers-and-transpilers","title":"Bloqade Compilers and Transpilers","text":"<p>Given a user program expressed as the Bloqade AST, we can target various backends by transforming from the Bloqade AST to other kinds of IR. For example, when submitting a task to QuEra's hardware, we transform the Bloqade AST to the IR that describes a valid program for the hardware.</p> <p>This process is referred to as <code>lowering</code>, which in a general sense is a transformation that takes you from one IR to another where the target IR is specialized or has a smaller syntactical structure. <code>Transpiling</code> corresponds to a transformation that takes you from one language to equivalent expressions in another. For example, we can transpile from the Bloqade AST in Python to the Bloqade AST in Julia. The generic term for both of these types of transformation in Bloqade is Code Generation. You will find various code generation implementations in various <code>codegen</code> modules.</p>"},{"location":"contributing/documentation-issues/","title":"Reporting a Documentation Issue","text":"<p>We are always looking to improve our documentation. If you find a typo or think something is unclear, please open an issue on our GitHub page: https://github.com/QuEraComputing/bloqade-python/issues</p> <p>For typos or other minor problems, create an issue that contains a link to the specific page that includes the problem, along with a description of the problem and possibly a solution.</p> <p>For a request for new documentation content, please open up an issue and describe what you think is missing from the documentation.</p>"},{"location":"contributing/feature-requests/","title":"Requesting new Features","text":"<p>Given that we are currently at the beginning of the development of the Bloqade python interface, we are open to suggestions about what features would be helpful to include in future package iterations. If you have a request for a new feature, please open an issue on our GitHub page: https://github.com/QuEraComputing/bloqade-python/issues</p> <p>We ask that the feature requests be as specific as possible. Please include the following information in your feature request:</p> <ol> <li> <p>A short, descriptive title.</p> </li> <li> <p>A detailed description of the feature, including your attempt to solve the problem with the current version of Bloqade.</p> </li> <li> <p>A minimal code example that demonstrates the need for the feature.</p> </li> <li> <p>The version of Bloqade you are using.</p> </li> <li> <p>The version of Python you are using.</p> </li> <li> <p>The version of your operating system.</p> </li> </ol>"},{"location":"contributing/reporting-a-bug/","title":"Reporting a Bug","text":"<p>Bloqade is currently in the alpha phase of development, meaning bugs most likely exist in the current implementation. We are continuously striving to improve the stability of Bloqade. As such, we encourage our users to report all bugs they find. To do this, we ask you to submit an issue to our GitHub page: https://github.com/QuEraComputing/bloqade-python/issues</p> <p>Please include the following information in your bug report:</p> <ol> <li> <p>A short, descriptive title.</p> </li> <li> <p>A detailed description of the bug, including the expected behavior and what happened.</p> </li> <li> <p>A minimal code example that reproduces the bug.</p> </li> <li> <p>The version of Bloqade you are using.</p> </li> <li> <p>The version of Python you are using.</p> </li> <li> <p>The version of your operating system.</p> </li> </ol>"},{"location":"getting_started/","title":"Getting Started","text":"<ul> <li>Installation</li> <li>Usage and Philosophy</li> </ul>"},{"location":"getting_started/installation/","title":"Installation","text":"<p>You can install the latest version of Bloqade using pip:</p> <pre><code>pip install bloqade\n</code></pre>"},{"location":"getting_started/philosophy/","title":"Usage","text":"<p>In bloqade we use the <code>.</code> to separate the different parts of your quantum program. The most basic starting point for your program will be the <code>bloqade.start</code> object.</p> <pre><code>from bloqade import start\ncalculation = (\nstart\n)\n</code></pre> <p>From here there will be different methods and properties that you can use to build your program. For example, you can start to add atom sites to your program by selecting <code>add_position</code> method.</p> <pre><code>from bloqade import start\ncalculation = (\nstart\n.add_position((0, 0))\n.add_position((0, 6.8))\n.add_position([(6.8, 0), (6.8, 6.8)])\n)\n</code></pre> <p>If you want to start to build the Rydberg drive you can select the <code>rydberg</code> property.</p> <p><pre><code>from bloqade import start\ncalculation = (\nstart\n.add_position((0, 0))\n.add_position((0, 6.8))\n.add_position([(6.8, 0), (6.8, 6.8)])\n.rydberg\n)\n</code></pre> Note that from here on out, you can no longer add to your geometry as the <code>rydberg</code> property is terminal.</p> <p>From here, you can select the different parts of the Rydberg drive. For example, if you want to build the detuning part of the drive, you can choose the <code>detuning</code> property.</p> <pre><code>from bloqade import start\ncalculation = (\nstart\n.add_position((0, 0))\n.add_position((0, 6.8))\n.add_position([(6.8, 0), (6.8, 6.8)])\n.rydberg.detuning\n)\n</code></pre> <p>In the code above, <code>rydberg.detuning</code> indicates that the following set of methods and properties will be related to the Detuning of the Rydberg drive. You can also select <code>rabi.amplitude</code> or <code>rabi.phase</code> To build the amplitude and phase parts of the drive. Next, we will select the spatial modulation of the driving field.</p> <pre><code>from bloqade import start\ncalculation = (\nstart\n.add_position((0, 0))\n.add_position((0, 6.8))\n.add_position([(6.8, 0), (6.8, 6.8)])\n.rydberg.detuning.uniform\n)\n</code></pre> <p>Here, we selected the <code>uniform</code> property, indicating that the detuning will be uniform across the atoms. You can also select <code>var(name)</code> where <code>name</code> is the name of the variable defined using a string. Having variables will allow you to define a spatially varying detuning as a list of real numbers. You can also select individual atoms using the <code>location(index)</code> method, where <code>index</code> is the integer associated with the lattice. Now that we have the drive's spatial modulation, we can start to build the time dependence of the detuning field. Continuing with the example, we can add individual segments to the time function using <code>linear</code> or <code>constant</code> methods, or we have shortcuts to common waveforms like <code>piecewise_linear</code> or <code>piecewise_constant</code>. We use a piecewise linear function to define the Detuning waveform on Aquila.</p> <pre><code>from bloqade import start\ncalculation = (\nstart\n.add_position((0, 0))\n.add_position((0, 6.8))\n.add_position([(6.8, 0), (6.8, 6.8)])\n.rydberg.detuning.uniform.\npiecewise_linear(\ndurations = [0.1, 1.0 0.1],\nvalues = [-10, -10, 10, 10]\n)\n)\n</code></pre> <p>One can continue using the <code>.</code> to append more time-dependent segments to the uniform detuning waveform or select a different spatial modulation of the detuning field. The results will be that the new spatial modulation will be added to the existing spatial modulation. You can also start to build another field within the Rydberg drive by selecting the <code>amplitude</code> or <code>phase</code> properties.</p> <pre><code>from bloqade import start\ncalculation = (\nstart\n.add_position((0, 0))\n.add_position((0, 6.8))\n.add_position([(6.8, 0), (6.8, 6.8)])\n.rydberg.detuning.uniform.\npiecewise_linear(\ndurations = [0.1, 1.0 0.1],\nvalues = [-10, -10, 10, 10]\n)\n.amplitude.uniform.\npiecewise_linear(\ndurations = [0.1, 1.0 0.1],\nvalues = [0, 10, 10, 0]\n)\n)\n</code></pre> <p>If the next property is: 1. <code>hyperfine</code> will start to build the Hyperfine driving transition 2. <code>amplitude</code> or <code>rabi.amplitude</code> will start to build the rabi amplitude in the current context, e.g. rydberg 3. <code>phase</code> or <code>rabi.phase</code> will start to build the rabi phase in the current context 4. A spatial modulation will add a new channel to the current field, e.g. detuning 5. Repeating the previously specified spatial modulations will add that waveform with the previously defined waveform in that spatial modulation.</p> <pre><code>from bloqade import start\ncalculation = (\nstart\n.add_position((0, 0))\n.add_position((0, 6.8))\n.add_position([(6.8, 0), (6.8, 6.8)])\n.rydberg.detuning.uniform.\npiecewise_linear(\ndurations = [0.1, 1.0 0.1],\nvalues = [-10, -10, \"final_detuning\", \"final_detuning\"]\n)\n.amplitude.uniform.\npiecewise_linear(\ndurations = [0.1, 1.0 0.1],\nvalues = [0, 10, 10, 0]\n)\n)\n</code></pre> <p>A string can parameterize continuous values inside the program we call these run-time parameters. There are three ways to specify the value for these parameters; the first is to set the value via <code>assign</code>, which means that the variable will have the same assignment regardless of the run. The second is to specify the value via <code>batch_assign</code>, which assigns that parameter to a batch. When specifying a batch, the program will automatically execute a quantum teach for each parameter in the batch. The other method to define the variable is through <code>flatten</code>. This instruction will delay the specification of the variable till running/submitting the tasks, which is helpful for certain kinds of hybrid quantum-classical applications. Combined with the callable nature of the backends, it will make it very easy to create a quantum-classical loop. You can mix and match some of these methods, and the available options should pop up if you're using an IDE.</p> <p>Another helpful feature for small clusters of atoms is the <code>parallelize</code> option. The idea here is that the atoms are arranged in 2D space in some bounded square region for Aquila and other Neutral Atom machines. You can run multiple copies of that calculation in parallel for small clusters of atoms by spacing those clusters apart by some sufficiently large distance. Our infrastructure will automatically detect the area of the QPU and use that to generate the appropriate number of copies of the calculation. Also, when processing the results, it is possible to automatically stitch the results from the different copies together so that the analysis is unified on the original cluster.</p> <p>Now that we have specified all the options, we can think about how to run our program. We only support <code>braket</code>, which tells bloqade to submit your tasks to the braket service. The credentials are handled entirely by the braket SDK, so we suggest you look at their documentation for how to set that up. However, setting up your AWS credentials in your environment variables is the easiest way. To execute the program on Aquila, you select the <code>aquila</code> backend after the <code>braket</code> property.</p> <p><pre><code>from bloqade import start\ncalculation = (\nstart\n.add_position((0, 0))\n.add_position((0, 6.8))\n.add_position([(6.8, 0), (6.8, 6.8)])\n.rydberg.detuning.uniform.\npiecewise_linear(\ndurations = [0.1, 1.0 0.1],\nvalues = [-10, -10, \"final_detuning\", \"final_detuning\"]\n)\n.amplitude.uniform.\npiecewise_linear(\ndurations = [0.1, 1.0 0.1],\nvalues = [0, 10, 10, 0]\n)\n.batch_assign(detuning_final=[0,1,2,3,4])\n.braket.aquila()\n)\n</code></pre> For tasks executed through a remote API, there are three options to run your job. The first is an asynchronous call via <code>submit</code>, which will return a <code>RemoteBatch</code> object. This object has various methods to <code>fetch</code> and or <code>pull</code> results from the remote API, along with some other tools that can query the status of the task(s) in this batch. <code>run</code> is another method that blocks the script waiting for all the tasks to finish, susequently returning the <code>RemoteBatch</code>. The final option is to use the <code>__call__</code> method of the <code>calculation</code> object for hybrid workflows. The call object is effectively the same as calling <code>run</code>. However, specifying the <code>flatten</code> option will allow you to call <code>__call__</code> with arguments corresponding to the list of strings provided by <code>flatten</code>.</p> <p>The <code>RemoteBatch</code> object can be saved in JSON format using the <code>save_batch</code> and reloaded back into Python using the <code>load_batch</code> functions. This capability is useful for the asynchronous case, where you can save the batch and load it back later to retrieve the results.</p> <p>The braket service also provides a local emulator, which can be run by selecting the <code>local_emulator()</code> options after the <code>braket</code> property. There is no asynchronous option for local emulator jobs, so you can only call <code>run</code> or <code>__call__</code> methods, and the return result is a <code>LocalBatch</code>.</p> <p>The batch objects also have a method <code>report</code> that returns a <code>Report</code> object. This object will contain all the data inside the batch object, so if no results are present in the <code>RemoteBatch</code>, then the <code>Report</code> will not have any data either. A common pattern would be first to call <code>fetch</code> and then create the <code>Report</code> by calling <code>report</code>. That way, the generated report will have the most up-to-date results. Similarly, if you are willing to wait, you can call <code>pull</code>, which will block until all tasks have stopped running.</p> <p>Here is what a final calculation might look like for running a parameter scan and comparing hardware to a classical emulator:</p> <pre><code>from bloqade import start, save_batch\nprogram = (\nstart\n.add_position((0, 0))\n.add_position((0, 6.8))\n.add_position([(6.8, 0), (6.8, 6.8)])\n.rydberg.detuning.uniform.\npiecewise_linear(\ndurations = [0.1, 1.0, 0.1],\nvalues = [-10, -10, \"final_detuning\", \"final_detuning\"]\n)\n.amplitude.uniform.\npiecewise_linear(\ndurations = [0.1, 1.0, 0.1],\nvalues = [0, 10, 10, 0]\n)\n.batch_assign(detuning_final=[0,1,2,3,4])\n)\nemulator_batch = program.braket.local_emulator().run(1000)\nhardware_batch = program.parallelize(20).braket.aquila().submit(1000)\nsave_batch(\"emulator_results.json\", emulator_batch)\nsave_batch(\"hardware_results.json\", hardware_batch)\n# Analysis script\nfrom bloqade import load_batch\nemulator_batch = load_batch(\"emulator_results.json\")\nhardware_batch = load_batch(\"hardware_results.json\")\nemulator_batch.report().show()\nhardware_batch.fetch().report().show()\n</code></pre> <p>An excellent place to start for examples is the Aquila whitepaper examples bound here. Also, a flow diagram can be found here that discusses the entire build process.</p>"},{"location":"reference/bloqade/","title":"Index","text":""},{"location":"reference/bloqade/#bloqade.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <ul> <li>Program starting node</li> <li> <p>Possible Next  <p>-&gt; <code>start.rydberg</code>     :: address rydberg level coupling</p> <p>-&gt; <code>start.hyperfine</code>     :: address hyperfine level coupling</p> <li> <p>Possible Next  <p>-&gt; <code>start.add_locations(List[Tuple[int]])</code>     :: add multiple atoms to current register</p> <p>-&gt; <code>start.add_location(Tuple[int])</code>     :: add atom to current register</p>"},{"location":"reference/bloqade/#bloqade.Literal","title":"Literal","text":"<p>             Bases: <code>Real</code></p>"},{"location":"reference/bloqade/#bloqade.Literal.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre> <p>Scalar Literal, which stores a decimaal value instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>decimal value instance</p> required"},{"location":"reference/bloqade/#bloqade.Variable","title":"Variable","text":"<p>             Bases: <code>Real</code></p> <p>Variable, which stores a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>variable instance.</p> required"},{"location":"reference/bloqade/#bloqade.cast","title":"cast","text":"<pre><code>cast(py)\n</code></pre> <ol> <li> <p>cast Real number (or list/tuple of Real numbers) to <code>Scalar Literal</code>.</p> </li> <li> <p>cast str (or list/tuple of Real numbers) to <code>Scalar Variable</code>.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, Real, Tuple[Real], List[Real]]</code> <p>python object to cast</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>Scalar</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def cast(py) -&gt; \"Scalar\":\n\"\"\"\n    1. cast Real number (or list/tuple of Real numbers)\n    to [`Scalar Literal`][bloqade.ir.scalar.Literal].\n    2. cast str (or list/tuple of Real numbers)\n    to [`Scalar Variable`][bloqade.ir.scalar.Variable].\n    Args:\n        py (Union[str,Real,Tuple[Real],List[Real]]): python object to cast\n    Returns:\n        Scalar\n    \"\"\"\nret = trycast(py)\nif ret is None:\nraise TypeError(f\"Cannot cast {type(py)} to Scalar Literal\")\nreturn ret\n</code></pre>"},{"location":"reference/bloqade/#bloqade.dumps","title":"dumps","text":"<pre><code>dumps(o, use_decimal=True, **json_kwargs)\n</code></pre> <p>Serialize object to string</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dumps</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the serialized object as a string</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef dumps(\no: Any,\nuse_decimal: bool = True,\n**json_kwargs,\n) -&gt; str:\n\"\"\"Serialize object to string\n    Args:\n        o (Any): the object to serialize\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dumps\n    Returns:\n        str: the serialized object as a string\n    \"\"\"\nif not isinstance(o, Serializer.types):\nraise TypeError(\nf\"Object of type {type(o)} is not JSON serializable. \"\nf\"Only {Serializer.types} are supported.\"\n)\nreturn json.dumps(o, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade/#bloqade.load","title":"load","text":"<pre><code>load(fp, use_decimal=True, **json_kwargs)\n</code></pre> <p>Load object from file</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.load</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef load(fp: Union[TextIO, str], use_decimal: bool = True, **json_kwargs):\n\"\"\"Load object from file\n    Args:\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.load\n    Returns:\n        Any: the deserialized object\n    \"\"\"\nload_patchage()\nif isinstance(fp, str):\nwith open(fp, \"r\") as f:\nreturn json.load(\nf,\nobject_hook=Serializer.object_hook,\nuse_decimal=use_decimal,\n**json_kwargs,\n)\nelse:\nreturn json.load(\nfp,\nobject_hook=Serializer.object_hook,\nuse_decimal=use_decimal,\n**json_kwargs,\n)\n</code></pre>"},{"location":"reference/bloqade/#bloqade.loads","title":"loads","text":"<pre><code>loads(s, use_decimal=True, **json_kwargs)\n</code></pre> <p>Load object from string</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the string to load</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.loads</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef loads(s: str, use_decimal: bool = True, **json_kwargs):\n\"\"\"Load object from string\n    Args:\n        s (str): the string to load\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.loads\n    Returns:\n        Any: the deserialized object\n    \"\"\"\nload_patchage()\nreturn json.loads(\ns, object_hook=Serializer.object_hook, use_decimal=use_decimal, **json_kwargs\n)\n</code></pre>"},{"location":"reference/bloqade/#bloqade.save","title":"save","text":"<pre><code>save(o, fp, use_decimal=True, **json_kwargs)\n</code></pre> <p>Serialize object to file</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dump</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef save(\no: Any,\nfp: Union[TextIO, str],\nuse_decimal=True,\n**json_kwargs,\n) -&gt; None:\n\"\"\"Serialize object to file\n    Args:\n        o (Any): the object to serialize\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dump\n    Returns:\n        None\n    \"\"\"\nif not isinstance(o, Serializer.types):\nraise TypeError(\nf\"Object of type {type(o)} is not JSON serializable. \"\nf\"Only {Serializer.types} are supported.\"\n)\nif isinstance(fp, str):\nwith open(fp, \"w\") as f:\njson.dump(o, f, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\nelse:\njson.dump(o, fp, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade/#bloqade.tree_depth","title":"tree_depth","text":"<pre><code>tree_depth(depth=None)\n</code></pre> <p>Setting globally maximum depth for tree printing</p> <p>If <code>depth=None</code>, return current depth. If <code>depth</code> is provided, setting current depth to <code>depth</code></p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>int</code> <p>the user specified depth. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <p>current updated depth</p> Source code in <code>src/bloqade/__init__.py</code> <pre><code>def tree_depth(depth: int = None):\n\"\"\"Setting globally maximum depth for tree printing\n    If `depth=None`, return current depth.\n    If `depth` is provided, setting current depth to `depth`\n    Args:\n        depth (int, optional): the user specified depth. Defaults to None.\n    Returns:\n        int: current updated depth\n    \"\"\"\nif depth is not None:\n_ir.tree_print.max_tree_depth = depth\nreturn _ir.tree_print.max_tree_depth\n</code></pre>"},{"location":"reference/bloqade/#bloqade.var","title":"var","text":"<pre><code>var(py)\n</code></pre> <p>cast string (or list/tuple of strings) to <code>Variable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, List[str]]</code> <p>a string or list/tuple of strings</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>Union[Variable]</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def var(py: str) -&gt; \"Variable\":\n\"\"\"cast string (or list/tuple of strings)\n    to [`Variable`][bloqade.ir.scalar.Variable].\n    Args:\n        py (Union[str, List[str]]): a string or list/tuple of strings\n    Returns:\n       Union[Variable]\n    \"\"\"\nret = tryvar(py)\nif ret is None:\nraise TypeError(f\"Cannot cast {type(py)} to Variable\")\nreturn ret\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/","title":"Atom arrangement","text":""},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement","title":"AtomArrangement","text":"<p>             Bases: <code>ProgramStart</code>, <code>TransformTrait</code></p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n\"\"\"enumerate all locations in the register.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n\"\"\"obtain a figure object from the atom arrangement.\"\"\"\nreturn get_atom_arrangement_figure(self, fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Chain","title":"Chain","text":"<pre><code>Chain(L, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\nself, L: int, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\nself.vertical = vertical_chain\nsuper().__init__(L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L * 2.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Kagome","title":"Kagome","text":"<pre><code>Kagome(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Lieb","title":"Lieb","text":"<pre><code>Lieb(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\nwidth,\nheight,\nlattice_spacing_x=1.0,\nlattice_spacing_y=None,\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>None</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\nself,\nwidth: int,\nheight: int,\nlattice_spacing_x: ScalarType = 1.0,\nlattice_spacing_y: Optional[ScalarType] = None,\n):\nsuper().__init__(width, height, lattice_spacing=lattice_spacing_x)\nif lattice_spacing_y is None:\nself.ratio = cast(1.0) / cast(lattice_spacing_x)\nelse:\nself.ratio = cast(lattice_spacing_y) / cast(lattice_spacing_x)\nsuper().__init__(width, height, lattice_spacing=lattice_spacing_x)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Square","title":"Square","text":"<pre><code>Square(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Triangular","title":"Triangular","text":"<pre><code>Triangular(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/constants/","title":"Constants","text":""},{"location":"reference/bloqade/serialize/","title":"Serialize","text":""},{"location":"reference/bloqade/serialize/#bloqade.serialize.dumps","title":"dumps","text":"<pre><code>dumps(o, use_decimal=True, **json_kwargs)\n</code></pre> <p>Serialize object to string</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dumps</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the serialized object as a string</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef dumps(\no: Any,\nuse_decimal: bool = True,\n**json_kwargs,\n) -&gt; str:\n\"\"\"Serialize object to string\n    Args:\n        o (Any): the object to serialize\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dumps\n    Returns:\n        str: the serialized object as a string\n    \"\"\"\nif not isinstance(o, Serializer.types):\nraise TypeError(\nf\"Object of type {type(o)} is not JSON serializable. \"\nf\"Only {Serializer.types} are supported.\"\n)\nreturn json.dumps(o, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade/serialize/#bloqade.serialize.load","title":"load","text":"<pre><code>load(fp, use_decimal=True, **json_kwargs)\n</code></pre> <p>Load object from file</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.load</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef load(fp: Union[TextIO, str], use_decimal: bool = True, **json_kwargs):\n\"\"\"Load object from file\n    Args:\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.load\n    Returns:\n        Any: the deserialized object\n    \"\"\"\nload_patchage()\nif isinstance(fp, str):\nwith open(fp, \"r\") as f:\nreturn json.load(\nf,\nobject_hook=Serializer.object_hook,\nuse_decimal=use_decimal,\n**json_kwargs,\n)\nelse:\nreturn json.load(\nfp,\nobject_hook=Serializer.object_hook,\nuse_decimal=use_decimal,\n**json_kwargs,\n)\n</code></pre>"},{"location":"reference/bloqade/serialize/#bloqade.serialize.loads","title":"loads","text":"<pre><code>loads(s, use_decimal=True, **json_kwargs)\n</code></pre> <p>Load object from string</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the string to load</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.loads</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef loads(s: str, use_decimal: bool = True, **json_kwargs):\n\"\"\"Load object from string\n    Args:\n        s (str): the string to load\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.loads\n    Returns:\n        Any: the deserialized object\n    \"\"\"\nload_patchage()\nreturn json.loads(\ns, object_hook=Serializer.object_hook, use_decimal=use_decimal, **json_kwargs\n)\n</code></pre>"},{"location":"reference/bloqade/serialize/#bloqade.serialize.save","title":"save","text":"<pre><code>save(o, fp, use_decimal=True, **json_kwargs)\n</code></pre> <p>Serialize object to file</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dump</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef save(\no: Any,\nfp: Union[TextIO, str],\nuse_decimal=True,\n**json_kwargs,\n) -&gt; None:\n\"\"\"Serialize object to file\n    Args:\n        o (Any): the object to serialize\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dump\n    Returns:\n        None\n    \"\"\"\nif not isinstance(o, Serializer.types):\nraise TypeError(\nf\"Object of type {type(o)} is not JSON serializable. \"\nf\"Only {Serializer.types} are supported.\"\n)\nif isinstance(fp, str):\nwith open(fp, \"w\") as f:\njson.dump(o, f, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\nelse:\njson.dump(o, fp, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade/builder/","title":"Index","text":""},{"location":"reference/bloqade/builder/args/","title":"Args","text":""},{"location":"reference/bloqade/builder/assign/","title":"Assign","text":""},{"location":"reference/bloqade/builder/coupling/","title":"Coupling","text":""},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.Hyperfine","title":"Hyperfine","text":"<p>             Bases: <code>LevelCoupling</code></p> <p>This node represent level coupling between hyperfine state.</p> <p>Examples:</p> <pre><code>- To reach the node from the start node:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.coupling.Hyperfine'&gt;\n\n- Hyperfine level coupling have two reachable field nodes:\n\n    - detuning term (See also [`Detuning`][bloqade.builder.field.Detuning])\n    - rabi term (See also [`Rabi`][bloqade.builder.field.Rabi])\n\n&gt;&gt;&gt; hyp_detune = bloqade.start.hyperfine.detuning\n&gt;&gt;&gt; hyp_rabi = bloqade.start.hyperfine.rabi\n</code></pre>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.LevelCoupling","title":"LevelCoupling","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.LevelCoupling.detuning","title":"detuning  <code>property</code>","text":"<pre><code>detuning\n</code></pre> <ul> <li>Specify the Detuning field</li> <li>Next-step:  <li> <p>Possible Next:</p> <p>-&gt; <code>...detuning.location(int)</code>     :: Address atom at specific location</p> <p>-&gt; <code>...detuning.uniform</code>     :: Address all atoms in register</p> <p>-&gt; <code>...detuning.var(str)</code>     :: Address atom at location labeled by variable</p> </li>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.LevelCoupling.rabi","title":"rabi  <code>property</code>","text":"<pre><code>rabi\n</code></pre> <ul> <li>Specify the Rabi term/field.</li> <li> <p>Possible Next:</p> <p>-&gt; <code>...rabi.amplitude</code>     :: address rabi amplitude</p> <p>-&gt; <code>...rabi.phase</code>     :: address rabi phase</p> </li> </ul>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.Rydberg","title":"Rydberg","text":"<p>             Bases: <code>LevelCoupling</code></p> <p>This node represent level coupling of rydberg state.</p> <p>Examples:</p> <pre><code>- To reach the node from the start node:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.coupling.Rydberg'&gt;\n\n- Rydberg level coupling have two reachable field nodes:\n\n    - detuning term (See also [`Detuning`][bloqade.builder.field.Detuning])\n    - rabi term (See also [`Rabi`][bloqade.builder.field.Rabi])\n\n&gt;&gt;&gt; ryd_detune = bloqade.start.rydberg.detuning\n&gt;&gt;&gt; ryd_rabi = bloqade.start.rydberg.rabi\n</code></pre>"},{"location":"reference/bloqade/builder/drive/","title":"Drive","text":""},{"location":"reference/bloqade/builder/drive/#bloqade.builder.drive.Drive","title":"Drive","text":""},{"location":"reference/bloqade/builder/drive/#bloqade.builder.drive.Drive.hyperfine","title":"hyperfine  <code>property</code>","text":"<pre><code>hyperfine\n</code></pre> <ul> <li>Specify the Hyperfile level coupling.</li> <li> <p>Possible Next:</p> <p>-&gt; <code>...hyperfine.rabi</code>     :: address rabi term</p> <p>-&gt; <code>...hyperfine.detuning</code>     :: address detuning field</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = bloqade.start.hyperfine\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.coupling.Hyperfine'&gt;\n</code></pre> <ul> <li> <p>Hyperfine level coupling have two reachable field nodes:</p> <ul> <li>detuning term (See also <code>Detuning</code>)</li> <li>rabi term (See also <code>Rabi</code>)</li> </ul> </li> </ul> <pre><code>&gt;&gt;&gt; hyp_detune = bloqade.start.hyperfine.detuning\n&gt;&gt;&gt; hyp_rabi = bloqade.start.hyperfine.rabi\n</code></pre> <p>See Hyperfine for more details.</p>"},{"location":"reference/bloqade/builder/drive/#bloqade.builder.drive.Drive.rydberg","title":"rydberg  <code>property</code>","text":"<pre><code>rydberg\n</code></pre> <ul> <li>Specify the Rydberg level coupling.</li> <li> <p>Possible Next:</p> <p>-&gt; <code>...rydberg.rabi</code>     :: address rabi term</p> <p>-&gt; <code>...rydberg.detuning</code>     :: address detuning field</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = bloqade.start.rydberg\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.coupling.Rydberg'&gt;\n</code></pre> <ul> <li> <p>Rydberg level coupling have two reachable field nodes:</p> <ul> <li>detuning term (See also <code>Detuning</code>)</li> <li>rabi term (See also <code>Rabi</code>)</li> </ul> </li> </ul> <pre><code>&gt;&gt;&gt; ryd_detune = bloqade.start.rydberg.detuning\n&gt;&gt;&gt; ryd_rabi = bloqade.start.rydberg.rabi\n</code></pre> <p>See <code>Rydberg</code> for more details.</p>"},{"location":"reference/bloqade/builder/field/","title":"Field","text":""},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Detuning","title":"Detuning","text":"<p>             Bases: <code>Field</code></p> <p>This node represent detuning field of a specified level coupling (rydberg or hyperfine) type.</p> <p>Examples:</p> <pre><code>- To specify detuning of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.detuning\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Detuning'&gt;\n\n- To specify detuning of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.detuning\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Detuning'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See <code>SpatialModulation</code> for additional options.</p>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field","title":"Field","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.uniform","title":"uniform  <code>property</code>","text":"<pre><code>uniform\n</code></pre> <ul> <li>Addressing all atom locations for preceeding waveform</li> <li>Next-step:  <li> <p>Possible Next:</p> <p>-&gt; <code>...uniform.linear()</code>     :: apply linear waveform</p> <p>-&gt; <code>...uniform.constant()</code>     :: apply constant waveform</p> <p>-&gt; <code>...uniform.ploy()</code>     :: apply polynomial waveform</p> <p>-&gt; <code>...uniform.apply()</code>     :: apply pre-constructed waveform</p> <p>-&gt; <code>...uniform.piecewise_linear()</code>     :: apply piecewise linear waveform</p> <p>-&gt; <code>...uniform.piecewise_constant()</code>     :: apply piecewise constant waveform</p> <p>-&gt; <code>...uniform.fn()</code>     :: apply callable as waveform.</p> </li> <p>Examples:</p> <pre><code>- Addressing rydberg detuning to all atoms in the system with\n4 sites\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.uniform\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.location","title":"location","text":"<pre><code>location(label)\n</code></pre> <p>Addressing one or multiple specific location(s) for preceeding waveform.</p> <p>(See <code>Location</code> for more details])</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>int</code> <p>The label of the location to apply the following waveform to.</p> required <p>Examples:</p> <pre><code>- Addressing rydberg detuning to location 1 on a system with 4 sites.\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.location(1)\n\n- Addressing rydberg detuning on both location\n0 and 2 on a system with 4 sites.\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.location(1).location(2)\n</code></pre> Note <p>label index start with 0, and should be positive.</p> <ul> <li> <p>Possible Next : <p>-&gt; <code>...location(int).location(int)</code>     :: adding location into current list</p> <p>-&gt; <code>...location(int).scale(float)</code>     :: specify scaling factor to current location     for the preceeding waveform</p> <li> <p>Possible Next : <p>-&gt; <code>...location(int).linear()</code>     :: apply linear waveform</p> <p>-&gt; <code>...location(int).constant()</code>     :: apply constant waveform</p> <p>-&gt; <code>...location(int).ploy()</code>     :: apply polynomial waveform</p> <p>-&gt; <code>...location(int).apply()</code>     :: apply pre-constructed waveform</p> <p>-&gt; <code>...location(int).piecewise_linear()</code>     :: apply piecewise linear waveform</p> <p>-&gt; <code>...location(int).piecewise_constant()</code>     :: apply piecewise constant waveform</p> <p>-&gt; <code>...location(int).fn()</code>     :: apply callable as waveform.</p> Source code in <code>src/bloqade/builder/field.py</code> <pre><code>@beartype\ndef location(self, label: int):\n\"\"\"\n    Addressing one or multiple specific location(s) for preceeding waveform.\n    (See [`Location`][bloqade.builder.location.Location] for more details])\n    Args:\n        label (int): The label of the location to apply the following waveform to.\n    Examples:\n        - Addressing rydberg detuning to location 1 on a system with 4 sites.\n        &gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n        &gt;&gt;&gt; loc = reg.rydberg.detuning.location(1)\n        - Addressing rydberg detuning on both location\n        0 and 2 on a system with 4 sites.\n        &gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n        &gt;&gt;&gt; loc = reg.rydberg.detuning.location(1).location(2)\n    Note:\n        label index start with 0, and should be positive.\n    - Possible Next &lt;Location&gt;:\n        -&gt; `...location(int).location(int)`\n            :: adding location into current list\n        -&gt; `...location(int).scale(float)`\n            :: specify scaling factor to current location\n            for the preceeding waveform\n    - Possible Next &lt;WaveForm&gt;:\n        -&gt; `...location(int).linear()`\n            :: apply linear waveform\n        -&gt; `...location(int).constant()`\n            :: apply constant waveform\n        -&gt; `...location(int).ploy()`\n            :: apply polynomial waveform\n        -&gt; `...location(int).apply()`\n            :: apply pre-constructed waveform\n        -&gt; `...location(int).piecewise_linear()`\n            :: apply piecewise linear waveform\n        -&gt; `...location(int).piecewise_constant()`\n            :: apply piecewise constant waveform\n        -&gt; `...location(int).fn()`\n            :: apply callable as waveform.\n    \"\"\"\nfrom bloqade.builder.spatial import Location\nreturn Location(label, self)\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.var","title":"var","text":"<pre><code>var(name)\n</code></pre> <ul> <li>Addressing atom location associate with given variable for preceeding waveform</li> <li> <p>Possible Next : <p>-&gt; <code>...location(int).linear()</code>     :: apply linear waveform</p> <p>-&gt; <code>...location(int).constant()</code>     :: apply constant waveform</p> <p>-&gt; <code>...location(int).ploy()</code>     :: apply polynomial waveform</p> <p>-&gt; <code>...location(int).apply()</code>     :: apply pre-constructed waveform</p> <p>-&gt; <code>...location(int).piecewise_linear()</code>     :: apply piecewise linear waveform</p> <p>-&gt; <code>...location(int).piecewise_constant()</code>     :: apply piecewise constant waveform</p> <p>-&gt; <code>...location(int).fn()</code>     :: apply callable as waveform.</p> <p>Examples:</p> <pre><code>- Addressing rydberg detuning to atom location `myatom` in the system with\n4 sites\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.var('myatom')\n</code></pre> Source code in <code>src/bloqade/builder/field.py</code> <pre><code>@beartype\ndef var(self, name: str):\n\"\"\"\n    - Addressing atom location associate with given variable for preceeding waveform\n    - Possible Next &lt;WaveForm&gt;:\n        -&gt; `...location(int).linear()`\n            :: apply linear waveform\n        -&gt; `...location(int).constant()`\n            :: apply constant waveform\n        -&gt; `...location(int).ploy()`\n            :: apply polynomial waveform\n        -&gt; `...location(int).apply()`\n            :: apply pre-constructed waveform\n        -&gt; `...location(int).piecewise_linear()`\n            :: apply piecewise linear waveform\n        -&gt; `...location(int).piecewise_constant()`\n            :: apply piecewise constant waveform\n        -&gt; `...location(int).fn()`\n            :: apply callable as waveform.\n    Examples:\n        - Addressing rydberg detuning to atom location `myatom` in the system with\n        4 sites\n        &gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n        &gt;&gt;&gt; loc = reg.rydberg.detuning.var('myatom')\n    \"\"\"\nfrom bloqade.builder.spatial import Var\nreturn Var(name, self)\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Rabi","title":"Rabi","text":"<p>             Bases: <code>Builder</code></p> <p>This node represent rabi field of a specified level coupling (rydberg or hyperfine) type.</p> <p>Examples:</p> <pre><code>- To specify rabi of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi\n&lt;class 'bloqade.builder.field.Rabi'&gt;\n\n- To specify rabi of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Rabi'&gt;\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Rabi.amplitude","title":"amplitude  <code>property</code>","text":"<pre><code>amplitude\n</code></pre> <ul> <li>Specify the amplitude of the rabi field.</li> <li>Next-step:  <li> <p>Possible Next:</p> <p>-&gt; <code>...amplitude.location(int)</code>     :: Address atom at specific location</p> <p>-&gt; <code>...amplitude.uniform</code>     :: Address all atoms in register</p> <p>-&gt; <code>...amplitude.var(str)</code>     :: Address atom at location labeled by variable</p> </li> <p>Examples:</p> <pre><code>- rydberg coupling rabi amplitude\n(See also [`RabiAmplitude`][bloqade.builder.field.RabiAmplitude])\n\n&gt;&gt;&gt; ryd_rabi = bloqade.start.rydberg.rabi\n&gt;&gt;&gt; ryd_rabi_amp = ryd_rabi.amplitude\n\n\n- hyperfine coupling rabi amplitude\n(See also [`RabiAmplitude`][bloqade.builder.field.RabiAmplitude])\n\n&gt;&gt;&gt; hyp_rabi = bloqade.start.hyperfine.rabi\n&gt;&gt;&gt; hyp_rabi_amp = hyp_rabi.amplitude\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Rabi.phase","title":"phase  <code>property</code>","text":"<pre><code>phase\n</code></pre> <ul> <li>Specify the phase of the rabi field.</li> <li>Next-step:  <li> <p>Possible Next:</p> <p>-&gt; <code>...phase.location(int)</code>     :: Address atom at specific location</p> <p>-&gt; <code>...phase.uniform</code>     :: Address all atoms in register</p> <p>-&gt; <code>...phase.var(str)</code>     :: Address atom at location labeled by variable</p> </li> <p>Examples:</p> <pre><code>- rydberg coupling rabi phase\n(See also [`RabiPhase`][bloqade.builder.field.RabiPhase])\n\n&gt;&gt;&gt; ryd_rabi = bloqade.start.rydberg.rabi\n&gt;&gt;&gt; ryd_rabi_ph = ryd_rabi.phase\n\n\n- hyperfine coupling rabi phase\n(See also [`RabiPhase`][bloqade.builder.field.RabiPhase])\n\n&gt;&gt;&gt; hyp_rabi = bloqade.start.hyperfine.rabi\n&gt;&gt;&gt; hyp_rabi_ph = hyp_rabi.phase\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.RabiAmplitude","title":"RabiAmplitude","text":"<p>             Bases: <code>Field</code></p> <p>This node represent amplitude of a rabi field.</p> <p>Examples:</p> <pre><code>- To specify rabi amplitude of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi.amplitude\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Amplitude'&gt;\n\n- To specify rabi amplitude of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi.amplitude\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Amplitude'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See <code>SpatialModulation</code> for additional options.</p>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.RabiPhase","title":"RabiPhase","text":"<p>             Bases: <code>Field</code></p> <p>This node represent phase of a rabi field.</p> <p>Examples:</p> <pre><code>- To specify rabi phase of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi.phase\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Phase'&gt;\n\n- To specify rabi phase of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi.phase\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Phase'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See <code>SpatialModulation</code> for additional options.</p>"},{"location":"reference/bloqade/builder/parallelize/","title":"Parallelize","text":""},{"location":"reference/bloqade/builder/pragmas/","title":"Pragmas","text":""},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Assignable","title":"Assignable","text":""},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Assignable.assign","title":"assign","text":"<pre><code>assign(**assignments)\n</code></pre> <p>Assign values to variables declared previously in the program.</p> <p>Parameters:</p> Name Type Description Default <code>assignments</code> <code>Dict[str, Union[Number]]</code> <code>{}</code> <p>Examples:</p> <ul> <li>Assign the value 0.0 to the variable \"ival\" and 0.5 to the variable \"span_time\".</li> </ul> <pre><code>&gt;&gt;&gt; reg = bloqade.start\n...       .add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; seq = reg.rydberg.detuning.uniform\n...       .linear(start=\"ival\",stop=1,duration=\"span_time\")\n&gt;&gt;&gt; seq = seq.assign(span_time = 0.5, ival = 0.0)\n</code></pre> Source code in <code>src/bloqade/builder/pragmas.py</code> <pre><code>def assign(self, **assignments) -&gt; \"Assign\":\n\"\"\"\n    Assign values to variables declared previously in the program.\n    Args:\n        assignments (Dict[str, Union[Number]]):\n        The assignments, which should be a kwargs\n        where the key is the variable name and the\n        value is the value to assign to the variable.\n    Examples:\n        - Assign the value 0.0 to the variable \"ival\"\n        and 0.5 to the variable \"span_time\".\n        &gt;&gt;&gt; reg = bloqade.start\n        ...       .add_position([(0,0),(1,1),(2,2),(3,3)])\n        &gt;&gt;&gt; seq = reg.rydberg.detuning.uniform\n        ...       .linear(start=\"ival\",stop=1,duration=\"span_time\")\n        &gt;&gt;&gt; seq = seq.assign(span_time = 0.5, ival = 0.0)\n    \"\"\"\nfrom bloqade.builder.assign import Assign\nreturn Assign(parent=self, **assignments)\n</code></pre>"},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Parallelizable","title":"Parallelizable","text":""},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Parallelizable.parallelize","title":"parallelize","text":"<pre><code>parallelize(cluster_spacing)\n</code></pre> <p>Parallelize the current problem (register &amp; sequnece) to fill entire FOV with the given cluster spacing.</p> <p>Parameters:</p> Name Type Description Default <code>cluster_spacing</code> <code>Real | Decimal</code> required <p>Examples:</p> <ul> <li>Parallelize the current problem with cluster spacing 7.2 um.</li> </ul> <pre><code>&gt;&gt;&gt; prob = (\n        bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n        .rydberg.detuning.uniform\n        .linear(start=0,stop=1,duration=1)\n        )\n&gt;&gt;&gt; prob = prob.parallelize(7.2)\n</code></pre> Source code in <code>src/bloqade/builder/pragmas.py</code> <pre><code>def parallelize(self, cluster_spacing: LiteralType) -&gt; \"Parallelize\":\n\"\"\"\n    Parallelize the current problem (register &amp; sequnece) to fill entire FOV\n    with the given cluster spacing.\n    Args:\n        cluster_spacing (Real | Decimal):\n        the spacing between parallel clusters.\n    Examples:\n        - Parallelize the current problem with cluster spacing 7.2 um.\n        &gt;&gt;&gt; prob = (\n                bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n                .rydberg.detuning.uniform\n                .linear(start=0,stop=1,duration=1)\n                )\n        &gt;&gt;&gt; prob = prob.parallelize(7.2)\n    \"\"\"\nfrom bloqade.builder.parallelize import Parallelize\nreturn Parallelize(cluster_spacing, self)\n</code></pre>"},{"location":"reference/bloqade/builder/route/","title":"Route","text":""},{"location":"reference/bloqade/builder/sequence_builder/","title":"Sequence builder","text":""},{"location":"reference/bloqade/builder/spatial/","title":"Spatial","text":""},{"location":"reference/bloqade/builder/spatial/#bloqade.builder.spatial.Location","title":"Location","text":"<pre><code>Location(label, parent=None)\n</code></pre> <p>             Bases: <code>SpatialModulation</code></p> Source code in <code>src/bloqade/builder/spatial.py</code> <pre><code>@beartype\ndef __init__(self, label: int, parent: Optional[Builder] = None) -&gt; None:\nassert isinstance(label, int) and label &gt;= 0\nsuper().__init__(parent)\nself._label = label\n</code></pre>"},{"location":"reference/bloqade/builder/spatial/#bloqade.builder.spatial.Location.location","title":"location","text":"<pre><code>location(label)\n</code></pre> <p>Append another location to the current location(s)</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>int</code> <p>The label of the location</p> required <p>Examples:</p> <pre><code>- Append location 1 to the current location 0.\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.location(0)\n&gt;&gt;&gt; loc = loc.location(1)\n\n- One can keep appending by concatenating location()\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.location(0)\n&gt;&gt;&gt; loc = loc.location(1).location(2)\n</code></pre> <ul> <li> <p>Possible Next : <p>-&gt; <code>...location(int).location(int)</code>     :: keep adding location into current list</p> <p>-&gt; <code>...location(int).scale(float)</code>     :: specify scaling factor to current location     for the preceeding waveform</p> <li> <p>Possible Next : <p>-&gt; <code>...location(int).linear()</code>     :: apply linear waveform</p> <p>-&gt; <code>...location(int).constant()</code>     :: apply constant waveform</p> <p>-&gt; <code>...location(int).ploy()</code>     :: apply polynomial waveform</p> <p>-&gt; <code>...location(int).apply()</code>     :: apply pre-constructed waveform</p> <p>-&gt; <code>...location(int).piecewise_linear()</code>     :: apply piecewise linear waveform</p> <p>-&gt; <code>...location(int).piecewise_constant()</code>     :: apply piecewise constant waveform</p> <p>-&gt; <code>...location(int).fn()</code>     :: apply callable as waveform.</p> Source code in <code>src/bloqade/builder/spatial.py</code> <pre><code>@beartype\ndef location(self, label: int) -&gt; \"Location\":\n\"\"\"\n    Append another location to the current location(s)\n    Args:\n        label (int): The label of the location\n    Examples:\n        - Append location 1 to the current location 0.\n        &gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n        &gt;&gt;&gt; loc = reg.rydberg.detuning.location(0)\n        &gt;&gt;&gt; loc = loc.location(1)\n        - One can keep appending by concatenating location()\n        &gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n        &gt;&gt;&gt; loc = reg.rydberg.detuning.location(0)\n        &gt;&gt;&gt; loc = loc.location(1).location(2)\n    - Possible Next &lt;Location&gt;:\n        -&gt; `...location(int).location(int)`\n            :: keep adding location into current list\n        -&gt; `...location(int).scale(float)`\n            :: specify scaling factor to current location\n            for the preceeding waveform\n    - Possible Next &lt;WaveForm&gt;:\n        -&gt; `...location(int).linear()`\n            :: apply linear waveform\n        -&gt; `...location(int).constant()`\n            :: apply constant waveform\n        -&gt; `...location(int).ploy()`\n            :: apply polynomial waveform\n        -&gt; `...location(int).apply()`\n            :: apply pre-constructed waveform\n        -&gt; `...location(int).piecewise_linear()`\n            :: apply piecewise linear waveform\n        -&gt; `...location(int).piecewise_constant()`\n            :: apply piecewise constant waveform\n        -&gt; `...location(int).fn()`\n            :: apply callable as waveform.\n    \"\"\"\nreturn Location(label, self)\n</code></pre>"},{"location":"reference/bloqade/builder/spatial/#bloqade.builder.spatial.Location.scale","title":"scale","text":"<pre><code>scale(value)\n</code></pre> <p>Scale the preceeding waveform by the specified factor.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float</code> <p>The factor to scale (amplitude of)</p> required <p>Examples:</p> <pre><code>- Scale the preceeding waveform that addressing location(0) by 1.2.\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; scaled = reg.rydberg.detuning.location(0).scale(1.2)\n\n- Scale multiple locations with different factors.\n(ex. loc 0 by 1.2, loc 1 by 0.5)\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.location(0)\n&gt;&gt;&gt; loc = loc.scale(1.2).location(1).scale(0.5)\n\n- Scale multiple locations with the same factor. (ex. loc 0 and 1 by 1.2)\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; scaled = reg.rydberg.detuning.location(0).location(1).scale(1.2)\n</code></pre> <ul> <li> <p>Possible Next : <p>-&gt; <code>...scale(float).location(int)</code>     :: keep adding location into current list</p> <li> <p>Possible Next : <p>-&gt; <code>...scale(float).linear()</code>     :: apply linear waveform</p> <p>-&gt; <code>...scale(float).constant()</code>     :: apply constant waveform</p> <p>-&gt; <code>...scale(float).ploy()</code>     :: apply polynomial waveform</p> <p>-&gt; <code>...scale(float).apply()</code>     :: apply pre-constructed waveform(s)</p> <p>-&gt; <code>...scale(float).piecewise_linear()</code>     :: apply piecewise linear waveform</p> <p>-&gt; <code>...scale(float).piecewise_constant()</code>     :: apply piecewise constant waveform</p> <p>-&gt; <code>...scale(float).fn()</code>     :: apply callable as waveform.</p> Source code in <code>src/bloqade/builder/spatial.py</code> <pre><code>@beartype\ndef scale(self, value: ScalarType) -&gt; \"Scale\":\n\"\"\"\n    Scale the preceeding waveform by the specified factor.\n    Args:\n        scale (float): The factor to scale (amplitude of)\n        the preceeding waveform.\n    Examples:\n        - Scale the preceeding waveform that addressing location(0) by 1.2.\n        &gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n        &gt;&gt;&gt; scaled = reg.rydberg.detuning.location(0).scale(1.2)\n        - Scale multiple locations with different factors.\n        (ex. loc 0 by 1.2, loc 1 by 0.5)\n        &gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n        &gt;&gt;&gt; loc = reg.rydberg.detuning.location(0)\n        &gt;&gt;&gt; loc = loc.scale(1.2).location(1).scale(0.5)\n        - Scale multiple locations with the same factor. (ex. loc 0 and 1 by 1.2)\n        &gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n        &gt;&gt;&gt; scaled = reg.rydberg.detuning.location(0).location(1).scale(1.2)\n    - Possible Next &lt;Location&gt;:\n        -&gt; `...scale(float).location(int)`\n            :: keep adding location into current list\n    - Possible Next &lt;WaveForm&gt;:\n        -&gt; `...scale(float).linear()`\n            :: apply linear waveform\n        -&gt; `...scale(float).constant()`\n            :: apply constant waveform\n        -&gt; `...scale(float).ploy()`\n            :: apply polynomial waveform\n        -&gt; `...scale(float).apply()`\n            :: apply pre-constructed waveform(s)\n        -&gt; `...scale(float).piecewise_linear()`\n            :: apply piecewise linear waveform\n        -&gt; `...scale(float).piecewise_constant()`\n            :: apply piecewise constant waveform\n        -&gt; `...scale(float).fn()`\n            :: apply callable as waveform.\n    \"\"\"\nreturn Scale(value, self)\n</code></pre>"},{"location":"reference/bloqade/builder/spatial/#bloqade.builder.spatial.Scale","title":"Scale","text":"<pre><code>Scale(value, parent=None)\n</code></pre> <p>             Bases: <code>WaveformAttachable</code></p> Source code in <code>src/bloqade/builder/spatial.py</code> <pre><code>@beartype\ndef __init__(self, value: ScalarType, parent: Optional[Builder] = None) -&gt; None:\nsuper().__init__(parent)\nself._value = value\n</code></pre>"},{"location":"reference/bloqade/builder/spatial/#bloqade.builder.spatial.Scale.location","title":"location","text":"<pre><code>location(label)\n</code></pre> <ul> <li>Append another location to the current location after scale the previous one</li> </ul> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>int</code> <p>The label of the location</p> required <p>Examples:</p> <pre><code>- Append location 1 after scale location 0 by 1.2.\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.location(0).scale(1.2)\n&gt;&gt;&gt; loc = loc.location(1)\n</code></pre> <ul> <li> <p>Possible Next : <p>-&gt; <code>...location(int).location(int)</code>     :: keep adding location into current list</p> <p>-&gt; <code>...location(int).scale(float)</code>     :: specify scaling factor to current location     for the preceeding waveform</p> <li> <p>Possible Next : <p>-&gt; <code>...location(int).linear()</code>     :: apply linear waveform</p> <p>-&gt; <code>...location(int).constant()</code>     :: apply constant waveform</p> <p>-&gt; <code>...location(int).ploy()</code>     :: apply polynomial waveform</p> <p>-&gt; <code>...location(int).apply()</code>     :: apply pre-constructed waveform</p> <p>-&gt; <code>...location(int).piecewise_linear()</code>     :: apply piecewise linear waveform</p> <p>-&gt; <code>...location(int).piecewise_constant()</code>     :: apply piecewise constant waveform</p> <p>-&gt; <code>...location(int).fn()</code>     :: apply callable as waveform.</p> Source code in <code>src/bloqade/builder/spatial.py</code> <pre><code>@beartype\ndef location(self, label: int) -&gt; \"Location\":\n\"\"\"\n    - Append another location to the current location after scale the previous one\n    Args:\n        label (int): The label of the location\n    Examples:\n        - Append location 1 after scale location 0 by 1.2.\n        &gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n        &gt;&gt;&gt; loc = reg.rydberg.detuning.location(0).scale(1.2)\n        &gt;&gt;&gt; loc = loc.location(1)\n    - Possible Next &lt;Location&gt;:\n        -&gt; `...location(int).location(int)`\n            :: keep adding location into current list\n        -&gt; `...location(int).scale(float)`\n            :: specify scaling factor to current location\n            for the preceeding waveform\n    - Possible Next &lt;WaveForm&gt;:\n        -&gt; `...location(int).linear()`\n            :: apply linear waveform\n        -&gt; `...location(int).constant()`\n            :: apply constant waveform\n        -&gt; `...location(int).ploy()`\n            :: apply polynomial waveform\n        -&gt; `...location(int).apply()`\n            :: apply pre-constructed waveform\n        -&gt; `...location(int).piecewise_linear()`\n            :: apply piecewise linear waveform\n        -&gt; `...location(int).piecewise_constant()`\n            :: apply piecewise constant waveform\n        -&gt; `...location(int).fn()`\n            :: apply callable as waveform.\n    \"\"\"\nreturn Location(label, self)\n</code></pre>"},{"location":"reference/bloqade/builder/spatial/#bloqade.builder.spatial.Uniform","title":"Uniform","text":"<p>             Bases: <code>SpatialModulation</code></p> <p>The node specify a uniform spacial modulation. Which is ready to apply waveform (See <code>Waveform</code> for available waveform options)</p> <p>Examples:</p> <pre><code>- To hit this node from the start node:\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.uniform\n\n- Apply Linear waveform:\n\n&gt;&gt;&gt; wv = bloqade.ir.Linear(start=0,stop=1,duration=0.5)\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.uniform.apply(wv)\n</code></pre>"},{"location":"reference/bloqade/builder/start/","title":"Start","text":""},{"location":"reference/bloqade/builder/start/#bloqade.builder.start.ProgramStart","title":"ProgramStart","text":"<p>             Bases: <code>Drive</code>, <code>Builder</code></p> <p>ProgramStart is the base class for a starting/entry node for building a program.</p>"},{"location":"reference/bloqade/builder/start/#bloqade.builder.start.ProgramStart.apply","title":"apply","text":"<pre><code>apply(sequence)\n</code></pre> <p>apply an existing pulse sequence to the program.</p> Source code in <code>src/bloqade/builder/start.py</code> <pre><code>@beartype\ndef apply(self, sequence: Sequence) -&gt; SequenceBuilder:\n\"\"\"apply an existing pulse sequence to the program.\"\"\"\nreturn SequenceBuilder(sequence, self)\n</code></pre>"},{"location":"reference/bloqade/builder/typing/","title":"Typing","text":""},{"location":"reference/bloqade/builder/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Recordable","title":"Recordable","text":""},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Recordable.record","title":"record","text":"<pre><code>record(name)\n</code></pre> <p>Record the value of the current waveform to a variable.</p> <p>Possible Next:</p> <ul> <li> <p>Possible Next : <p>-&gt; <code>.location(int)</code>     :: creating new channel to address     another location(s)</p> <li> <p>Possible Next : <p>-&gt; <code>.slice()</code>     :: slice the current waveform</p> <p>-&gt; <code>.record(str)</code>     :: record the value of waveform at current time</p> <li> <p>Possible Next : <p>:: Append waveform into current channel</p> <p>-&gt; <code>.linear()</code></p> <p>-&gt; <code>.constant()</code></p> <p>-&gt; <code>.ploy()</code></p> <p>-&gt; <code>.apply()</code></p> <p>-&gt; <code>.piecewise_linear()</code></p> <p>-&gt; <code>.piecewise_constant()</code></p> <p>-&gt; <code>.fn()</code></p> <li> <p>Possible Next : <p>-&gt; <code>.rydberg</code>     :: Create/Switch to new rydberg level coupling channel</p> <p>-&gt; <code>.hyperfine</code>     :: Create/Switch to new hyperfine level coupling channel</p> <li> <p>Possible Next : <p>-&gt; <code>.assign()</code>     :: assign varialbe an actual value/number</p> <p>-&gt; <code>.batch_assign()</code>     :: create batch job with different sets     of values assign to each variable.</p> <li> <p>Possible Next : <p>-&gt; <code>.quera</code>     :: specify QuEra backend</p> <p>-&gt; <code>.braket</code>     :: specify QuEra backend</p> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef record(self, name: str) -&gt; \"Record\":\n\"\"\"\n    Record the value of the current waveform to a variable.\n    Possible Next:\n    - Possible Next &lt;Location&gt;:\n        -&gt; `.location(int)`\n            :: creating new channel to address\n            another location(s)\n    - Possible Next &lt;WaveForm:: current&gt;:\n        -&gt; `.slice()`\n            :: slice the current waveform\n        -&gt; `.record(str)`\n            :: record the value of waveform at current time\n    - Possible Next &lt;WaveForm:: append&gt;:\n        :: Append waveform into current channel\n        -&gt; `.linear()`\n        -&gt; `.constant()`\n        -&gt; `.ploy()`\n        -&gt; `.apply()`\n        -&gt; `.piecewise_linear()`\n        -&gt; `.piecewise_constant()`\n        -&gt; `.fn()`\n    - Possible Next &lt;LevelCoupling&gt;:\n        -&gt; `.rydberg`\n            :: Create/Switch to new rydberg level coupling channel\n        -&gt; `.hyperfine`\n            :: Create/Switch to new hyperfine level coupling channel\n    - Possible Next &lt;Emit:: Linking Vars&gt;:\n        -&gt; `.assign()`\n            :: assign varialbe an actual value/number\n        -&gt; `.batch_assign()`\n            :: create batch job with different sets\n            of values assign to each variable.\n    - Possible Next &lt;Backend&gt;:\n        -&gt; `.quera`\n            :: specify QuEra backend\n        -&gt; `.braket`\n            :: specify QuEra backend\n    \"\"\"\nreturn Record(name, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Sliceable","title":"Sliceable","text":""},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Sliceable.slice","title":"slice","text":"<pre><code>slice(start=None, stop=None)\n</code></pre> <p>Slice current waveform</p> <p>Possible Next:</p> <ul> <li> <p>Possible Next : <p>-&gt; <code>.location(int)</code>     :: creating new channel to address     another location(s)</p> <li> <p>Possible Next : <p>-&gt; <code>.record(str)</code>     :: record the value of waveform at current time</p> <li> <p>Possible Next : <p>:: Append waveform into current channel</p> <p>-&gt; <code>.linear()</code></p> <p>-&gt; <code>.constant()</code></p> <p>-&gt; <code>.ploy()</code></p> <p>-&gt; <code>.apply()</code></p> <p>-&gt; <code>.piecewise_linear()</code></p> <p>-&gt; <code>.piecewise_constant()</code></p> <p>-&gt; <code>.fn()</code></p> <li> <p>Possible Next : <p>-&gt; <code>.rydberg</code>     :: Create/Switch to new rydberg level coupling channel</p> <p>-&gt; <code>.hyperfine</code>     :: Create/Switch to new hyperfine level coupling channel</p> <li> <p>Possible Next : <p>-&gt; <code>.assign()</code>     :: assign varialbe an actual value/number</p> <p>-&gt; <code>.batch_assign()</code>     :: create batch job with different sets     of values assign to each variable.</p> <li> <p>Possible Next : <p>-&gt; <code>.quera</code>     :: specify QuEra backend</p> <p>-&gt; <code>.braket</code>     :: specify QuEra backend</p> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef slice(\nself,\nstart: Optional[ScalarType] = None,\nstop: Optional[ScalarType] = None,\n) -&gt; \"Slice\":\n\"\"\"\n    Slice current waveform\n    Possible Next:\n    - Possible Next &lt;Location&gt;:\n        -&gt; `.location(int)`\n            :: creating new channel to address\n            another location(s)\n    - Possible Next &lt;WaveForm:: current&gt;:\n        -&gt; `.record(str)`\n            :: record the value of waveform at current time\n    - Possible Next &lt;WaveForm:: append&gt;:\n        :: Append waveform into current channel\n        -&gt; `.linear()`\n        -&gt; `.constant()`\n        -&gt; `.ploy()`\n        -&gt; `.apply()`\n        -&gt; `.piecewise_linear()`\n        -&gt; `.piecewise_constant()`\n        -&gt; `.fn()`\n    - Possible Next &lt;LevelCoupling&gt;:\n        -&gt; `.rydberg`\n            :: Create/Switch to new rydberg level coupling channel\n        -&gt; `.hyperfine`\n            :: Create/Switch to new hyperfine level coupling channel\n    - Possible Next &lt;Emit:: Linking Vars&gt;:\n        -&gt; `.assign()`\n            :: assign varialbe an actual value/number\n        -&gt; `.batch_assign()`\n            :: create batch job with different sets\n            of values assign to each variable.\n    - Possible Next &lt;Backend&gt;:\n        -&gt; `.quera`\n            :: specify QuEra backend\n        -&gt; `.braket`\n            :: specify QuEra backend\n    \"\"\"\nreturn Slice(start, stop, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable","title":"WaveformAttachable","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.apply","title":"apply","text":"<pre><code>apply(wf)\n</code></pre> <p>Apply a pre-defined waveform to the current location.</p> <p>Parameters:</p> Name Type Description Default <code>wf</code> <code>Waveform</code> <p>the waveform</p> required <p>Examples:</p> <ul> <li>apply a pre-defined waveform object to current sequence.</li> </ul> <pre><code>&gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n&gt;&gt;&gt; wv = bloqade.ir.Linear(0,10,0.5)\n&gt;&gt;&gt; node = node.apply(wv)\n</code></pre> <p>Possible Next:</p> <ul> <li> <p>Possible Next : <p>-&gt; <code>.location(int)</code>     :: creating new channel to address another location(s)</p> <li> <p>Possible Next : <p>-&gt; <code>.slice()</code>     :: slice current waveform</p> <p>-&gt; <code>.record(str)</code>     :: record the value of waveform at current time</p> <li> <p>Possible Next : <p>:: Append waveform into current channel</p> <p>-&gt; <code>.linear()</code></p> <p>-&gt; <code>.constant()</code></p> <p>-&gt; <code>.ploy()</code></p> <p>-&gt; <code>.apply()</code></p> <p>-&gt; <code>.piecewise_linear()</code></p> <p>-&gt; <code>.piecewise_constant()</code></p> <p>-&gt; <code>.fn()</code></p> <li> <p>Possible Next : <p>-&gt; <code>.rydberg</code>     :: Create/Switch to new rydberg level coupling channel</p> <p>-&gt; <code>.hyperfine</code>     :: Create/Switch to new hyperfine level coupling channel</p> <li> <p>Possible Next : <p>-&gt; <code>.assign()</code>     :: assign varialbe an actual value/number</p> <p>-&gt; <code>.batch_assign()</code>     :: create batch job with different sets     of values assign to each variable.</p> <li> <p>Possible Next : <p>-&gt; <code>.quera</code>     :: specify QuEra backend</p> <p>-&gt; <code>.braket</code>     :: specify QuEra backend</p> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef apply(self, wf: ir.Waveform) -&gt; \"Apply\":\n\"\"\"\n    Apply a pre-defined waveform to the current location.\n    Args:\n        wf (ir.Waveform): the waveform\n    Examples:\n        - apply a pre-defined waveform object to current sequence.\n        &gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n        &gt;&gt;&gt; wv = bloqade.ir.Linear(0,10,0.5)\n        &gt;&gt;&gt; node = node.apply(wv)\n    Possible Next:\n    - Possible Next &lt;Location&gt;:\n        -&gt; `.location(int)`\n            :: creating new channel to address another location(s)\n    - Possible Next &lt;WaveForm:: current&gt;:\n        -&gt; `.slice()`\n            :: slice current waveform\n        -&gt; `.record(str)`\n            :: record the value of waveform at current time\n    - Possible Next &lt;WaveForm:: append&gt;:\n        :: Append waveform into current channel\n        -&gt; `.linear()`\n        -&gt; `.constant()`\n        -&gt; `.ploy()`\n        -&gt; `.apply()`\n        -&gt; `.piecewise_linear()`\n        -&gt; `.piecewise_constant()`\n        -&gt; `.fn()`\n    - Possible Next &lt;LevelCoupling&gt;:\n        -&gt; `.rydberg`\n            :: Create/Switch to new rydberg level coupling channel\n        -&gt; `.hyperfine`\n            :: Create/Switch to new hyperfine level coupling channel\n    - Possible Next &lt;Emit:: Linking Vars&gt;:\n        -&gt; `.assign()`\n            :: assign varialbe an actual value/number\n        -&gt; `.batch_assign()`\n            :: create batch job with different sets\n            of values assign to each variable.\n    - Possible Next &lt;Backend&gt;:\n        -&gt; `.quera`\n            :: specify QuEra backend\n        -&gt; `.braket`\n            :: specify QuEra backend\n    \"\"\"\nreturn Apply(wf, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.constant","title":"constant","text":"<pre><code>constant(value, duration)\n</code></pre> <p>Append/assign a constant waveform to the current location.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ScalarType Union[float, str]</code> <p>The value of the waveform</p> required <code>duration</code> <code>ScalarType Union[float, str]</code> <p>The duration of the waveform</p> required <p>Examples:</p> <ul> <li>specify a constant waveform of value 1 with duration 0.5 for (spatial) uniform rydberg detuning</li> </ul> <pre><code>&gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n&gt;&gt;&gt; node = node.constant(value=1,duration=0.5)\n</code></pre> <p>Possible Next:</p> <ul> <li> <p>Possible Next : <p>-&gt; <code>.location(int)</code>     :: creating new channel to address another location(s)</p> <li> <p>Possible Next : <p>-&gt; <code>.slice()</code>     :: slice current waveform</p> <p>-&gt; <code>.record(str)</code>     :: record the value of waveform at current time</p> <li> <p>Possible Next : <p>:: Append waveform into current channel</p> <p>-&gt; <code>.linear()</code></p> <p>-&gt; <code>.constant()</code></p> <p>-&gt; <code>.ploy()</code></p> <p>-&gt; <code>.apply()</code></p> <p>-&gt; <code>.piecewise_linear()</code></p> <p>-&gt; <code>.piecewise_constant()</code></p> <p>-&gt; <code>.fn()</code></p> <li> <p>Possible Next : <p>-&gt; <code>.rydberg</code>     :: Create/Switch to new rydberg level coupling channel</p> <p>-&gt; <code>.hyperfine</code>     :: Create/Switch to new hyperfine level coupling channel</p> <li> <p>Possible Next : <p>-&gt; <code>.assign()</code>     :: assign varialbe an actual value/number</p> <p>-&gt; <code>.batch_assign()</code>     :: create batch job with different sets     of values assign to each variable.</p> <li> <p>Possible Next : <p>-&gt; <code>.quera</code>     :: specify QuEra backend</p> <p>-&gt; <code>.braket</code>     :: specify QuEra backend</p> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef constant(self, value: ScalarType, duration: ScalarType) -&gt; \"Constant\":\n\"\"\"\n    Append/assign a constant waveform to the current location.\n    Args:\n        value (ScalarType Union[float, str]): The value of the waveform\n        duration (ScalarType Union[float, str]): The duration of the waveform\n    Examples:\n        - specify a constant waveform of value 1 with duration 0.5\n        for (spatial) uniform rydberg detuning\n        &gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n        &gt;&gt;&gt; node = node.constant(value=1,duration=0.5)\n    Possible Next:\n    - Possible Next &lt;Location&gt;:\n        -&gt; `.location(int)`\n            :: creating new channel to address another location(s)\n    - Possible Next &lt;WaveForm:: current&gt;:\n        -&gt; `.slice()`\n            :: slice current waveform\n        -&gt; `.record(str)`\n            :: record the value of waveform at current time\n    - Possible Next &lt;WaveForm:: append&gt;:\n        :: Append waveform into current channel\n        -&gt; `.linear()`\n        -&gt; `.constant()`\n        -&gt; `.ploy()`\n        -&gt; `.apply()`\n        -&gt; `.piecewise_linear()`\n        -&gt; `.piecewise_constant()`\n        -&gt; `.fn()`\n    - Possible Next &lt;LevelCoupling&gt;:\n        -&gt; `.rydberg`\n            :: Create/Switch to new rydberg level coupling channel\n        -&gt; `.hyperfine`\n            :: Create/Switch to new hyperfine level coupling channel\n    - Possible Next &lt;Emit:: Linking Vars&gt;:\n        -&gt; `.assign()`\n            :: assign varialbe an actual value/number\n        -&gt; `.batch_assign()`\n            :: create batch job with different sets\n            of values assign to each variable.\n    - Possible Next &lt;Backend&gt;:\n        -&gt; `.quera`\n            :: specify QuEra backend\n        -&gt; `.braket`\n            :: specify QuEra backend\n    \"\"\"\nreturn Constant(value, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.fn","title":"fn","text":"<pre><code>fn(fn, duration)\n</code></pre> <p>Append/assign a waveform defined by a python function to the current location.</p> <p>This function create a waveform with user-defined python function <code>fn(t)</code> with duration <code>duration</code>.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable</code> <p>The python function defining the waveform</p> required <code>duration</code> <code>ScalarType</code> <p>The durations of each constant segment</p> required Note <ul> <li>ScalarType can be either float or str.</li> <li>The python function should take a single argument <code>t</code> and return a float.</li> </ul> <p>Examples:</p> <ul> <li>create a cosine waveform with duration 0.5 for (spatial) uniform rydberg detuning.</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; def my_fn(t):\n&gt;&gt;&gt;     return np.cos(2*np.pi*t)\n&gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n&gt;&gt;&gt; node = node.fn(my_fn,duration=0.5)\n</code></pre> <p>Possible Next:</p> <ul> <li> <p>Possible Next : <p>-&gt; <code>.location(int)</code>     :: creating new channel to address another location(s)</p> <li> <p>Possible Next : <p>-&gt; <code>.slice()</code>     :: slice current waveform</p> <p>-&gt; <code>.record(str)</code>     :: record the value of waveform at current time</p> <p>-&gt; <code>.sample()</code>     :: sample current callable at given time points</p> <li> <p>Possible Next : <p>:: Append waveform into current channel</p> <p>-&gt; <code>.linear()</code></p> <p>-&gt; <code>.constant()</code></p> <p>-&gt; <code>.ploy()</code></p> <p>-&gt; <code>.apply()</code></p> <p>-&gt; <code>.piecewise_linear()</code></p> <p>-&gt; <code>.piecewise_constant()</code></p> <p>-&gt; <code>.fn()</code></p> <li> <p>Possible Next : <p>-&gt; <code>.rydberg</code>     :: Create/Switch to new rydberg level coupling channel</p> <p>-&gt; <code>.hyperfine</code>     :: Create/Switch to new hyperfine level coupling channel</p> <li> <p>Possible Next : <p>-&gt; <code>.assign()</code>     :: assign varialbe an actual value/number</p> <p>-&gt; <code>.batch_assign()</code>     :: create batch job with different sets     of values assign to each variable.</p> <li> <p>Possible Next : <p>-&gt; <code>.quera</code>     :: specify QuEra backend</p> <p>-&gt; <code>.braket</code>     :: specify QuEra backend</p> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef fn(self, fn: Callable, duration: ScalarType) -&gt; \"Fn\":\n\"\"\"\n    Append/assign a waveform defined by a python function to the current location.\n    This function create a waveform with user-defined\n    python function `fn(t)` with duration `duration`.\n    Args:\n        fn (Callable): The python function defining the waveform\n        duration (ScalarType): The durations of each constant segment\n    Note:\n        - ScalarType can be either float or str.\n        - The python function should take a single argument `t` and return a float.\n    Examples:\n        - create a cosine waveform with duration 0.5\n        for (spatial) uniform rydberg detuning.\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; def my_fn(t):\n        &gt;&gt;&gt;     return np.cos(2*np.pi*t)\n        &gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n        &gt;&gt;&gt; node = node.fn(my_fn,duration=0.5)\n    Possible Next:\n    - Possible Next &lt;Location&gt;:\n        -&gt; `.location(int)`\n            :: creating new channel to address another location(s)\n    - Possible Next &lt;WaveForm:: current&gt;:\n        -&gt; `.slice()`\n            :: slice current waveform\n        -&gt; `.record(str)`\n            :: record the value of waveform at current time\n        -&gt; `.sample()`\n            :: sample current callable at given time points\n    - Possible Next &lt;WaveForm:: append&gt;:\n        :: Append waveform into current channel\n        -&gt; `.linear()`\n        -&gt; `.constant()`\n        -&gt; `.ploy()`\n        -&gt; `.apply()`\n        -&gt; `.piecewise_linear()`\n        -&gt; `.piecewise_constant()`\n        -&gt; `.fn()`\n    - Possible Next &lt;LevelCoupling&gt;:\n        -&gt; `.rydberg`\n            :: Create/Switch to new rydberg level coupling channel\n        -&gt; `.hyperfine`\n            :: Create/Switch to new hyperfine level coupling channel\n    - Possible Next &lt;Emit:: Linking Vars&gt;:\n        -&gt; `.assign()`\n            :: assign varialbe an actual value/number\n        -&gt; `.batch_assign()`\n            :: create batch job with different sets\n            of values assign to each variable.\n    - Possible Next &lt;Backend&gt;:\n        -&gt; `.quera`\n            :: specify QuEra backend\n        -&gt; `.braket`\n            :: specify QuEra backend\n    \"\"\"\nreturn Fn(fn, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.linear","title":"linear","text":"<pre><code>linear(start, stop, duration)\n</code></pre> <p>Append/assign a linear waveform to the current location.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>ScalarType Union[float, str]</code> <p>The start value of the waveform</p> required <code>stop</code> <code>ScalarType Union[float, str]</code> <p>The stop value of the waveform</p> required <code>duration</code> <code>ScalarType Union[float, str]</code> <p>The duration of the waveform</p> required <p>Examples:</p> <ul> <li>specify a linear waveform for (spatial) uniform rydberg detuning from 0 to 1 in 0.5 us.</li> </ul> <pre><code>&gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n&gt;&gt;&gt; node = node.linear(start=0,stop=1,duration=0.5)\n</code></pre> <p>Possible Next:</p> <ul> <li> <p>Possible Next : <p>-&gt; <code>.location(int)</code>     :: creating new channel to address another location(s)</p> <li> <p>Possible Next : <p>-&gt; <code>.slice()</code>     :: slice current waveform</p> <p>-&gt; <code>.record(str)</code>     :: record the value of waveform at current time</p> <li> <p>Possible Next : <p>:: Append waveform into current channel</p> <p>-&gt; <code>.linear()</code></p> <p>-&gt; <code>.constant()</code></p> <p>-&gt; <code>.ploy()</code></p> <p>-&gt; <code>.apply()</code></p> <p>-&gt; <code>.piecewise_linear()</code></p> <p>-&gt; <code>.piecewise_constant()</code></p> <p>-&gt; <code>.fn()</code></p> <li> <p>Possible Next : <p>-&gt; <code>.rydberg</code>     :: Create/Switch to new rydberg level coupling channel</p> <p>-&gt; <code>.hyperfine</code>     :: Create/Switch to new hyperfine level coupling channel</p> <li> <p>Possible Next : <p>-&gt; <code>.assign()</code>     :: assign varialbe an actual value/number</p> <p>-&gt; <code>.batch_assign()</code>     :: create batch job with different     sets of values assign to each variable.</p> <li> <p>Possible Next : <p>-&gt; <code>.quera</code>     :: specify QuEra backend</p> <p>-&gt; <code>.braket</code>     :: specify QuEra backend</p> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef linear(\nself, start: ScalarType, stop: ScalarType, duration: ScalarType\n) -&gt; \"Linear\":\n\"\"\"\n    Append/assign a linear waveform to the current location.\n    Args:\n        start (ScalarType Union[float, str]): The start value of the waveform\n        stop (ScalarType Union[float, str]): The stop value of the waveform\n        duration (ScalarType Union[float, str]): The duration of the waveform\n    Examples:\n        - specify a linear waveform for (spatial) uniform rydberg detuning\n        from 0 to 1 in 0.5 us.\n        &gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n        &gt;&gt;&gt; node = node.linear(start=0,stop=1,duration=0.5)\n    Possible Next:\n    - Possible Next &lt;Location&gt;:\n        -&gt; `.location(int)`\n            :: creating new channel to address another location(s)\n    - Possible Next &lt;WaveForm:: current&gt;:\n        -&gt; `.slice()`\n            :: slice current waveform\n        -&gt; `.record(str)`\n            :: record the value of waveform at current time\n    - Possible Next &lt;WaveForm:: append&gt;:\n        :: Append waveform into current channel\n        -&gt; `.linear()`\n        -&gt; `.constant()`\n        -&gt; `.ploy()`\n        -&gt; `.apply()`\n        -&gt; `.piecewise_linear()`\n        -&gt; `.piecewise_constant()`\n        -&gt; `.fn()`\n    - Possible Next &lt;LevelCoupling&gt;:\n        -&gt; `.rydberg`\n            :: Create/Switch to new rydberg level coupling channel\n        -&gt; `.hyperfine`\n            :: Create/Switch to new hyperfine level coupling channel\n    - Possible Next &lt;Emit:: Linking Vars&gt;:\n        -&gt; `.assign()`\n            :: assign varialbe an actual value/number\n        -&gt; `.batch_assign()`\n            :: create batch job with different\n            sets of values assign to each variable.\n    - Possible Next &lt;Backend&gt;:\n        -&gt; `.quera`\n            :: specify QuEra backend\n        -&gt; `.braket`\n            :: specify QuEra backend\n    \"\"\"\nreturn Linear(start, stop, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.piecewise_constant","title":"piecewise_constant","text":"<pre><code>piecewise_constant(durations, values)\n</code></pre> <p>Append/assign a piecewise constant waveform to the current location. The durations should have number of elements = len(values).</p> <p>This function create a waveform of piecewise_constant of <code>values[i]</code> with duration <code>durations[i]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The durations of each constant segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values of each constant segment</p> required Note <p>ScalarType can be either float or str.</p> <p>Examples:</p> <ul> <li>specify a piecewise constant of [0.5,1.5] with duration [0.1,3.8] for (spatial) uniform rydberg detuning.</li> </ul> <pre><code>&gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n&gt;&gt;&gt; node = node.piecewise_constant(values=[0.5,1.5],durations=[0.1,3.8])\n</code></pre> <p>Possible Next:</p> <ul> <li> <p>Possible Next : <p>-&gt; <code>.location(int)</code>     :: creating new channel to address another location(s)</p> <li> <p>Possible Next : <p>-&gt; <code>.slice()</code>     :: slice current waveform</p> <p>-&gt; <code>.record(str)</code>     :: record the value of waveform at current time</p> <li> <p>Possible Next : <p>:: Append waveform into current channel</p> <p>-&gt; <code>.linear()</code></p> <p>-&gt; <code>.constant()</code></p> <p>-&gt; <code>.ploy()</code></p> <p>-&gt; <code>.apply()</code></p> <p>-&gt; <code>.piecewise_linear()</code></p> <p>-&gt; <code>.piecewise_constant()</code></p> <p>-&gt; <code>.fn()</code></p> <li> <p>Possible Next : <p>-&gt; <code>.rydberg</code>     :: Create/Switch to new rydberg level coupling channel</p> <p>-&gt; <code>.hyperfine</code>     :: Create/Switch to new hyperfine level coupling channel</p> <li> <p>Possible Next : <p>-&gt; <code>.assign()</code>     :: assign varialbe an actual value/number</p> <p>-&gt; <code>.batch_assign()</code>     :: create batch job with different sets     of values assign to each variable.</p> <li> <p>Possible Next : <p>-&gt; <code>.quera</code>     :: specify QuEra backend</p> <p>-&gt; <code>.braket</code>     :: specify QuEra backend</p> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef piecewise_constant(\nself, durations: List[ScalarType], values: List[ScalarType]\n) -&gt; \"PiecewiseConstant\":\n\"\"\"\n    Append/assign a piecewise constant waveform to the current location.\n    The durations should have number of elements = len(values).\n    This function create a waveform of piecewise_constant of\n    `values[i]` with duration `durations[i]`.\n    Args:\n        durations (List[ScalarType]): The durations of each constant segment\n        values (List[ScalarType]): The values of each constant segment\n    Note:\n        ScalarType can be either float or str.\n    Examples:\n        - specify a piecewise constant of [0.5,1.5] with duration [0.1,3.8]\n        for (spatial) uniform rydberg detuning.\n        &gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n        &gt;&gt;&gt; node = node.piecewise_constant(values=[0.5,1.5],durations=[0.1,3.8])\n    Possible Next:\n    - Possible Next &lt;Location&gt;:\n        -&gt; `.location(int)`\n            :: creating new channel to address another location(s)\n    - Possible Next &lt;WaveForm:: current&gt;:\n        -&gt; `.slice()`\n            :: slice current waveform\n        -&gt; `.record(str)`\n            :: record the value of waveform at current time\n    - Possible Next &lt;WaveForm:: append&gt;:\n        :: Append waveform into current channel\n        -&gt; `.linear()`\n        -&gt; `.constant()`\n        -&gt; `.ploy()`\n        -&gt; `.apply()`\n        -&gt; `.piecewise_linear()`\n        -&gt; `.piecewise_constant()`\n        -&gt; `.fn()`\n    - Possible Next &lt;LevelCoupling&gt;:\n        -&gt; `.rydberg`\n            :: Create/Switch to new rydberg level coupling channel\n        -&gt; `.hyperfine`\n            :: Create/Switch to new hyperfine level coupling channel\n    - Possible Next &lt;Emit:: Linking Vars&gt;:\n        -&gt; `.assign()`\n            :: assign varialbe an actual value/number\n        -&gt; `.batch_assign()`\n            :: create batch job with different sets\n            of values assign to each variable.\n    - Possible Next &lt;Backend&gt;:\n        -&gt; `.quera`\n            :: specify QuEra backend\n        -&gt; `.braket`\n            :: specify QuEra backend\n    \"\"\"\nreturn PiecewiseConstant(durations, values, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.piecewise_linear","title":"piecewise_linear","text":"<pre><code>piecewise_linear(durations, values)\n</code></pre> <p>Append/assign a piecewise linear waveform to the current location. The durations should have number of elements = len(values) - 1.</p> <p>This function create a waveform by connecting <code>values[i], values[i+1]</code> with linear segments.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The durations of each linear segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values of each linear segment</p> required <p>Examples:</p> <ul> <li>specify a piecewise linear of [0,1,1,0] with duration [0.1,3.8,0.1] for (spatial) uniform rydberg detuning.</li> </ul> <pre><code>&gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n&gt;&gt;&gt; node = node.piecewise_linear(values=[0,1,1,0],durations=[0.1,3.8,0.1])\n</code></pre> Note <p>ScalarType can be either float or str.</p> <p>Possible Next:</p> <ul> <li> <p>Possible Next : <p>-&gt; <code>.location(int)</code>     :: creating new channel to address another location(s)</p> <li> <p>Possible Next : <p>-&gt; <code>.slice()</code>     :: slice current waveform</p> <p>-&gt; <code>.record(str)</code>     :: record the value of waveform at current time</p> <li> <p>Possible Next : <p>:: Append waveform into current channel</p> <p>-&gt; <code>.linear()</code></p> <p>-&gt; <code>.constant()</code></p> <p>-&gt; <code>.ploy()</code></p> <p>-&gt; <code>.apply()</code></p> <p>-&gt; <code>.piecewise_linear()</code></p> <p>-&gt; <code>.piecewise_constant()</code></p> <p>-&gt; <code>.fn()</code></p> <li> <p>Possible Next : <p>-&gt; <code>.rydberg</code>     :: Create/Switch to new rydberg level coupling channel</p> <p>-&gt; <code>.hyperfine</code>     :: Create/Switch to new hyperfine level coupling channel</p> <li> <p>Possible Next : <p>-&gt; <code>.assign()</code>     :: assign varialbe an actual value/number</p> <p>-&gt; <code>.batch_assign()</code>     :: create batch job with different sets     of values assign to each variable.</p> <li> <p>Possible Next : <p>-&gt; <code>.quera</code>     :: specify QuEra backend</p> <p>-&gt; <code>.braket</code>     :: specify QuEra backend</p> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef piecewise_linear(\nself, durations: List[ScalarType], values: List[ScalarType]\n) -&gt; \"PiecewiseLinear\":\n\"\"\"\n    Append/assign a piecewise linear waveform to the current location.\n    The durations should have number of elements = len(values) - 1.\n    This function create a waveform by connecting `values[i], values[i+1]`\n    with linear segments.\n    Args:\n        durations (List[ScalarType]): The durations of each linear segment\n        values (List[ScalarType]): The values of each linear segment\n    Examples:\n        - specify a piecewise linear of [0,1,1,0] with duration [0.1,3.8,0.1]\n        for (spatial) uniform rydberg detuning.\n        &gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n        &gt;&gt;&gt; node = node.piecewise_linear(values=[0,1,1,0],durations=[0.1,3.8,0.1])\n    Note:\n        ScalarType can be either float or str.\n    Possible Next:\n    - Possible Next &lt;Location&gt;:\n        -&gt; `.location(int)`\n            :: creating new channel to address another location(s)\n    - Possible Next &lt;WaveForm:: current&gt;:\n        -&gt; `.slice()`\n            :: slice current waveform\n        -&gt; `.record(str)`\n            :: record the value of waveform at current time\n    - Possible Next &lt;WaveForm:: append&gt;:\n        :: Append waveform into current channel\n        -&gt; `.linear()`\n        -&gt; `.constant()`\n        -&gt; `.ploy()`\n        -&gt; `.apply()`\n        -&gt; `.piecewise_linear()`\n        -&gt; `.piecewise_constant()`\n        -&gt; `.fn()`\n    - Possible Next &lt;LevelCoupling&gt;:\n        -&gt; `.rydberg`\n            :: Create/Switch to new rydberg level coupling channel\n        -&gt; `.hyperfine`\n            :: Create/Switch to new hyperfine level coupling channel\n    - Possible Next &lt;Emit:: Linking Vars&gt;:\n        -&gt; `.assign()`\n            :: assign varialbe an actual value/number\n        -&gt; `.batch_assign()`\n            :: create batch job with different sets\n            of values assign to each variable.\n    - Possible Next &lt;Backend&gt;:\n        -&gt; `.quera`\n            :: specify QuEra backend\n        -&gt; `.braket`\n            :: specify QuEra backend\n    \"\"\"\nreturn PiecewiseLinear(durations, values, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.poly","title":"poly","text":"<pre><code>poly(coeffs, duration)\n</code></pre> <p>Append/assign a waveform with polynomial profile to the current location. with form:</p> <pre><code>wv(t) = coeffs[0] + coeffs[1]*t + coeffs[2]*t^2 + ... + coeffs[n]*t^n\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>ScalarType Union[float, str]</code> <p>The coefficients of the polynomial</p> required <code>duration</code> <code>ScalarType Union[float, str]</code> <p>The duration of the waveform</p> required <p>Examples:</p> <ul> <li>specify a second order polynomial with duration 0.5 for (spatial) uniform rydberg detuning</li> </ul> <pre><code>&gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n&gt;&gt;&gt; node = node.poly(coeffs=[1,2,3],duration=0.5)\n</code></pre> <p>Possible Next:</p> <ul> <li> <p>Possible Next : <p>-&gt; <code>.location(int)</code>     :: creating new channel to address another location(s)</p> <li> <p>Possible Next : <p>-&gt; <code>.slice()</code>     :: slice current waveform</p> <p>-&gt; <code>.record(str)</code>     :: record the value of waveform at current time</p> <li> <p>Possible Next : <p>:: Append waveform into current channel</p> <p>-&gt; <code>.linear()</code></p> <p>-&gt; <code>.constant()</code></p> <p>-&gt; <code>.ploy()</code></p> <p>-&gt; <code>.apply()</code></p> <p>-&gt; <code>.piecewise_linear()</code></p> <p>-&gt; <code>.piecewise_constant()</code></p> <p>-&gt; <code>.fn()</code></p> <li> <p>Possible Next : <p>-&gt; <code>.rydberg</code>     :: Create/Switch to new rydberg level coupling channel</p> <p>-&gt; <code>.hyperfine</code>     :: Create/Switch to new hyperfine level coupling channel</p> <li> <p>Possible Next : <p>-&gt; <code>.assign()</code>     :: assign varialbe an actual value/number</p> <p>-&gt; <code>.batch_assign()</code>     :: create batch job with different sets     of values assign to each variable.</p> <li> <p>Possible Next : <p>-&gt; <code>.quera</code>     :: specify QuEra backend</p> <p>-&gt; <code>.braket</code>     :: specify QuEra backend</p> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef poly(self, coeffs: List[ScalarType], duration: ScalarType) -&gt; \"Poly\":\n\"\"\"\n    Append/assign a waveform with polynomial profile to the current location.\n    with form:\n        wv(t) = coeffs[0] + coeffs[1]*t + coeffs[2]*t^2 + ... + coeffs[n]*t^n\n    Args:\n        coeffs (ScalarType Union[float, str]): The coefficients of the polynomial\n        duration (ScalarType Union[float, str]): The duration of the waveform\n    Examples:\n        - specify a second order polynomial with duration 0.5\n        for (spatial) uniform rydberg detuning\n        &gt;&gt;&gt; node = bloqade.start.rydberg.detuning.uniform\n        &gt;&gt;&gt; node = node.poly(coeffs=[1,2,3],duration=0.5)\n    Possible Next:\n    - Possible Next &lt;Location&gt;:\n        -&gt; `.location(int)`\n            :: creating new channel to address another location(s)\n    - Possible Next &lt;WaveForm:: current&gt;:\n        -&gt; `.slice()`\n            :: slice current waveform\n        -&gt; `.record(str)`\n            :: record the value of waveform at current time\n    - Possible Next &lt;WaveForm:: append&gt;:\n        :: Append waveform into current channel\n        -&gt; `.linear()`\n        -&gt; `.constant()`\n        -&gt; `.ploy()`\n        -&gt; `.apply()`\n        -&gt; `.piecewise_linear()`\n        -&gt; `.piecewise_constant()`\n        -&gt; `.fn()`\n    - Possible Next &lt;LevelCoupling&gt;:\n        -&gt; `.rydberg`\n            :: Create/Switch to new rydberg level coupling channel\n        -&gt; `.hyperfine`\n            :: Create/Switch to new hyperfine level coupling channel\n    - Possible Next &lt;Emit:: Linking Vars&gt;:\n        -&gt; `.assign()`\n            :: assign varialbe an actual value/number\n        -&gt; `.batch_assign()`\n            :: create batch job with different sets\n            of values assign to each variable.\n    - Possible Next &lt;Backend&gt;:\n        -&gt; `.quera`\n            :: specify QuEra backend\n        -&gt; `.braket`\n            :: specify QuEra backend\n    \"\"\"\nreturn Poly(coeffs, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/backend/","title":"Index","text":""},{"location":"reference/bloqade/builder/backend/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeDeviceRoute","title":"BloqadeDeviceRoute","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeDeviceRoute.python","title":"python","text":"<pre><code>python()\n</code></pre> <ul> <li>Specify bloqade python backend</li> <li> <p>Possible Next:</p> <p>-&gt; <code>...python().run(shots, ...)</code>     :: Run the current program using bloqade python backend</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/bloqade.py</code> <pre><code>def python(self):\n\"\"\"\n    - Specify bloqade python backend\n    - Possible Next:\n        -&gt; `...python().run(shots, ...)`\n            :: Run the current program using bloqade python backend\n    \"\"\"\nfrom bloqade.ir.routine.bloqade import BloqadeServiceOptions\nreturn BloqadeServiceOptions(self).python()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeService","title":"BloqadeService","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeService.bloqade","title":"bloqade  <code>property</code>","text":"<pre><code>bloqade\n</code></pre> <ul> <li>Specify bloqade emulator</li> <li> <p>Possible Next:</p> <p>-&gt; <code>...bloqade.python</code>     :: Bloqade python backend</p> <p>-&gt; <code>...bloqade.julia</code>     :: Bloqade julia backend</p> </li> </ul>"},{"location":"reference/bloqade/builder/backend/braket/","title":"Braket","text":""},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute","title":"BraketDeviceRoute","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute.aquila","title":"aquila","text":"<pre><code>aquila()\n</code></pre> <p>Specify QuEra's Aquila QPU</p> Return <p>BraketHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/braket.py</code> <pre><code>def aquila(self):\n\"\"\"\n    Specify QuEra's Aquila QPU\n    Return:\n        BraketHardwareRoutine\n    - Possible Next:\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n    \"\"\"\nfrom bloqade.ir.routine.base import Routine\nreturn Routine(self).braket.aquila()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute.local_emulator","title":"local_emulator","text":"<pre><code>local_emulator()\n</code></pre> <p>Using Braket local emulator</p> Return <p>BraketLocalEmulatorRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...local_emulator().run</code>     :: run on local emulator</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/braket.py</code> <pre><code>def local_emulator(self):\n\"\"\"\n    Using Braket local emulator\n    Return:\n        BraketLocalEmulatorRoutine\n    - Possible Next:\n        -&gt; `...local_emulator().run`\n            :: run on local emulator\n    \"\"\"\nfrom bloqade.ir.routine.base import Routine\nreturn Routine(self).braket.local_emulator()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketService","title":"BraketService","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketService.braket","title":"braket  <code>property</code>","text":"<pre><code>braket\n</code></pre> <ul> <li>Specify braket service</li> <li> <p>Possible Next:</p> <p>-&gt; <code>...braket.aquila</code>     :: Aquila QPU, via braket service</p> <p>-&gt; <code>...braket.local_emulator</code>     :: braket local emulator backend</p> </li> </ul>"},{"location":"reference/bloqade/builder/backend/quera/","title":"Quera","text":""},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute","title":"QuEraDeviceRoute","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.aquila","title":"aquila","text":"<pre><code>aquila()\n</code></pre> <p>Specify QuEra's Aquila QPU</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def aquila(self):\n\"\"\"\n    Specify QuEra's Aquila QPU\n    Return:\n        QuEraHardwareRoutine\n    - Possible Next:\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n    \"\"\"\nfrom bloqade.ir.routine.base import Routine\nreturn Routine(self).quera.aquila()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.cloud_mock","title":"cloud_mock","text":"<pre><code>cloud_mock()\n</code></pre> <p>Specify QuEra's Remote Mock QPU</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def cloud_mock(self):\n\"\"\"\n    Specify QuEra's Remote Mock QPU\n    Return:\n        QuEraHardwareRoutine\n    - Possible Next:\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n    \"\"\"\nfrom bloqade.ir.routine.base import Routine\nreturn Routine(self).quera.cloud_mock()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.device","title":"device","text":"<pre><code>device(config_file=None, **api_config)\n</code></pre> <p>Specify QuEra's QPU device,</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>file that speficy the target hardware</p> <code>None</code> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...device().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...device().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...device().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def device(self, config_file: Optional[str] = None, **api_config):\n\"\"\"\n    Specify QuEra's QPU device,\n    Args:\n        config_file (str): file that speficy the target hardware\n    Return:\n        QuEraHardwareRoutine\n    - Possible Next:\n        -&gt; `...device().submit`\n            :: submit aync remote job\n        -&gt; `...device().run`\n            :: submit job and wait until job finished\n            and results returned\n        -&gt; `...device().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n    \"\"\"\nfrom bloqade.ir.routine.base import Routine\nreturn Routine(self).quera.device(config_file, **api_config)\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.mock","title":"mock","text":"<pre><code>mock(state_file='.mock_state.txt')\n</code></pre> <p>Specify mock, testing locally.</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def mock(self, state_file: str = \".mock_state.txt\"):\n\"\"\"\n    Specify mock, testing locally.\n    Return:\n        QuEraHardwareRoutine\n    - Possible Next:\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n    \"\"\"\nfrom bloqade.ir.routine.base import Routine\nreturn Routine(self).quera.mock(state_file)\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraService","title":"QuEraService","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraService.quera","title":"quera  <code>property</code>","text":"<pre><code>quera\n</code></pre> <ul> <li>Specify Quera backend</li> <li> <p>Possible Next:</p> <p>-&gt; <code>...quera.aquila</code>     :: Aquila QPU</p> <p>-&gt; <code>...quera.mock</code>     :: mock backend, meant for testings</p> <p>-&gt; <code>...quera.device</code>     :: QuEra QPU, specifiy by config_file</p> </li> </ul>"},{"location":"reference/bloqade/builder/parse/","title":"Index","text":""},{"location":"reference/bloqade/builder/parse/builder/","title":"Builder","text":""},{"location":"reference/bloqade/builder/parse/json/","title":"Json","text":""},{"location":"reference/bloqade/builder/parse/stream/","title":"Stream","text":""},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream","title":"BuilderStream  <code>dataclass</code>","text":"<p>Represents a stream of builder nodes.</p>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream.eat","title":"eat","text":"<pre><code>eat(types, skips=None)\n</code></pre> <p>Scan the stream until a node of type in <code>types</code> or <code>skips</code> is found.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>List[Type[Builder]]</code> <p>List of types to move the stream pointer to</p> required <code>skips</code> <code>List[Type[Builder]] | None</code> <p>List of types to end the</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BuilderNode</code> <code>BuilderNode</code> <p>The beginning of the stream which matches a type in <code>types</code>.</p> Source code in <code>src/bloqade/builder/parse/stream.py</code> <pre><code>def eat(\nself, types: List[Type[Builder]], skips: Optional[List[Type[Builder]]] = None\n) -&gt; BuilderNode:\n\"\"\"Scan the stream until a node of type in `types` or `skips` is found.\n    Args:\n        types (List[Type[Builder]]): List of types to move the stream pointer to\n        skips (List[Type[Builder]] | None, optional): List of types to end the\n        stream scan\n    Returns:\n        BuilderNode: The beginning of the stream which matches a type in `types`.\n    \"\"\"\nhead = self.read_next(types)\ncurr = head\nwhile curr is not None:\nif type(curr.node) not in types:\nif skips and type(curr.node) not in skips:\nbreak\ncurr = curr.next\nself.curr = curr\nreturn head\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/","title":"Trait","text":""},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.CompileJSON","title":"CompileJSON","text":""},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.CompileJSON.json","title":"json","text":"<pre><code>json(**json_options)\n</code></pre> <p>transform the program to a JSON string.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def json(self: \"Builder\", **json_options) -&gt; str:\n\"\"\"transform the program to a JSON string.\"\"\"\nfrom bloqade.builder.parse.json import BuilderSerializer\nreturn json.dumps(self, cls=BuilderSerializer, **json_options)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.Parse","title":"Parse","text":"<p>             Bases: <code>ParseRegister</code>, <code>ParseSequence</code>, <code>ParseCircuit</code>, <code>ParseRoutine</code></p>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.Parse.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>Return the number of atoms in the program.</p>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseCircuit","title":"ParseCircuit","text":""},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseCircuit.parse_circuit","title":"parse_circuit","text":"<pre><code>parse_circuit()\n</code></pre> <p>Parse the analog circuit from the program.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def parse_circuit(self: \"Builder\") -&gt; \"AnalogCircuit\":\n\"\"\"Parse the analog circuit from the program.\"\"\"\nfrom bloqade.builder.parse.builder import Parser\nreturn Parser().parse_circuit(self)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseRegister","title":"ParseRegister","text":""},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseRegister.parse_register","title":"parse_register","text":"<pre><code>parse_register()\n</code></pre> <p>Parse the arrangement of atoms of the program.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def parse_register(self: \"Builder\") -&gt; Union[\"AtomArrangement\", \"ParallelRegister\"]:\n\"\"\"Parse the arrangement of atoms of the program.\"\"\"\nfrom bloqade.builder.parse.builder import Parser\nreturn Parser().parse_register(self)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseRoutine","title":"ParseRoutine","text":"<p>Parse the program to return an AnalogCircuit as well as the parameters for the circuit.</p>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseSequence","title":"ParseSequence","text":""},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseSequence.parse_sequence","title":"parse_sequence","text":"<pre><code>parse_sequence()\n</code></pre> <p>Parse the pulse sequence part of the program.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def parse_sequence(self: \"Builder\") -&gt; \"Sequence\":\n\"\"\"Parse the pulse sequence part of the program.\"\"\"\nfrom bloqade.builder.parse.builder import Parser\nreturn Parser().parse_sequence(self)\n</code></pre>"},{"location":"reference/bloqade/emulate/","title":"Index","text":""},{"location":"reference/bloqade/emulate/sparse_operator/","title":"Sparse operator","text":""},{"location":"reference/bloqade/emulate/ir/","title":"Index","text":""},{"location":"reference/bloqade/emulate/ir/atom_type/","title":"Atom type","text":""},{"location":"reference/bloqade/emulate/ir/emulator/","title":"Emulator","text":""},{"location":"reference/bloqade/emulate/ir/emulator/#bloqade.emulate.ir.emulator.Register","title":"Register  <code>dataclass</code>","text":"<p>This class represents the of the atoms in the system.</p>"},{"location":"reference/bloqade/emulate/ir/space/","title":"Space","text":""},{"location":"reference/bloqade/emulate/ir/state_vector/","title":"State vector","text":""},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.AnalogGate","title":"AnalogGate  <code>dataclass</code>","text":""},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.AnalogGate.run","title":"run","text":"<pre><code>run(\nshots=1,\nsolver_name=\"dop853\",\natol=1e-14,\nrtol=1e-07,\nnsteps=2147483647,\ninteraction_picture=False,\nproject_hyperfine=True,\n)\n</code></pre> <p>Run the emulation with all atoms in the ground state, sampling the final state vector.</p> Source code in <code>src/bloqade/emulate/ir/state_vector.py</code> <pre><code>@beartype\ndef run(\nself,\nshots: int = 1,\nsolver_name: str = \"dop853\",\natol: float = 1e-14,\nrtol: float = 1e-7,\nnsteps: int = 2_147_483_647,\ninteraction_picture: bool = False,\nproject_hyperfine: bool = True,\n):\n\"\"\"Run the emulation with all atoms in the ground state,\n    sampling the final state vector.\"\"\"\noptions = dict(\nsolver_name=solver_name,\natol=atol,\nrtol=rtol,\nnsteps=nsteps,\ninteraction_picture=interaction_picture,\n)\nstate = self.hamiltonian.space.zero_state()\n(result,) = self.apply(state, **options)\nresult /= np.linalg.norm(result)\nreturn self.hamiltonian.space.sample_state_vector(\nresult, shots, project_hyperfine=project_hyperfine\n)\n</code></pre>"},{"location":"reference/bloqade/ir/","title":"Index","text":""},{"location":"reference/bloqade/ir/#bloqade.ir.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <ul> <li>Program starting node</li> <li> <p>Possible Next  <p>-&gt; <code>start.rydberg</code>     :: address rydberg level coupling</p> <p>-&gt; <code>start.hyperfine</code>     :: address hyperfine level coupling</p> <li> <p>Possible Next  <p>-&gt; <code>start.add_locations(List[Tuple[int]])</code>     :: add multiple atoms to current register</p> <p>-&gt; <code>start.add_location(Tuple[int])</code>     :: add atom to current register</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AlignedWaveform","title":"AlignedWaveform","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;padded waveform&gt; ::= &lt;waveform&gt; | &lt;waveform&gt; &lt;alignment&gt; &lt;value&gt;\n&lt;alignment&gt; ::= 'left aligned' | 'right aligned'\n&lt;value&gt; ::= 'left value' | 'right value' | &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AnalogCircuit","title":"AnalogCircuit","text":"<pre><code>AnalogCircuit(register, sequence)\n</code></pre> <p>AnalogCircuit is a dummy type that bundle register and sequence together.</p> Source code in <code>src/bloqade/ir/analog_circuit.py</code> <pre><code>def __init__(\nself,\nregister: Union[\"AtomArrangement\", \"ParallelRegister\"],\nsequence: \"Sequence\",\n):\nself._sequence = sequence\nself._register = register\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AnalogCircuit.register","title":"register  <code>property</code>","text":"<pre><code>register\n</code></pre> <p>Get the register of the program.</p> <p>Returns:</p> Type Description <p>register (Union[\"AtomArrangement\", \"ParallelRegister\"])</p> Note <p>If the program is built with <code>parallelize()</code>, The the register will be a <code>ParallelRegister</code>. Otherwise it will be a <code>AtomArrangement</code>.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AnalogCircuit.sequence","title":"sequence  <code>property</code>","text":"<pre><code>sequence\n</code></pre> <p>Get the sequence of the program.</p> <p>Returns:</p> Name Type Description <code>Sequence</code> <p>the sequence of the program. See also <code>Sequence</code>.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AnalogCircuit.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the program</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the program</p> <code>{}</code> Source code in <code>src/bloqade/ir/analog_circuit.py</code> <pre><code>def show(self, **assignments):\n\"\"\"Interactive visualization of the program\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the program\n    \"\"\"\ndisplay_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement","title":"AtomArrangement","text":"<p>             Bases: <code>ProgramStart</code>, <code>TransformTrait</code></p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n\"\"\"enumerate all locations in the register.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n\"\"\"obtain a figure object from the atom arrangement.\"\"\"\nreturn get_atom_arrangement_figure(self, fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(*shape, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>AtomArrangement</code></p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, *shape: int, lattice_spacing: ScalarType = 1.0):\nself.shape = shape\nself.lattice_spacing = cast(lattice_spacing)\nself.__n_atoms = None\nself.__n_dims = None\nsuper().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices <code>AtomArrangement</code>.</p> <ul> <li><code>Square</code></li> <li><code>Chain</code></li> <li><code>Honeycomb</code></li> <li><code>Triangular</code></li> <li><code>Lieb</code></li> <li><code>Kagome</code></li> <li><code>Rectangular</code></li> </ul>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index)\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n\"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n# damn! this is like stone age broadcasting\nvectors = np.array(self.cell_vectors())\nindex = np.array(index)\npos = np.sum(vectors.T * index, axis=1)\nreturn pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor)\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n\"\"\"Scale the current location with a factor.\n    (x,y) -&gt; factor*(x,y)\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\nfactor = cast(factor)\nobj = self.__new__(type(self))\nfor f in fields(self):\nif f.name == \"lattice_spacing\":\nobj.lattice_spacing = factor * self.lattice_spacing\nelse:\nsetattr(obj, f.name, getattr(self, f.name))\nreturn obj\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Chain","title":"Chain","text":"<pre><code>Chain(L, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\nself, L: int, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\nself.vertical = vertical_chain\nsuper().__init__(L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Constant","title":"Constant","text":"<pre><code>Constant(value, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;constant&gt; ::= 'constant' &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Scalar</code> <p>the constant value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the constant waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, value, duration):\nself.value = cast(value)\nself._duration = cast(duration)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Field","title":"Field","text":"<p>             Bases: <code>FieldExpr</code></p> <p>Field node in the IR. Which contains collection(s) of <code>Waveform</code></p> <pre><code>&lt;field&gt; ::= ('field' &lt;spatial modulation&gt;  &lt;padded waveform&gt;)*\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Field.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Field</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Field</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/field.py</code> <pre><code>def show(self, **assignments):\n\"\"\"\n    Interactive visualization of the Field\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Field\n    \"\"\"\ndisplay_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L * 2.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Kagome","title":"Kagome","text":"<pre><code>Kagome(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Lieb","title":"Lieb","text":"<pre><code>Lieb(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Linear","title":"Linear","text":"<pre><code>Linear(start, stop, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;linear&gt; ::= 'linear' &lt;scalar expr&gt; &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = start + (stop-start)/duration * t</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Scalar</code> <p>start value</p> required <code>stop</code> <code>Scalar</code> <p>stop value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the linear waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, start, stop, duration):\nself.start = cast(start)\nself.stop = cast(stop)\nself._duration = cast(duration)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Literal","title":"Literal","text":"<p>             Bases: <code>Real</code></p>"},{"location":"reference/bloqade/ir/#bloqade.ir.Literal.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre> <p>Scalar Literal, which stores a decimaal value instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>decimal value instance</p> required"},{"location":"reference/bloqade/ir/#bloqade.ir.ParallelRegister","title":"ParallelRegister","text":"<pre><code>ParallelRegister(register, cluster_spacing)\n</code></pre> <p>             Bases: <code>ProgramStart</code></p> <p>Parallel Register</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>@beartype\ndef __init__(self, register: AtomArrangement, cluster_spacing: ScalarType):\nself._register = register\nself._cluster_spacing = cast(cluster_spacing)\nif register.n_atoms &gt; 0:\n# calculate bounding box\n# of this register\nlocation_iter = register.enumerate()\n(x, y) = next(location_iter).position\nx_min = x\nx_max = x\ny_min = y\ny_max = y\nfor location_info in location_iter:\n(x, y) = location_info.position\nx_min = x.min(x_min)\nx_max = x.max(x_max)\ny_min = y.min(y_min)\ny_max = y.max(y_max)\nshift_x = (x_max - x_min) + cluster_spacing\nshift_y = (y_max - y_min) + cluster_spacing\nregister_locations = [\nlist(location_info.position) for location_info in register.enumerate()\n]\nregister_filling = [\nlocation_info.filling.value for location_info in register.enumerate()\n]\nshift_vectors = [[shift_x, cast(0)], [cast(0), shift_y]]\nelse:\nraise ValueError(\"No locations to parallelize.\")\nself.register_locations = register_locations\nself.register_filling = register_filling\nself.shift_vectors = shift_vectors\nsuper().__init__(self)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Poly","title":"Poly","text":"<pre><code>Poly(coeffs, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;poly&gt; ::= &lt;scalar&gt;+\n</code></pre> <p>f(t=0:duration) = c[0] + c[1]t + c[2]t^2 + ... + c[n-1]t^n-1 + c[n]t^n</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>List[Scalar]</code> <p>the coefficients c[] of the polynomial.</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, coeffs, duration):\nself.coeffs = cast(coeffs)\nself._duration = cast(duration)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Pulse","title":"Pulse","text":"<pre><code>Pulse(field_pairs)\n</code></pre> <p>             Bases: <code>PulseExpr</code></p> <pre><code>&lt;pulse&gt; ::= (&lt;field name&gt; &lt;field&gt;)+\n</code></pre> Source code in <code>src/bloqade/ir/control/pulse.py</code> <pre><code>def __init__(self, field_pairs):\nfields = dict()\nfor k, v in field_pairs.items():\nif isinstance(v, Field):\nfields[k] = v\nelif isinstance(v, dict):\nfields[k] = Field(v)\nelse:\nraise TypeError(f\"Expected Field or dict, got {type(v)}\")\nself.fields = fields\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Pulse.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Pulse</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Pulse</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/pulse.py</code> <pre><code>def show(self, **assignments):\n\"\"\"\n    Interactive visualization of the Pulse\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Pulse\n    \"\"\"\ndisplay_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.PythonFn","title":"PythonFn","text":"<pre><code>PythonFn(fn, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;python-fn&gt; ::= 'python-fn' &lt;python function def&gt; &lt;scalar expr&gt;\n</code></pre> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, fn: Callable, duration: Any):\nself.fn = fn\nself._duration = cast(duration)\nsignature = inspect.getfullargspec(fn)\nif signature.varargs is not None:\nraise ValueError(\"Cannot have `*args` in function definition\")\nif signature.varkw is not None:\nraise ValueError(\"Cannot have `**kwargs` in function definition\")\n# get default kwonly first:\nvariables = []\nself.default_param_values = {}\nself.default_arguements = {}\nif signature.kwonlydefaults is not None:\nfor name, value in signature.kwonlydefaults.items():\nif isinstance(value, (Real, Decimal)):\nvariables.append(name)\nself.default_param_values[name] = Decimal(str(value))\nelse:\n# self.default_arguements[name] = value\nraise ValueError(\nf\"Default value for parameter {name} is not Real or Decimal, \"\n\"cannot convert to Variable.\"\n)\nvariables += signature.args[1:]\nvariables += signature.kwonlyargs\nself.parameters = list(map(var, variables))\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Record","title":"Record","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;record&gt; ::= 'record' &lt;waveform&gt; &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\nwidth,\nheight,\nlattice_spacing_x=1.0,\nlattice_spacing_y=None,\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>None</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\nself,\nwidth: int,\nheight: int,\nlattice_spacing_x: ScalarType = 1.0,\nlattice_spacing_y: Optional[ScalarType] = None,\n):\nsuper().__init__(width, height, lattice_spacing=lattice_spacing_x)\nif lattice_spacing_y is None:\nself.ratio = cast(1.0) / cast(lattice_spacing_x)\nelse:\nself.ratio = cast(lattice_spacing_y) / cast(lattice_spacing_x)\nsuper().__init__(width, height, lattice_spacing=lattice_spacing_x)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Sample","title":"Sample","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;sample&gt; ::= 'sample' &lt;waveform&gt; &lt;interpolation&gt; &lt;scalar&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Scalar","title":"Scalar","text":"<p>Base class for all scalar expressions.</p> <pre><code>&lt;scalar&gt; ::= &lt;literal&gt;\n| &lt;variable&gt;\n| &lt;default&gt;\n| &lt;negative&gt;\n| &lt;add&gt;\n| &lt;mul&gt;\n| &lt;min&gt;\n| &lt;max&gt;\n| &lt;slice&gt;\n| &lt;inverval&gt;\n&lt;mul&gt; ::= &lt;scalar&gt; '*' &lt;scalar&gt;\n&lt;add&gt; ::= &lt;scalar&gt; '+' &lt;scalar&gt;\n&lt;min&gt; ::= 'min' &lt;scalar&gt;+\n&lt;max&gt; ::= 'max' &lt;scalar&gt;+\n&lt;slice&gt; ::= &lt;scalar expr&gt; '[' &lt;interval&gt; ']'\n&lt;interval&gt; ::= &lt;scalar expr&gt; '..' &lt;scalar expr&gt;\n&lt;real&gt; ::= &lt;literal&gt; | &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Sequence","title":"Sequence","text":"<pre><code>Sequence(seq_pairs=None)\n</code></pre> <p>             Bases: <code>SequenceExpr</code></p> <p>Sequence of a program, which includes pulses informations.</p> Source code in <code>src/bloqade/ir/control/sequence.py</code> <pre><code>def __init__(self, seq_pairs: Optional[Dict] = None):\nif seq_pairs is None:\nself.pulses = {}\nreturn\npulses = {}\nfor level_coupling, pulse in seq_pairs.items():\nif not isinstance(level_coupling, LevelCoupling):\nraise TypeError(f\"Unexpected type {type(level_coupling)}\")\nif isinstance(pulse, PulseExpr):\npulses[level_coupling] = pulse\nelif isinstance(pulse, dict):\npulses[level_coupling] = Pulse(pulse)\nelse:\nraise TypeError(f\"Unexpected type {type(pulse)}\")\nself.pulses = pulses\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Sequence.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Sequence</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Sequence</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/sequence.py</code> <pre><code>def show(self, **assignments):\n\"\"\"\n    Interactive visualization of the Sequence\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Sequence\n    \"\"\"\ndisplay_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Square","title":"Square","text":"<pre><code>Square(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Triangular","title":"Triangular","text":"<pre><code>Triangular(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Variable","title":"Variable","text":"<p>             Bases: <code>Real</code></p> <p>Variable, which stores a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>variable instance.</p> required"},{"location":"reference/bloqade/ir/#bloqade.ir.Waveform","title":"Waveform","text":"<p>Waveform node in the IR.</p> <ul> <li><code>&lt;instruction&gt;</code></li> <li><code>&lt;smooth&gt;</code></li> <li><code>&lt;slice&gt;</code></li> <li><code>&lt;apppend&gt;</code></li> <li><code>&lt;negative&gt;</code></li> <li><code>&lt;scale&gt;</code></li> <li><code>&lt;add&gt;</code></li> <li><code>&lt;record&gt;</code></li> <li><code>&lt;sample&gt;</code></li> </ul> <pre><code>&lt;waveform&gt; ::= &lt;instruction&gt;\n    | &lt;smooth&gt;\n    | &lt;slice&gt;\n    | &lt;append&gt;\n    | &lt;negative&gt;\n    | &lt;scale&gt;\n    | &lt;add&gt;\n    | &lt;record&gt;\n    | &lt;sample&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Waveform.figure","title":"figure","text":"<pre><code>figure(**assignments)\n</code></pre> <p>get figure of the plotting the waveform.</p> <p>Returns:</p> Name Type Description <code>figure</code> <p>a bokeh figure</p> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def figure(self, **assignments):\n\"\"\"get figure of the plotting the waveform.\n    Returns:\n        figure: a bokeh figure\n    \"\"\"\nreturn get_ir_figure(self, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.cast","title":"cast","text":"<pre><code>cast(py)\n</code></pre> <ol> <li> <p>cast Real number (or list/tuple of Real numbers) to <code>Scalar Literal</code>.</p> </li> <li> <p>cast str (or list/tuple of Real numbers) to <code>Scalar Variable</code>.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, Real, Tuple[Real], List[Real]]</code> <p>python object to cast</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>Scalar</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def cast(py) -&gt; \"Scalar\":\n\"\"\"\n    1. cast Real number (or list/tuple of Real numbers)\n    to [`Scalar Literal`][bloqade.ir.scalar.Literal].\n    2. cast str (or list/tuple of Real numbers)\n    to [`Scalar Variable`][bloqade.ir.scalar.Variable].\n    Args:\n        py (Union[str,Real,Tuple[Real],List[Real]]): python object to cast\n    Returns:\n        Scalar\n    \"\"\"\nret = trycast(py)\nif ret is None:\nraise TypeError(f\"Cannot cast {type(py)} to Scalar Literal\")\nreturn ret\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.var","title":"var","text":"<pre><code>var(py)\n</code></pre> <p>cast string (or list/tuple of strings) to <code>Variable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, List[str]]</code> <p>a string or list/tuple of strings</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>Union[Variable]</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def var(py: str) -&gt; \"Variable\":\n\"\"\"cast string (or list/tuple of strings)\n    to [`Variable`][bloqade.ir.scalar.Variable].\n    Args:\n        py (Union[str, List[str]]): a string or list/tuple of strings\n    Returns:\n       Union[Variable]\n    \"\"\"\nret = tryvar(py)\nif ret is None:\nraise TypeError(f\"Cannot cast {type(py)} to Variable\")\nreturn ret\n</code></pre>"},{"location":"reference/bloqade/ir/analog_circuit/","title":"Analog circuit","text":""},{"location":"reference/bloqade/ir/analog_circuit/#bloqade.ir.analog_circuit.AnalogCircuit","title":"AnalogCircuit","text":"<pre><code>AnalogCircuit(register, sequence)\n</code></pre> <p>AnalogCircuit is a dummy type that bundle register and sequence together.</p> Source code in <code>src/bloqade/ir/analog_circuit.py</code> <pre><code>def __init__(\nself,\nregister: Union[\"AtomArrangement\", \"ParallelRegister\"],\nsequence: \"Sequence\",\n):\nself._sequence = sequence\nself._register = register\n</code></pre>"},{"location":"reference/bloqade/ir/analog_circuit/#bloqade.ir.analog_circuit.AnalogCircuit.register","title":"register  <code>property</code>","text":"<pre><code>register\n</code></pre> <p>Get the register of the program.</p> <p>Returns:</p> Type Description <p>register (Union[\"AtomArrangement\", \"ParallelRegister\"])</p> Note <p>If the program is built with <code>parallelize()</code>, The the register will be a <code>ParallelRegister</code>. Otherwise it will be a <code>AtomArrangement</code>.</p>"},{"location":"reference/bloqade/ir/analog_circuit/#bloqade.ir.analog_circuit.AnalogCircuit.sequence","title":"sequence  <code>property</code>","text":"<pre><code>sequence\n</code></pre> <p>Get the sequence of the program.</p> <p>Returns:</p> Name Type Description <code>Sequence</code> <p>the sequence of the program. See also <code>Sequence</code>.</p>"},{"location":"reference/bloqade/ir/analog_circuit/#bloqade.ir.analog_circuit.AnalogCircuit.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the program</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the program</p> <code>{}</code> Source code in <code>src/bloqade/ir/analog_circuit.py</code> <pre><code>def show(self, **assignments):\n\"\"\"Interactive visualization of the program\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the program\n    \"\"\"\ndisplay_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/scalar/","title":"Scalar","text":""},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Literal","title":"Literal","text":"<p>             Bases: <code>Real</code></p>"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Literal.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre> <p>Scalar Literal, which stores a decimaal value instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>decimal value instance</p> required"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Scalar","title":"Scalar","text":"<p>Base class for all scalar expressions.</p> <pre><code>&lt;scalar&gt; ::= &lt;literal&gt;\n| &lt;variable&gt;\n| &lt;default&gt;\n| &lt;negative&gt;\n| &lt;add&gt;\n| &lt;mul&gt;\n| &lt;min&gt;\n| &lt;max&gt;\n| &lt;slice&gt;\n| &lt;inverval&gt;\n&lt;mul&gt; ::= &lt;scalar&gt; '*' &lt;scalar&gt;\n&lt;add&gt; ::= &lt;scalar&gt; '+' &lt;scalar&gt;\n&lt;min&gt; ::= 'min' &lt;scalar&gt;+\n&lt;max&gt; ::= 'max' &lt;scalar&gt;+\n&lt;slice&gt; ::= &lt;scalar expr&gt; '[' &lt;interval&gt; ']'\n&lt;interval&gt; ::= &lt;scalar expr&gt; '..' &lt;scalar expr&gt;\n&lt;real&gt; ::= &lt;literal&gt; | &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Variable","title":"Variable","text":"<p>             Bases: <code>Real</code></p> <p>Variable, which stores a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>variable instance.</p> required"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.cast","title":"cast","text":"<pre><code>cast(py)\n</code></pre> <ol> <li> <p>cast Real number (or list/tuple of Real numbers) to <code>Scalar Literal</code>.</p> </li> <li> <p>cast str (or list/tuple of Real numbers) to <code>Scalar Variable</code>.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, Real, Tuple[Real], List[Real]]</code> <p>python object to cast</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>Scalar</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def cast(py) -&gt; \"Scalar\":\n\"\"\"\n    1. cast Real number (or list/tuple of Real numbers)\n    to [`Scalar Literal`][bloqade.ir.scalar.Literal].\n    2. cast str (or list/tuple of Real numbers)\n    to [`Scalar Variable`][bloqade.ir.scalar.Variable].\n    Args:\n        py (Union[str,Real,Tuple[Real],List[Real]]): python object to cast\n    Returns:\n        Scalar\n    \"\"\"\nret = trycast(py)\nif ret is None:\nraise TypeError(f\"Cannot cast {type(py)} to Scalar Literal\")\nreturn ret\n</code></pre>"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.var","title":"var","text":"<pre><code>var(py)\n</code></pre> <p>cast string (or list/tuple of strings) to <code>Variable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, List[str]]</code> <p>a string or list/tuple of strings</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>Union[Variable]</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def var(py: str) -&gt; \"Variable\":\n\"\"\"cast string (or list/tuple of strings)\n    to [`Variable`][bloqade.ir.scalar.Variable].\n    Args:\n        py (Union[str, List[str]]): a string or list/tuple of strings\n    Returns:\n       Union[Variable]\n    \"\"\"\nret = tryvar(py)\nif ret is None:\nraise TypeError(f\"Cannot cast {type(py)} to Variable\")\nreturn ret\n</code></pre>"},{"location":"reference/bloqade/ir/analysis/","title":"Index","text":""},{"location":"reference/bloqade/ir/analysis/assignment_scan/","title":"Assignment scan","text":""},{"location":"reference/bloqade/ir/analysis/scan_variables/","title":"Scan variables","text":""},{"location":"reference/bloqade/ir/control/","title":"Index","text":""},{"location":"reference/bloqade/ir/control/field/","title":"Field","text":""},{"location":"reference/bloqade/ir/control/field/#bloqade.ir.control.field.Field","title":"Field","text":"<p>             Bases: <code>FieldExpr</code></p> <p>Field node in the IR. Which contains collection(s) of <code>Waveform</code></p> <pre><code>&lt;field&gt; ::= ('field' &lt;spatial modulation&gt;  &lt;padded waveform&gt;)*\n</code></pre>"},{"location":"reference/bloqade/ir/control/field/#bloqade.ir.control.field.Field.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Field</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Field</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/field.py</code> <pre><code>def show(self, **assignments):\n\"\"\"\n    Interactive visualization of the Field\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Field\n    \"\"\"\ndisplay_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/","title":"Pulse","text":""},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.Append","title":"Append","text":"<p>             Bases: <code>PulseExpr</code></p> <pre><code>&lt;append&gt; ::= &lt;expr&gt;+\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.Pulse","title":"Pulse","text":"<pre><code>Pulse(field_pairs)\n</code></pre> <p>             Bases: <code>PulseExpr</code></p> <pre><code>&lt;pulse&gt; ::= (&lt;field name&gt; &lt;field&gt;)+\n</code></pre> Source code in <code>src/bloqade/ir/control/pulse.py</code> <pre><code>def __init__(self, field_pairs):\nfields = dict()\nfor k, v in field_pairs.items():\nif isinstance(v, Field):\nfields[k] = v\nelif isinstance(v, dict):\nfields[k] = Field(v)\nelse:\nraise TypeError(f\"Expected Field or dict, got {type(v)}\")\nself.fields = fields\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.Pulse.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Pulse</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Pulse</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/pulse.py</code> <pre><code>def show(self, **assignments):\n\"\"\"\n    Interactive visualization of the Pulse\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Pulse\n    \"\"\"\ndisplay_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.PulseExpr","title":"PulseExpr","text":"<pre><code>&lt;expr&gt; ::= &lt;pulse&gt;\n  | &lt;append&gt;\n  | &lt;slice&gt;\n  | &lt;named&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/sequence/","title":"Sequence","text":""},{"location":"reference/bloqade/ir/control/sequence/#bloqade.ir.control.sequence.Sequence","title":"Sequence","text":"<pre><code>Sequence(seq_pairs=None)\n</code></pre> <p>             Bases: <code>SequenceExpr</code></p> <p>Sequence of a program, which includes pulses informations.</p> Source code in <code>src/bloqade/ir/control/sequence.py</code> <pre><code>def __init__(self, seq_pairs: Optional[Dict] = None):\nif seq_pairs is None:\nself.pulses = {}\nreturn\npulses = {}\nfor level_coupling, pulse in seq_pairs.items():\nif not isinstance(level_coupling, LevelCoupling):\nraise TypeError(f\"Unexpected type {type(level_coupling)}\")\nif isinstance(pulse, PulseExpr):\npulses[level_coupling] = pulse\nelif isinstance(pulse, dict):\npulses[level_coupling] = Pulse(pulse)\nelse:\nraise TypeError(f\"Unexpected type {type(pulse)}\")\nself.pulses = pulses\n</code></pre>"},{"location":"reference/bloqade/ir/control/sequence/#bloqade.ir.control.sequence.Sequence.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Sequence</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Sequence</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/sequence.py</code> <pre><code>def show(self, **assignments):\n\"\"\"\n    Interactive visualization of the Sequence\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Sequence\n    \"\"\"\ndisplay_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Add","title":"Add","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;add&gt; ::= &lt;waveform&gt; '+' &lt;waveform&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.AlignedWaveform","title":"AlignedWaveform","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;padded waveform&gt; ::= &lt;waveform&gt; | &lt;waveform&gt; &lt;alignment&gt; &lt;value&gt;\n&lt;alignment&gt; ::= 'left aligned' | 'right aligned'\n&lt;value&gt; ::= 'left value' | 'right value' | &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Append","title":"Append","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;append&gt; ::= &lt;waveform&gt;+\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Constant","title":"Constant","text":"<pre><code>Constant(value, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;constant&gt; ::= 'constant' &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Scalar</code> <p>the constant value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the constant waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, value, duration):\nself.value = cast(value)\nself._duration = cast(duration)\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Instruction","title":"Instruction","text":"<p>             Bases: <code>Waveform</code></p> <p>Instruction node in the IR.</p> <ul> <li><code>&lt;linear&gt;</code></li> <li><code>&lt;constant&gt;</code></li> <li><code>&lt;poly&gt;</code></li> <li><code>&lt;python-fn&gt;</code></li> </ul> <pre><code>&lt;instruction&gt; ::= &lt;linear&gt;\n    | &lt;constant&gt;\n    | &lt;poly&gt;\n    | &lt;python-fn&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Linear","title":"Linear","text":"<pre><code>Linear(start, stop, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;linear&gt; ::= 'linear' &lt;scalar expr&gt; &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = start + (stop-start)/duration * t</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Scalar</code> <p>start value</p> required <code>stop</code> <code>Scalar</code> <p>stop value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the linear waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, start, stop, duration):\nself.start = cast(start)\nself.stop = cast(stop)\nself._duration = cast(duration)\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Negative","title":"Negative","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;negative&gt; ::= '-' &lt;waveform&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Poly","title":"Poly","text":"<pre><code>Poly(coeffs, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;poly&gt; ::= &lt;scalar&gt;+\n</code></pre> <p>f(t=0:duration) = c[0] + c[1]t + c[2]t^2 + ... + c[n-1]t^n-1 + c[n]t^n</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>List[Scalar]</code> <p>the coefficients c[] of the polynomial.</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, coeffs, duration):\nself.coeffs = cast(coeffs)\nself._duration = cast(duration)\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.PythonFn","title":"PythonFn","text":"<pre><code>PythonFn(fn, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;python-fn&gt; ::= 'python-fn' &lt;python function def&gt; &lt;scalar expr&gt;\n</code></pre> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, fn: Callable, duration: Any):\nself.fn = fn\nself._duration = cast(duration)\nsignature = inspect.getfullargspec(fn)\nif signature.varargs is not None:\nraise ValueError(\"Cannot have `*args` in function definition\")\nif signature.varkw is not None:\nraise ValueError(\"Cannot have `**kwargs` in function definition\")\n# get default kwonly first:\nvariables = []\nself.default_param_values = {}\nself.default_arguements = {}\nif signature.kwonlydefaults is not None:\nfor name, value in signature.kwonlydefaults.items():\nif isinstance(value, (Real, Decimal)):\nvariables.append(name)\nself.default_param_values[name] = Decimal(str(value))\nelse:\n# self.default_arguements[name] = value\nraise ValueError(\nf\"Default value for parameter {name} is not Real or Decimal, \"\n\"cannot convert to Variable.\"\n)\nvariables += signature.args[1:]\nvariables += signature.kwonlyargs\nself.parameters = list(map(var, variables))\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Record","title":"Record","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;record&gt; ::= 'record' &lt;waveform&gt; &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Sample","title":"Sample","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;sample&gt; ::= 'sample' &lt;waveform&gt; &lt;interpolation&gt; &lt;scalar&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Scale","title":"Scale","text":"<pre><code>Scale(scalar, waveform)\n</code></pre> <p>             Bases: <code>Waveform</code></p> <pre><code>&lt;scale&gt; ::= &lt;scalar expr&gt; '*' &lt;waveform&gt;\n</code></pre> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, scalar, waveform: Waveform):\nself.scalar = cast(scalar)\nself.waveform = waveform\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Slice","title":"Slice","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;slice&gt; ::= &lt;waveform&gt; &lt;scalar.interval&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Smooth","title":"Smooth","text":"<pre><code>Smooth(radius, kernel, waveform)\n</code></pre> <p>             Bases: <code>Waveform</code></p> <pre><code>&lt;smooth&gt; ::= 'smooth' &lt;kernel&gt; &lt;waveform&gt;\n</code></pre> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, radius, kernel, waveform):\nif isinstance(kernel, str):\nif kernel == \"Guassian\":\nkernel = GaussianKernel\nelif kernel == \"Logistic\":\nkernel = LogisticKernel\nelif kernel == \"Sigmoid\":\nkernel = SigmoidKernel\nelif kernel == \"Triangle\":\nkernel = TriangleKernel\nelif kernel == \"Uniform\":\nkernel = UniformKernel\nelif kernel == \"Parabolic\":\nkernel = ParabolicKernel\nelif kernel == \"Biweight\":\nkernel = BiweightKernel\nelif kernel == \"Triweight\":\nkernel = TriweightKernel\nelif kernel == \"Tricube\":\nkernel = TricubeKernel\nelif kernel == \"Cosine\":\nkernel = CosineKernel\nelse:\nraise ValueError(f\"Invalid kernel: {kernel}\")\nself.radius = cast(radius)\nself.kernel = kernel\nself.waveform = waveform\nsuper().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Waveform","title":"Waveform","text":"<p>Waveform node in the IR.</p> <ul> <li><code>&lt;instruction&gt;</code></li> <li><code>&lt;smooth&gt;</code></li> <li><code>&lt;slice&gt;</code></li> <li><code>&lt;apppend&gt;</code></li> <li><code>&lt;negative&gt;</code></li> <li><code>&lt;scale&gt;</code></li> <li><code>&lt;add&gt;</code></li> <li><code>&lt;record&gt;</code></li> <li><code>&lt;sample&gt;</code></li> </ul> <pre><code>&lt;waveform&gt; ::= &lt;instruction&gt;\n    | &lt;smooth&gt;\n    | &lt;slice&gt;\n    | &lt;append&gt;\n    | &lt;negative&gt;\n    | &lt;scale&gt;\n    | &lt;add&gt;\n    | &lt;record&gt;\n    | &lt;sample&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Waveform.figure","title":"figure","text":"<pre><code>figure(**assignments)\n</code></pre> <p>get figure of the plotting the waveform.</p> <p>Returns:</p> Name Type Description <code>figure</code> <p>a bokeh figure</p> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def figure(self, **assignments):\n\"\"\"get figure of the plotting the waveform.\n    Returns:\n        figure: a bokeh figure\n    \"\"\"\nreturn get_ir_figure(self, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/location/","title":"Index","text":""},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <ul> <li>Program starting node</li> <li> <p>Possible Next  <p>-&gt; <code>start.rydberg</code>     :: address rydberg level coupling</p> <p>-&gt; <code>start.hyperfine</code>     :: address hyperfine level coupling</p> <li> <p>Possible Next  <p>-&gt; <code>start.add_locations(List[Tuple[int]])</code>     :: add multiple atoms to current register</p> <p>-&gt; <code>start.add_location(Tuple[int])</code>     :: add atom to current register</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement","title":"AtomArrangement","text":"<p>             Bases: <code>ProgramStart</code>, <code>TransformTrait</code></p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n\"\"\"enumerate all locations in the register.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n\"\"\"obtain a figure object from the atom arrangement.\"\"\"\nreturn get_atom_arrangement_figure(self, fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(*shape, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>AtomArrangement</code></p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, *shape: int, lattice_spacing: ScalarType = 1.0):\nself.shape = shape\nself.lattice_spacing = cast(lattice_spacing)\nself.__n_atoms = None\nself.__n_dims = None\nsuper().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices <code>AtomArrangement</code>.</p> <ul> <li><code>Square</code></li> <li><code>Chain</code></li> <li><code>Honeycomb</code></li> <li><code>Triangular</code></li> <li><code>Lieb</code></li> <li><code>Kagome</code></li> <li><code>Rectangular</code></li> </ul>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index)\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n\"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n# damn! this is like stone age broadcasting\nvectors = np.array(self.cell_vectors())\nindex = np.array(index)\npos = np.sum(vectors.T * index, axis=1)\nreturn pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor)\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n\"\"\"Scale the current location with a factor.\n    (x,y) -&gt; factor*(x,y)\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\nfactor = cast(factor)\nobj = self.__new__(type(self))\nfor f in fields(self):\nif f.name == \"lattice_spacing\":\nobj.lattice_spacing = factor * self.lattice_spacing\nelse:\nsetattr(obj, f.name, getattr(self, f.name))\nreturn obj\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Chain","title":"Chain","text":"<pre><code>Chain(L, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\nself, L: int, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\nself.vertical = vertical_chain\nsuper().__init__(L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L * 2.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Kagome","title":"Kagome","text":"<pre><code>Kagome(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Lieb","title":"Lieb","text":"<pre><code>Lieb(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.ParallelRegister","title":"ParallelRegister","text":"<pre><code>ParallelRegister(register, cluster_spacing)\n</code></pre> <p>             Bases: <code>ProgramStart</code></p> <p>Parallel Register</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>@beartype\ndef __init__(self, register: AtomArrangement, cluster_spacing: ScalarType):\nself._register = register\nself._cluster_spacing = cast(cluster_spacing)\nif register.n_atoms &gt; 0:\n# calculate bounding box\n# of this register\nlocation_iter = register.enumerate()\n(x, y) = next(location_iter).position\nx_min = x\nx_max = x\ny_min = y\ny_max = y\nfor location_info in location_iter:\n(x, y) = location_info.position\nx_min = x.min(x_min)\nx_max = x.max(x_max)\ny_min = y.min(y_min)\ny_max = y.max(y_max)\nshift_x = (x_max - x_min) + cluster_spacing\nshift_y = (y_max - y_min) + cluster_spacing\nregister_locations = [\nlist(location_info.position) for location_info in register.enumerate()\n]\nregister_filling = [\nlocation_info.filling.value for location_info in register.enumerate()\n]\nshift_vectors = [[shift_x, cast(0)], [cast(0), shift_y]]\nelse:\nraise ValueError(\"No locations to parallelize.\")\nself.register_locations = register_locations\nself.register_filling = register_filling\nself.shift_vectors = shift_vectors\nsuper().__init__(self)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\nwidth,\nheight,\nlattice_spacing_x=1.0,\nlattice_spacing_y=None,\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>None</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\nself,\nwidth: int,\nheight: int,\nlattice_spacing_x: ScalarType = 1.0,\nlattice_spacing_y: Optional[ScalarType] = None,\n):\nsuper().__init__(width, height, lattice_spacing=lattice_spacing_x)\nif lattice_spacing_y is None:\nself.ratio = cast(1.0) / cast(lattice_spacing_x)\nelse:\nself.ratio = cast(lattice_spacing_y) / cast(lattice_spacing_x)\nsuper().__init__(width, height, lattice_spacing=lattice_spacing_x)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Square","title":"Square","text":"<pre><code>Square(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Triangular","title":"Triangular","text":"<pre><code>Triangular(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/base/","title":"Base","text":""},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement","title":"AtomArrangement","text":"<p>             Bases: <code>ProgramStart</code>, <code>TransformTrait</code></p>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n\"\"\"enumerate all locations in the register.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n\"\"\"obtain a figure object from the atom arrangement.\"\"\"\nreturn get_atom_arrangement_figure(self, fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.ParallelRegister","title":"ParallelRegister","text":"<pre><code>ParallelRegister(register, cluster_spacing)\n</code></pre> <p>             Bases: <code>ProgramStart</code></p> <p>Parallel Register</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>@beartype\ndef __init__(self, register: AtomArrangement, cluster_spacing: ScalarType):\nself._register = register\nself._cluster_spacing = cast(cluster_spacing)\nif register.n_atoms &gt; 0:\n# calculate bounding box\n# of this register\nlocation_iter = register.enumerate()\n(x, y) = next(location_iter).position\nx_min = x\nx_max = x\ny_min = y\ny_max = y\nfor location_info in location_iter:\n(x, y) = location_info.position\nx_min = x.min(x_min)\nx_max = x.max(x_max)\ny_min = y.min(y_min)\ny_max = y.max(y_max)\nshift_x = (x_max - x_min) + cluster_spacing\nshift_y = (y_max - y_min) + cluster_spacing\nregister_locations = [\nlist(location_info.position) for location_info in register.enumerate()\n]\nregister_filling = [\nlocation_info.filling.value for location_info in register.enumerate()\n]\nshift_vectors = [[shift_x, cast(0)], [cast(0), shift_y]]\nelse:\nraise ValueError(\"No locations to parallelize.\")\nself.register_locations = register_locations\nself.register_filling = register_filling\nself.shift_vectors = shift_vectors\nsuper().__init__(self)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/","title":"Bravais","text":""},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(*shape, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>AtomArrangement</code></p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, *shape: int, lattice_spacing: ScalarType = 1.0):\nself.shape = shape\nself.lattice_spacing = cast(lattice_spacing)\nself.__n_atoms = None\nself.__n_dims = None\nsuper().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices <code>AtomArrangement</code>.</p> <ul> <li><code>Square</code></li> <li><code>Chain</code></li> <li><code>Honeycomb</code></li> <li><code>Triangular</code></li> <li><code>Lieb</code></li> <li><code>Kagome</code></li> <li><code>Rectangular</code></li> </ul>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index)\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n\"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n# damn! this is like stone age broadcasting\nvectors = np.array(self.cell_vectors())\nindex = np.array(index)\npos = np.sum(vectors.T * index, axis=1)\nreturn pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor)\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n\"\"\"Scale the current location with a factor.\n    (x,y) -&gt; factor*(x,y)\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\nfactor = cast(factor)\nobj = self.__new__(type(self))\nfor f in fields(self):\nif f.name == \"lattice_spacing\":\nobj.lattice_spacing = factor * self.lattice_spacing\nelse:\nsetattr(obj, f.name, getattr(self, f.name))\nreturn obj\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Chain","title":"Chain","text":"<pre><code>Chain(L, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\nself, L: int, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\nself.vertical = vertical_chain\nsuper().__init__(L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L * 2.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Kagome","title":"Kagome","text":"<pre><code>Kagome(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Lieb","title":"Lieb","text":"<pre><code>Lieb(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\nwidth,\nheight,\nlattice_spacing_x=1.0,\nlattice_spacing_y=None,\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>None</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\nself,\nwidth: int,\nheight: int,\nlattice_spacing_x: ScalarType = 1.0,\nlattice_spacing_y: Optional[ScalarType] = None,\n):\nsuper().__init__(width, height, lattice_spacing=lattice_spacing_x)\nif lattice_spacing_y is None:\nself.ratio = cast(1.0) / cast(lattice_spacing_x)\nelse:\nself.ratio = cast(lattice_spacing_y) / cast(lattice_spacing_x)\nsuper().__init__(width, height, lattice_spacing=lattice_spacing_x)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Square","title":"Square","text":"<pre><code>Square(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Triangular","title":"Triangular","text":"<pre><code>Triangular(L, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, L: int, lattice_spacing: ScalarType = 1.0):\nsuper().__init__(L, L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/list/","title":"List","text":""},{"location":"reference/bloqade/ir/location/list/#bloqade.ir.location.list.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <ul> <li>Program starting node</li> <li> <p>Possible Next  <p>-&gt; <code>start.rydberg</code>     :: address rydberg level coupling</p> <p>-&gt; <code>start.hyperfine</code>     :: address hyperfine level coupling</p> <li> <p>Possible Next  <p>-&gt; <code>start.add_locations(List[Tuple[int]])</code>     :: add multiple atoms to current register</p> <p>-&gt; <code>start.add_location(Tuple[int])</code>     :: add atom to current register</p>"},{"location":"reference/bloqade/ir/location/quera_task_result/","title":"Quera task result","text":""},{"location":"reference/bloqade/ir/location/quera_task_result/#bloqade.ir.location.quera_task_result.QuEraTaskResults","title":"QuEraTaskResults","text":"<p>             Bases: <code>BaseModel</code></p>"},{"location":"reference/bloqade/ir/location/quera_task_result/#bloqade.ir.location.quera_task_result.QuEraTaskResults.export_as_probabilities","title":"export_as_probabilities","text":"<pre><code>export_as_probabilities()\n</code></pre> <p>converts from shot results to probabilities</p> <p>Returns:</p> Name Type Description <code>TaskProbabilities</code> <code>TaskProbabilities</code> <p>The task results as probabilties</p> Source code in <code>src/bloqade/ir/location/quera_task_result.py</code> <pre><code>def export_as_probabilities(self) -&gt; TaskProbabilities:\n\"\"\"converts from shot results to probabilities\n    Returns:\n        TaskProbabilities: The task results as probabilties\n    \"\"\"\ncounts = dict()\nnshots = len(self.shot_outputs)\nfor shot_result in self.shot_outputs:\npre_sequence_str = \"\".join(str(bit) for bit in shot_result.pre_sequence)\npost_sequence_str = \"\".join(str(bit) for bit in shot_result.post_sequence)\nconfiguration = (pre_sequence_str, post_sequence_str)\n# iterative average\ncurrent_count = counts.get(configuration, 0)\ncounts[configuration] = current_count + 1\nprobabilities = [(config, count / nshots) for config, count in counts.items()]\nreturn TaskProbabilities(probabilities=probabilities)\n</code></pre>"},{"location":"reference/bloqade/ir/location/transform/","title":"Transform","text":""},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait","title":"TransformTrait","text":""},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.add_position","title":"add_position","text":"<pre><code>add_position(position, filling=None)\n</code></pre> <p>add a position or list of positions to existing atom arrangement.</p> <p>Parameters:</p> Name Type Description Default <code>|</code> <code>numpy.array with shape (n, 2)]</code> <p>position to add</p> required <code>|</code> <code>numpy.array with shape (n, ) | None</code> <p>filling of the added position(s). Defaults to None.</p> required <p>Returns:</p> Name Type Description <code>ListOfLocations</code> <code>ListOfLocations</code> <p>new atom arrangement with added positions</p> Source code in <code>src/bloqade/ir/location/transform.py</code> <pre><code>def add_position(\nself,\nposition: Union[\nTuple[ScalarType, ScalarType],\nList[Tuple[ScalarType, ScalarType]],\nPositionArray,\n],\nfilling: Optional[Union[bool, list[bool], BoolArray]] = None,\n) -&gt; \"ListOfLocations\":\n\"\"\"add a position or list of positions to existing atom arrangement.\n    Args:\n        position (Tuple[ScalarType, ScalarType]\n        | List[Tuple[ScalarType, ScalarType]\n        | numpy.array with shape (n, 2)]):\n            position to add\n        filling (bool | list[bool]\n        | numpy.array with shape (n, ) | None, optional):\n            filling of the added position(s). Defaults to None.\n    Returns:\n        ListOfLocations: new atom arrangement with added positions\n    \"\"\"\nif isinstance(position, tuple) and isinstance(filling, (bool, type(None))):\nreturn self._add_position(position, filling)\nelif isinstance(position, list) and isinstance(filling, (list, type(None))):\nreturn self._add_position_list(position, filling)\nelif isinstance(position, np.ndarray) and isinstance(\nfilling, (np.ndarray, type(None))\n):\nreturn self._add_numpy_position(position, filling)\nelse:\nraise TypeError(\nf\"cannot interpret arguments, got {type(position)} \"\nf\"for position and {type(filling)} for filling\"\n)\n</code></pre>"},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.apply_defect_count","title":"apply_defect_count","text":"<pre><code>apply_defect_count(n_defects, rng=np.random.default_rng())\n</code></pre> <p>apply n_defects randomly to existing atom arrangement.</p> Source code in <code>src/bloqade/ir/location/transform.py</code> <pre><code>@beartype\ndef apply_defect_count(\nself, n_defects: int, rng: np.random.Generator = np.random.default_rng()\n):\n\"\"\"apply n_defects randomly to existing atom arrangement.\"\"\"\nfrom .list import ListOfLocations\nfrom .base import LocationInfo, SiteFilling\nlocation_list = []\nfor location_info in self.enumerate():\nlocation_list.append(location_info)\nfilled_sites = []\nfor index, location_info in enumerate(location_list):\nif location_info.filling is SiteFilling.filled:\nfilled_sites.append(index)\nif n_defects &gt;= len(filled_sites):\nraise ValueError(\nf\"n_defects {n_defects} must be less than the number of filled sites \"\nf\"({len(filled_sites)})\"\n)\nfor _ in range(n_defects):\nindex = rng.choice(filled_sites)\nlocation_list[index] = LocationInfo(\nlocation_list[index].position,\n(False if location_list[index].filling is SiteFilling.filled else True),\n)\nfilled_sites.remove(index)\nreturn ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.apply_defect_density","title":"apply_defect_density","text":"<pre><code>apply_defect_density(\ndefect_probability, rng=np.random.default_rng()\n)\n</code></pre> <p>apply defect_probability randomly to existing atom arrangement.</p> Source code in <code>src/bloqade/ir/location/transform.py</code> <pre><code>@beartype\ndef apply_defect_density(\nself,\ndefect_probability: float,\nrng: np.random.Generator = np.random.default_rng(),\n):\n\"\"\"apply defect_probability randomly to existing atom arrangement.\"\"\"\nfrom .list import ListOfLocations\nfrom .base import LocationInfo, SiteFilling\np = min(1, max(0, defect_probability))\nlocation_list = []\nfor location_info in self.enumerate():\nif rng.random() &lt; p:\nlocation_list.append(\nLocationInfo(\nlocation_info.position,\n(\nFalse\nif location_info.filling is SiteFilling.filled\nelse True\n),\n)\n)\nelse:\nlocation_list.append(location_info)\nreturn ListOfLocations(location_list=location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.remove_vacant_sites","title":"remove_vacant_sites","text":"<pre><code>remove_vacant_sites()\n</code></pre> <p>remove all vacant sites from the register.</p> Source code in <code>src/bloqade/ir/location/transform.py</code> <pre><code>def remove_vacant_sites(self):\n\"\"\"remove all vacant sites from the register.\"\"\"\nfrom .base import SiteFilling\nfrom .list import ListOfLocations\nnew_locations = []\nfor location_info in self.enumerate():\nif location_info.filling is SiteFilling.filled:\nnew_locations.append(location_info)\nreturn ListOfLocations(new_locations)\n</code></pre>"},{"location":"reference/bloqade/ir/routine/","title":"Index","text":""},{"location":"reference/bloqade/ir/routine/base/","title":"Base","text":""},{"location":"reference/bloqade/ir/routine/base/#bloqade.ir.routine.base.Routine","title":"Routine  <code>dataclass</code>","text":"<p>             Bases: <code>RoutineBase</code></p> <p>Result of parsing a completed Builder string.</p>"},{"location":"reference/bloqade/ir/routine/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadePythonRoutine","title":"BloqadePythonRoutine  <code>dataclass</code>","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadePythonRoutine.run","title":"run","text":"<pre><code>run(\nshots,\nargs=(),\nname=None,\nblockade_radius=0.0,\ninteraction_picture=False,\ncache_matrices=False,\nmultiprocessing=False,\nnum_workers=None,\nsolver_name=\"dop853\",\natol=1e-14,\nrtol=1e-07,\nnsteps=2147483647,\n)\n</code></pre> <p>Run the current program using bloqade python backend</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots after running state vector simulation</p> required <code>args</code> <code>Tuple[Real, ...]</code> <p>The arguments defined in <code>flatten</code>.</p> <code>()</code> <code>name</code> <code>Optional[str]</code> <p>Name to give this run. Defaults to None.</p> <code>None</code> <code>blockade_radius</code> <code>float</code> <p>Use the Blockade subspace given a</p> <code>0.0</code> <code>interaction_picture</code> <code>bool</code> <p>Use the interaction picture when</p> <code>False</code> <code>cache_matrices</code> <code>bool</code> <p>Reuse previously evaluated matrcies when</p> <code>False</code> <code>multiprocessing</code> <code>bool</code> <p>Use multiple processes to process the</p> <code>False</code> <code>num_workers</code> <code>Optional[int]</code> <p>Number of processes to run with</p> <code>None</code> <code>solver_name</code> <code>str</code> <p>Which SciPy Solver to use. Defaults to</p> <code>'dop853'</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for ODE solver. Defaults to</p> <code>1e-14</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive step in ODE solver.</p> <code>1e-07</code> <code>nsteps</code> <code>int</code> <p>Maximum number of steps allowed per integration</p> <code>2147483647</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Cannot use multiprocessing and cache_matrices at the same time.</p> <p>Returns:</p> Name Type Description <code>LocalBatch</code> <code>LocalBatch</code> <p>Batch of local tasks that have been executed.</p> Source code in <code>src/bloqade/ir/routine/bloqade.py</code> <pre><code>@beartype\ndef run(\nself,\nshots: int,\nargs: Tuple[LiteralType, ...] = (),\nname: Optional[str] = None,\nblockade_radius: float = 0.0,\ninteraction_picture: bool = False,\ncache_matrices: bool = False,\nmultiprocessing: bool = False,\nnum_workers: Optional[int] = None,\nsolver_name: str = \"dop853\",\natol: float = 1e-14,\nrtol: float = 1e-7,\nnsteps: int = 2_147_483_647,\n) -&gt; LocalBatch:\n\"\"\"Run the current program using bloqade python backend\n    Args:\n        shots (int): number of shots after running state vector simulation\n        args (Tuple[Real, ...], optional): The arguments defined in `flatten`.\n        Defaults to ().\n        name (Optional[str], optional): Name to give this run. Defaults to None.\n        blockade_radius (float, optional): Use the Blockade subspace given a\n        particular radius. Defaults to 0.0.\n        interaction_picture (bool, optional): Use the interaction picture when\n        solving schrodinger equation. Defaults to False.\n        cache_matrices (bool, optional): Reuse previously evaluated matrcies when\n        possible. Defaults to False.\n        multiprocessing (bool, optional): Use multiple processes to process the\n        batches. Defaults to False.\n        num_workers (Optional[int], optional): Number of processes to run with\n        multiprocessing. Defaults to None.\n        solver_name (str, optional): Which SciPy Solver to use. Defaults to\n        \"dop853\".\n        atol (float, optional): Absolute tolerance for ODE solver. Defaults to\n        1e-14.\n        rtol (float, optional): Relative tolerance for adaptive step in ODE solver.\n        Defaults to 1e-7.\n        nsteps (int, optional): Maximum number of steps allowed per integration\n        step. Defaults to 2_147_483_647, the maximum value.\n    Raises:\n        ValueError: Cannot use multiprocessing and cache_matrices at the same time.\n    Returns:\n        LocalBatch: Batch of local tasks that have been executed.\n    \"\"\"\nif multiprocessing and cache_matrices:\nraise ValueError(\n\"Cannot use multiprocessing and cache_matrices at the same time.\"\n)\ncompile_options = dict(\nshots=shots,\nargs=args,\nname=name,\nblockade_radius=blockade_radius,\ncache_matrices=cache_matrices,\n)\nsolver_options = dict(\nmultiprocessing=multiprocessing,\nnum_workers=num_workers,\nsolver_name=solver_name,\natol=atol,\nrtol=rtol,\nnsteps=nsteps,\ninteraction_picture=interaction_picture,\n)\nbatch = self._compile(**compile_options)\nbatch._run(**solver_options)\nreturn batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/","title":"Braket","text":""},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine","title":"BraketHardwareRoutine  <code>dataclass</code>","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine.__call__","title":"__call__","text":"<pre><code>__call__(\n*args, shots=1, name=None, shuffle=False, **kwargs\n)\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, run_async to Braket, and wait until the results are coming back.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> <code>1</code> <code>args</code> <code>LiteralType</code> <p>additional arguments for flatten variables.</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef __call__(\nself,\n*args: LiteralType,\nshots: int = 1,\nname: Optional[str] = None,\nshuffle: bool = False,\n**kwargs,\n):\n\"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, run_async to Braket,\n    and wait until the results are coming back.\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n    Args:\n        shots (int): number of shots\n        args: additional arguments for flatten variables.\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n    Return:\n        RemoteBatch\n    \"\"\"\nreturn self.run(shots, args, name, shuffle, **kwargs)\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine.run","title":"run","text":"<pre><code>run(shots, args=(), name=None, shuffle=False, **kwargs)\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, run_async to Braket, and wait until the results are coming back.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>additional arguments</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef run(\nself,\nshots: int,\nargs: Tuple[LiteralType, ...] = (),\nname: Optional[str] = None,\nshuffle: bool = False,\n**kwargs,\n) -&gt; RemoteBatch:\n\"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, run_async to Braket,\n    and wait until the results are coming back.\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n    Args:\n        shots (int): number of shots\n        args (Tuple): additional arguments\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n    Return:\n        RemoteBatch\n    \"\"\"\nbatch = self.run_async(shots, args, name, shuffle, **kwargs)\nbatch.pull()\nreturn batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine.run_async","title":"run_async","text":"<pre><code>run_async(\nshots, args=(), name=None, shuffle=False, **kwargs\n)\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, and run_async to Braket.</p> Note <p>This is async.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>additional arguments</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef run_async(\nself,\nshots: int,\nargs: Tuple[LiteralType, ...] = (),\nname: Optional[str] = None,\nshuffle: bool = False,\n**kwargs,\n) -&gt; RemoteBatch:\n\"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, and run_async to Braket.\n    Note:\n        This is async.\n    Args:\n        shots (int): number of shots\n        args (Tuple): additional arguments\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n    Return:\n        RemoteBatch\n    \"\"\"\nbatch = self._compile(shots, args, name)\nbatch._submit(shuffle, **kwargs)\nreturn batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketLocalEmulatorRoutine","title":"BraketLocalEmulatorRoutine  <code>dataclass</code>","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketLocalEmulatorRoutine.__call__","title":"__call__","text":"<pre><code>__call__(\n*args,\nshots=1,\nname=None,\nmultiprocessing=False,\nnum_workers=None,\n**kwargs\n)\n</code></pre> <p>Compile to a LocalBatch, and run. The LocalBatch contain tasks to run on local emulator.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> <code>1</code> <code>args</code> <code>LiteralType</code> <p>additional arguments for flatten variables.</p> <code>()</code> <code>multiprocessing</code> <code>bool</code> <p>enable multi-process</p> <code>False</code> <code>num_workers</code> <code>int</code> <p>number of workers to run the emulator</p> <code>None</code> Return <p>LocalBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef __call__(\nself,\n*args: LiteralType,\nshots: int = 1,\nname: Optional[str] = None,\nmultiprocessing: bool = False,\nnum_workers: Optional[int] = None,\n**kwargs,\n):\n\"\"\"\n    Compile to a LocalBatch, and run.\n    The LocalBatch contain tasks to run on local emulator.\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n    Args:\n        shots (int): number of shots\n        args: additional arguments for flatten variables.\n        multiprocessing (bool): enable multi-process\n        num_workers (int): number of workers to run the emulator\n    Return:\n        LocalBatch\n    \"\"\"\nreturn self.run(\nshots,\nargs,\nname,\nmultiprocessing=multiprocessing,\nnum_workers=num_workers,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketLocalEmulatorRoutine.run","title":"run","text":"<pre><code>run(\nshots,\nargs=(),\nname=None,\nmultiprocessing=False,\nnum_workers=None,\n**kwargs\n)\n</code></pre> <p>Compile to a LocalBatch, and run. The LocalBatch contain tasks to run on local emulator.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple[LiteralType, ...]</code> <p>additional arguments for flatten variables.</p> <code>()</code> <code>multiprocessing</code> <code>bool</code> <p>enable multi-process</p> <code>False</code> <code>num_workers</code> <code>int</code> <p>number of workers to run the emulator</p> <code>None</code> Return <p>LocalBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef run(\nself,\nshots: int,\nargs: Tuple[LiteralType, ...] = (),\nname: Optional[str] = None,\nmultiprocessing: bool = False,\nnum_workers: Optional[int] = None,\n**kwargs,\n) -&gt; LocalBatch:\n\"\"\"\n    Compile to a LocalBatch, and run.\n    The LocalBatch contain tasks to run on local emulator.\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n    Args:\n        shots (int): number of shots\n        args: additional arguments for flatten variables.\n        multiprocessing (bool): enable multi-process\n        num_workers (int): number of workers to run the emulator\n    Return:\n        LocalBatch\n    \"\"\"\nbatch = self._compile(shots, args, name)\nbatch._run(multiprocessing=multiprocessing, num_workers=num_workers, **kwargs)\nreturn batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/params/","title":"Params","text":""},{"location":"reference/bloqade/ir/routine/quera/","title":"Quera","text":""},{"location":"reference/bloqade/ir/routine/quera/#bloqade.ir.routine.quera.QuEraHardwareRoutine","title":"QuEraHardwareRoutine  <code>dataclass</code>","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/quera/#bloqade.ir.routine.quera.QuEraHardwareRoutine.run_async","title":"run_async","text":"<pre><code>run_async(\nshots, args=(), name=None, shuffle=False, **kwargs\n)\n</code></pre> <p>Compile to a RemoteBatch, which contain     QuEra backend specific tasks,     and run_async through QuEra service.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>additional arguments</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/quera.py</code> <pre><code>@beartype\ndef run_async(\nself,\nshots: int,\nargs: Tuple[LiteralType, ...] = (),\nname: Optional[str] = None,\nshuffle: bool = False,\n**kwargs,\n) -&gt; RemoteBatch:\n\"\"\"\n    Compile to a RemoteBatch, which contain\n        QuEra backend specific tasks,\n        and run_async through QuEra service.\n    Args:\n        shots (int): number of shots\n        args (Tuple): additional arguments\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n    Return:\n        RemoteBatch\n    \"\"\"\nbatch = self._compile(shots, args, name)\nbatch._submit(shuffle, **kwargs)\nreturn batch\n</code></pre>"},{"location":"reference/bloqade/submission/","title":"Index","text":""},{"location":"reference/bloqade/submission/base/","title":"Base","text":""},{"location":"reference/bloqade/submission/braket/","title":"Braket","text":""},{"location":"reference/bloqade/submission/mock/","title":"Mock","text":""},{"location":"reference/bloqade/submission/quera/","title":"Quera","text":""},{"location":"reference/bloqade/submission/ir/","title":"Index","text":""},{"location":"reference/bloqade/submission/ir/braket/","title":"Braket","text":""},{"location":"reference/bloqade/submission/ir/capabilities/","title":"Capabilities","text":""},{"location":"reference/bloqade/submission/ir/parallel/","title":"Parallel","text":""},{"location":"reference/bloqade/submission/ir/parallel/#bloqade.submission.ir.parallel.ClusterLocationInfo","title":"ClusterLocationInfo","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class that stores the mapping of batched jobs.</p> <p>Parameters:</p> Name Type Description Default <code>cluster_index</code> <code>int</code> <p>the index of the cluster a site belongs to</p> required <code>global_location_index</code> <code>int</code> <p>the index of the site in the multplexed system</p> required <code>cluster_location_index</code> <code>int</code> <p>the index of the site in the original system</p> required"},{"location":"reference/bloqade/submission/ir/task_results/","title":"Task results","text":""},{"location":"reference/bloqade/submission/ir/task_results/#bloqade.submission.ir.task_results.QuEraTaskResults","title":"QuEraTaskResults","text":"<p>             Bases: <code>BaseModel</code></p>"},{"location":"reference/bloqade/submission/ir/task_results/#bloqade.submission.ir.task_results.QuEraTaskResults.export_as_probabilities","title":"export_as_probabilities","text":"<pre><code>export_as_probabilities()\n</code></pre> <p>converts from shot results to probabilities</p> <p>Returns:</p> Name Type Description <code>TaskProbabilities</code> <code>TaskProbabilities</code> <p>The task results as probabilties</p> Source code in <code>src/bloqade/submission/ir/task_results.py</code> <pre><code>def export_as_probabilities(self) -&gt; TaskProbabilities:\n\"\"\"converts from shot results to probabilities\n    Returns:\n        TaskProbabilities: The task results as probabilties\n    \"\"\"\ncounts = dict()\nnshots = len(self.shot_outputs)\nfor shot_result in self.shot_outputs:\npre_sequence_str = \"\".join(str(bit) for bit in shot_result.pre_sequence)\npost_sequence_str = \"\".join(str(bit) for bit in shot_result.post_sequence)\nconfiguration = (pre_sequence_str, post_sequence_str)\n# iterative average\ncurrent_count = counts.get(configuration, 0)\ncounts[configuration] = current_count + 1\nprobabilities = [(config, count / nshots) for config, count in counts.items()]\nreturn TaskProbabilities(probabilities=probabilities)\n</code></pre>"},{"location":"reference/bloqade/submission/ir/task_specification/","title":"Task specification","text":""},{"location":"reference/bloqade/task/","title":"Index","text":""},{"location":"reference/bloqade/task/base/","title":"Base","text":""},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report","title":"Report","text":"<pre><code>Report(data, metas, geos, name='')\n</code></pre> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def __init__(self, data, metas, geos, name=\"\") -&gt; None:\nself.dataframe = data  # df\nself._bitstrings = None  # bitstring cache\nself._counts = None  # counts cache\nself.metas = metas\nself.geos = geos\nself.name = name + \" \" + str(datetime.datetime.now())\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.counts","title":"counts  <code>property</code>","text":"<pre><code>counts\n</code></pre> <p>Get the statistic for the counts for each configuration(s)</p> Return <p>statistic of configuration (str): counts (int) for each task</p>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.bitstrings","title":"bitstrings","text":"<pre><code>bitstrings(filter_perfect_filling=True)\n</code></pre> <p>Get the bitstrings from the data.</p> <p>Parameters:</p> Name Type Description Default <code>filter_perfect_filling</code> <code>bool</code> <p>whether return will</p> <code>True</code> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def bitstrings(self, filter_perfect_filling: bool = True) -&gt; List[NDArray]:\n\"\"\"\n    Get the bitstrings from the data.\n    Args:\n        filter_perfect_filling (bool): whether return will\n        only contain perfect filling shots.\n    \"\"\"\nperfect_sorting = self.dataframe.index.get_level_values(\"perfect_sorting\")\npre_sequence = self.dataframe.index.get_level_values(\"pre_sequence\")\nif filter_perfect_filling:\ndf = self.dataframe[perfect_sorting == pre_sequence]\nelse:\ndf = self.dataframe\ntask_numbers = df.index.get_level_values(\"task_number\").unique()\nbitstrings = []\nfor task_number in task_numbers:\nbitstrings.append(df.loc[task_number, ...].to_numpy())\nreturn bitstrings\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.list_param","title":"list_param","text":"<pre><code>list_param(field_name)\n</code></pre> <p>List the parameters associate with the given variable field_name for each tasks.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>variable name</p> required Source code in <code>src/bloqade/task/base.py</code> <pre><code>def list_param(self, field_name: str) -&gt; List[Union[Number, None]]:\n\"\"\"\n    List the parameters associate with the given variable field_name\n    for each tasks.\n    Args:\n        field_name (str): variable name\n    \"\"\"\ndef cast(x):\ntry:\nreturn float(x)\nexcept ValueError:\nreturn x\nreturn list(map(cast, (meta.get(field_name) for meta in self.metas)))\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.rydberg_densities","title":"rydberg_densities","text":"<pre><code>rydberg_densities(filter_perfect_filling=True)\n</code></pre> <p>Get rydberg density for each task.</p> <p>Parameters:</p> Name Type Description Default <code>filter_perfect_filling</code> <code>bool</code> <p>whether return will</p> <code>True</code> Return <p>per-site rydberg density for each task</p> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def rydberg_densities(self, filter_perfect_filling: bool = True) -&gt; pd.Series:\n\"\"\"\n    Get rydberg density for each task.\n    Args:\n        filter_perfect_filling (bool):  whether return will\n        only contain perfect filling shots.\n    Return:\n        per-site rydberg density for each task\n    \"\"\"\n# TODO: implement nan for missing task numbers\nperfect_sorting = self.dataframe.index.get_level_values(\"perfect_sorting\")\npre_sequence = self.dataframe.index.get_level_values(\"pre_sequence\")\nif filter_perfect_filling:\ndf = self.dataframe[perfect_sorting == pre_sequence]\nelse:\ndf = self.dataframe\nreturn 1 - (df.groupby(\"task_number\").mean())\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Interactive Visualization of the Report</p> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def show(self):\n\"\"\"\n    Interactive Visualization of the Report\n    \"\"\"\ndisplay_report(self)\n</code></pre>"},{"location":"reference/bloqade/task/batch/","title":"Batch","text":""},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.LocalBatch","title":"LocalBatch  <code>dataclass</code>","text":"<p>             Bases: <code>Serializable</code></p>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.LocalBatch.report","title":"report","text":"<pre><code>report()\n</code></pre> <p>Generate analysis report base on currently completed tasks in the LocalBatch.</p> Return <p>Report</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def report(self) -&gt; Report:\n\"\"\"\n    Generate analysis report base on currently\n    completed tasks in the LocalBatch.\n    Return:\n        Report\n    \"\"\"\n## this potentially can be specialize/disatch\n## offline\nindex = []\ndata = []\nmetas = []\ngeos = []\nfor task_number, task in self.tasks.items():\ngeometry = task.geometry\nperfect_sorting = \"\".join(map(str, geometry.filling))\nparallel_decoder = geometry.parallel_decoder\nif parallel_decoder:\ncluster_indices = parallel_decoder.get_cluster_indices()\nelse:\ncluster_indices = {(0, 0): list(range(len(perfect_sorting)))}\nshot_iter = filter(\nlambda shot: shot.shot_status == QuEraShotStatusCode.Completed,\ntask.result().shot_outputs,\n)\nfor shot, (cluster_coordinate, cluster_index) in product(\nshot_iter, cluster_indices.items()\n):\npre_sequence = \"\".join(\nmap(\nstr,\n(shot.pre_sequence[index] for index in cluster_index),\n)\n)\npost_sequence = np.asarray(\n[shot.post_sequence[index] for index in cluster_index],\ndtype=np.int8,\n)\npfc_sorting = \"\".join(\n[perfect_sorting[index] for index in cluster_index]\n)\nkey = (\ntask_number,\ncluster_coordinate,\npfc_sorting,\npre_sequence,\n)\nindex.append(key)\ndata.append(post_sequence)\nmetas.append(task.metadata)\ngeos.append(task.geometry)\nindex = pd.MultiIndex.from_tuples(\nindex, names=[\"task_number\", \"cluster\", \"perfect_sorting\", \"pre_sequence\"]\n)\ndf = pd.DataFrame(data, index=index)\ndf.sort_index(axis=\"index\")\nrept = None\nif self.name is None:\nrept = Report(df, metas, geos, \"Local\")\nelse:\nrept = Report(df, metas, geos, self.name)\nreturn rept\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.LocalBatch.rerun","title":"rerun","text":"<pre><code>rerun(multiprocessing=False, num_workers=None, **kwargs)\n</code></pre> <p>Rerun all the tasks in the LocalBatch.</p> Return <p>Report</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef rerun(\nself, multiprocessing: bool = False, num_workers: Optional[int] = None, **kwargs\n):\n\"\"\"\n    Rerun all the tasks in the LocalBatch.\n    Return:\n        Report\n    \"\"\"\nreturn self._run(\nmultiprocessing=multiprocessing, num_workers=num_workers, **kwargs\n)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch","title":"RemoteBatch  <code>dataclass</code>","text":"<p>             Bases: <code>Serializable</code></p>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.total_nshots","title":"total_nshots  <code>property</code>","text":"<pre><code>total_nshots\n</code></pre> <p>Total number of shots of all tasks in the RemoteBatch</p> Return <p>number of shots</p>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.cancel","title":"cancel","text":"<pre><code>cancel()\n</code></pre> <p>Cancel all the tasks in the Batch.</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def cancel(self) -&gt; \"RemoteBatch\":\n\"\"\"\n    Cancel all the tasks in the Batch.\n    Return:\n        self\n    \"\"\"\n# cancel all jobs\nfor task in self.tasks.values():\ntask.cancel()\nreturn self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.fetch","title":"fetch","text":"<pre><code>fetch()\n</code></pre> <p>Fetch the tasks in the Batch.</p> Note <p>Fetching will update the status of tasks, and only pull the results for those tasks that have completed.</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def fetch(self) -&gt; \"RemoteBatch\":\n\"\"\"\n    Fetch the tasks in the Batch.\n    Note:\n        Fetching will update the status of tasks,\n        and only pull the results for those tasks\n        that have completed.\n    Return:\n        self\n    \"\"\"\n# online, non-blocking\n# pull the results only when its ready\nfor task in self.tasks.values():\ntask.fetch()\nreturn self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_completed_tasks","title":"get_completed_tasks","text":"<pre><code>get_completed_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain completed tasks from current Batch.</p> <p>Tasks consider completed with following status codes:</p> <ol> <li>Completed</li> <li>Partial</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def get_completed_tasks(self) -&gt; \"RemoteBatch\":\n\"\"\"\n    Create a RemoteBatch object that\n    contain completed tasks from current Batch.\n    Tasks consider completed with following status codes:\n    1. Completed\n    2. Partial\n    Return:\n        RemoteBatch\n    \"\"\"\nstatuses = [\n\"Completed\",\n\"Partial\",\n]\nreturn self.get_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_failed_tasks","title":"get_failed_tasks","text":"<pre><code>get_failed_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain failed tasks from current Batch.</p> <p>failed tasks with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def get_failed_tasks(self) -&gt; \"RemoteBatch\":\n\"\"\"\n    Create a RemoteBatch object that\n    contain failed tasks from current Batch.\n    failed tasks with following status codes:\n    1. Failed\n    2. Unaccepted\n    Return:\n        RemoteBatch\n    \"\"\"\n# statuses that are in a state that are\n# completed because of an error\nstatuses = [\"Failed\", \"Unaccepted\"]\nreturn self.get_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_finished_tasks","title":"get_finished_tasks","text":"<pre><code>get_finished_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain finished tasks from current Batch.</p> <p>Tasks consider finished with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> <li>Completed</li> <li>Partial</li> <li>Cancelled</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def get_finished_tasks(self) -&gt; \"RemoteBatch\":\n\"\"\"\n    Create a RemoteBatch object that\n    contain finished tasks from current Batch.\n    Tasks consider finished with following status codes:\n    1. Failed\n    2. Unaccepted\n    3. Completed\n    4. Partial\n    5. Cancelled\n    Return:\n        RemoteBatch\n    \"\"\"\n# statuses that are in a state that will\n# not run going forward for any reason\nstatuses = [\"Completed\", \"Failed\", \"Unaccepted\", \"Partial\", \"Cancelled\"]\nreturn self.remove_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_tasks","title":"get_tasks","text":"<pre><code>get_tasks(*status_codes)\n</code></pre> <p>Get Tasks with specify status_codes.</p> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef get_tasks(self, *status_codes: str) -&gt; \"RemoteBatch\":\n\"\"\"\n    Get Tasks with specify status_codes.\n    Return:\n        RemoteBatch\n    \"\"\"\n# offline:\nst_codes = [QuEraTaskStatusCode(x) for x in status_codes]\nnew_task_results = OrderedDict()\nfor task_number, task in self.tasks.items():\nif task.task_result_ir.task_status in st_codes:\nnew_task_results[task_number] = task\nreturn RemoteBatch(self.source, new_task_results, name=self.name)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.pull","title":"pull","text":"<pre><code>pull()\n</code></pre> <p>Pull results of the tasks in the Batch.</p> Note <p>Pulling will pull the results for the tasks. If a given task(s) has not been completed, wait until it finished.</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def pull(self) -&gt; \"RemoteBatch\":\n\"\"\"\n    Pull results of the tasks in the Batch.\n    Note:\n        Pulling will pull the results for the tasks.\n        If a given task(s) has not been completed, wait\n        until it finished.\n    Return:\n        self\n    \"\"\"\n# online, blocking\n# pull the results. if its not ready, hanging\nfor task in self.tasks.values():\ntask.pull()\nreturn self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.remove_failed_tasks","title":"remove_failed_tasks","text":"<pre><code>remove_failed_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain tasks from current Batch, with failed tasks removed.</p> <p>failed tasks with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def remove_failed_tasks(self) -&gt; \"RemoteBatch\":\n\"\"\"\n    Create a RemoteBatch object that\n    contain tasks from current Batch,\n    with failed tasks removed.\n    failed tasks with following status codes:\n    1. Failed\n    2. Unaccepted\n    Return:\n        RemoteBatch\n    \"\"\"\n# statuses that are in a state that will\n# not run going forward because of an error\nstatuses = [\"Failed\", \"Unaccepted\"]\nreturn self.remove_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.remove_invalid_tasks","title":"remove_invalid_tasks","text":"<pre><code>remove_invalid_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain tasks from current Batch, with all Unaccepted tasks removed.</p> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def remove_invalid_tasks(self) -&gt; \"RemoteBatch\":\n\"\"\"\n    Create a RemoteBatch object that\n    contain tasks from current Batch,\n    with all Unaccepted tasks removed.\n    Return:\n        RemoteBatch\n    \"\"\"\nreturn self.remove_tasks(\"Unaccepted\")\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.remove_tasks","title":"remove_tasks","text":"<pre><code>remove_tasks(*status_codes)\n</code></pre> <p>Remove Tasks with specify status_codes.</p> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef remove_tasks(self, *status_codes: str) -&gt; \"RemoteBatch\":\n\"\"\"\n    Remove Tasks with specify status_codes.\n    Return:\n        RemoteBatch\n    \"\"\"\n# offline:\nst_codes = [QuEraTaskStatusCode(x) for x in status_codes]\nnew_results = OrderedDict()\nfor task_number, task in self.tasks.items():\nif task.task_result_ir.task_status in st_codes:\ncontinue\nnew_results[task_number] = task\nreturn RemoteBatch(self.source, new_results, self.name)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.report","title":"report","text":"<pre><code>report()\n</code></pre> <p>Generate analysis report base on currently completed tasks in the RemoteBatch.</p> Return <p>Report</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def report(self) -&gt; \"Report\":\n\"\"\"\n    Generate analysis report base on currently\n    completed tasks in the RemoteBatch.\n    Return:\n        Report\n    \"\"\"\n## this potentially can be specialize/disatch\n## offline\nindex = []\ndata = []\nmetas = []\ngeos = []\nfor task_number, task in self.tasks.items():\n## fliter not existing results tasks:\nif (task.task_id is None) or (not task._result_exists()):\ncontinue\n## filter has result but is not correctly completed.\nif not task.task_result_ir.task_status == QuEraTaskStatusCode.Completed:\ncontinue\ngeometry = task.geometry\nperfect_sorting = \"\".join(map(str, geometry.filling))\nparallel_decoder = geometry.parallel_decoder\nif parallel_decoder:\ncluster_indices = parallel_decoder.get_cluster_indices()\nelse:\ncluster_indices = {(0, 0): list(range(len(perfect_sorting)))}\nshot_iter = filter(\nlambda shot: shot.shot_status == QuEraShotStatusCode.Completed,\ntask.result().shot_outputs,\n)\nfor shot, (cluster_coordinate, cluster_index) in product(\nshot_iter, cluster_indices.items()\n):\npre_sequence = \"\".join(\nmap(\nstr,\n(shot.pre_sequence[index] for index in cluster_index),\n)\n)\npost_sequence = np.asarray(\n[shot.post_sequence[index] for index in cluster_index],\ndtype=np.int8,\n)\npfc_sorting = \"\".join(\n[perfect_sorting[index] for index in cluster_index]\n)\nkey = (\ntask_number,\ncluster_coordinate,\npfc_sorting,\npre_sequence,\n)\nindex.append(key)\ndata.append(post_sequence)\nmetas.append(task.metadata)\ngeos.append(task.geometry)\nindex = pd.MultiIndex.from_tuples(\nindex, names=[\"task_number\", \"cluster\", \"perfect_sorting\", \"pre_sequence\"]\n)\ndf = pd.DataFrame(data, index=index)\ndf.sort_index(axis=\"index\")\nrept = None\nif self.name is None:\nrept = Report(df, metas, geos, \"Remote\")\nelse:\nrept = Report(df, metas, geos, self.name)\nreturn rept\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.resubmit","title":"resubmit","text":"<pre><code>resubmit(shuffle_submit_order=True)\n</code></pre> <p>Resubmit all the tasks in the RemoteBatch</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef resubmit(self, shuffle_submit_order: bool = True) -&gt; \"RemoteBatch\":\n\"\"\"\n    Resubmit all the tasks in the RemoteBatch\n    Return:\n        self\n    \"\"\"\n# online, non-blocking\nself._submit(shuffle_submit_order, force=True)\nreturn self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.tasks_metric","title":"tasks_metric","text":"<pre><code>tasks_metric()\n</code></pre> <p>Get current tasks status metric</p> Return <p>dataframe with [\"task id\", \"status\", \"shots\"]</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def tasks_metric(self) -&gt; pd.DataFrame:\n\"\"\"\n    Get current tasks status metric\n    Return:\n        dataframe with [\"task id\", \"status\", \"shots\"]\n    \"\"\"\n# [TODO] more info on current status\n# offline, non-blocking\ntid = []\ndata = []\nfor int, task in self.tasks.items():\ntid.append(int)\ndat = [None, None, None]\ndat[0] = task.task_id\nif task.task_result_ir is not None:\ndat[1] = task.task_result_ir.task_status.name\ndat[2] = task.task_ir.nshots\ndata.append(dat)\nreturn pd.DataFrame(data, index=tid, columns=[\"task ID\", \"status\", \"shots\"])\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.Serializable","title":"Serializable","text":""},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.Serializable.json","title":"json","text":"<pre><code>json(**options)\n</code></pre> <p>Serialize the object to JSON string.</p> Return <p>JSON string</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def json(self, **options) -&gt; str:\n\"\"\"\n    Serialize the object to JSON string.\n    Return:\n        JSON string\n    \"\"\"\nreturn dumps(self, **options)\n</code></pre>"},{"location":"reference/bloqade/task/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade/task/braket/","title":"Braket","text":""},{"location":"reference/bloqade/task/braket_simulator/","title":"Braket simulator","text":""},{"location":"reference/bloqade/task/json/","title":"Json","text":""},{"location":"reference/bloqade/task/json/#bloqade.task.json.load_batch","title":"load_batch","text":"<pre><code>load_batch(filename_or_io, *backend_args, **backend_kwargs)\n</code></pre> <p>load batch from json file or string io to batch object</p> <p>Parameters:</p> Name Type Description Default <code>filename_or_io</code> <code>Union[str, TextIO]</code> <p>filename or file object pointing to</p> required <code>*backend_args</code> <p>args to pass to backend construction.</p> <code>()</code> <code>**backend_kwargs</code> <p>kwargs to pass to backend construction.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[RemoteBatch, LocalBatch]</code> <p>Union[RemoteBatch, LocalBatch]: the resulting batch object</p> Note <p>The backend args are not always required for <code>LocalBatch</code> objects, but for <code>RemoteBatch</code> objects they are required.</p> Source code in <code>src/bloqade/task/json.py</code> <pre><code>def load_batch(\nfilename_or_io: Union[str, TextIO], *backend_args, **backend_kwargs\n) -&gt; Union[RemoteBatch, LocalBatch]:\n\"\"\"load batch from json file or string io to batch object\n    Args:\n        filename_or_io (Union[str, TextIO]): filename or file object pointing to\n        json file.\n        *backend_args: args to pass to backend construction.\n        **backend_kwargs: kwargs to pass to backend construction.\n    Returns:\n        Union[RemoteBatch, LocalBatch]: the resulting batch object\n    Note:\n        The backend args are not always required for `LocalBatch` objects, but\n        for `RemoteBatch` objects they are required.\n    \"\"\"\ndeserializer = BatchDeserializer(*backend_args, **backend_kwargs)\nif isinstance(filename_or_io, str):\nwith open(filename_or_io, \"r\") as f:\nreturn json.load(f, object_hook=deserializer.object_hook)\nelse:\nreturn json.load(filename_or_io, object_hook=deserializer.object_hook)\n</code></pre>"},{"location":"reference/bloqade/task/json/#bloqade.task.json.save_batch","title":"save_batch","text":"<pre><code>save_batch(filename_or_io, batch)\n</code></pre> <p>save batch to json file or string io</p> <p>Parameters:</p> Name Type Description Default <code>filename_or_io</code> <code>Union[str, TextIO]</code> <p>filename or file object pointing to</p> required <code>batch</code> <code>Union[RemoteBatch, LocalBatch]</code> <p>batch object to save.</p> required Source code in <code>src/bloqade/task/json.py</code> <pre><code>def save_batch(\nfilename_or_io: Union[str, TextIO], batch: Union[RemoteBatch, LocalBatch]\n) -&gt; None:\n\"\"\"save batch to json file or string io\n    Args:\n        filename_or_io (Union[str, TextIO]): filename or file object pointing to\n        json file.\n        batch (Union[RemoteBatch, LocalBatch]): batch object to save.\n    \"\"\"\nif isinstance(filename_or_io, str):\nwith open(filename_or_io, \"w\") as f:\njson.dump(batch, f, cls=BatchSerializer)\nelse:\njson.dump(batch, filename_or_io, cls=BatchSerializer)\n</code></pre>"},{"location":"reference/bloqade/task/quera/","title":"Quera","text":""},{"location":"tree/builder/","title":"Build workflow:","text":"<pre><code>graph TD\n\n  ProgramStart(ProgramStart)\n\n  Coupling[\"[Coupling]\n  Rydberg , Hyperfine\"]\n\n  Detuning[Detuning]\n  Rabi[Rabi]\n\n  Amplitude[Amplitude]\n  Phase[Phase]\n\n  SpaceModulation(SpaceModulation)\n  Waveform{Waveform}\n\n  Options([\"[Options]\n  assign\n  batch_assign\n  flatten\n  parallelize\n  \"])\n\n  Services([\"[Services]\n  bloqade\n  quera\n  braket\"])\n\n  QuEraBackends([\"[Backends]\n  mock\n  cloud_mock\n  aquila\n  device\n  \"])\n\n  BraketBackends([\"[Backends]\n  aquila\n  local_emulator\n  \"])\n\n  BloqadeBackends([\"[Backends]\n  python\n  julia\n  \"])\n\n  Submit(\"[Submission]\n  submit()\n  run()\n  __call__\")\n\n  ProgramStart --&gt; Coupling;\n  Coupling --&gt; Detuning;\n  Coupling --&gt; Rabi;\n\n  Rabi --&gt; Amplitude;\n  Rabi --&gt; Phase;\n\n  Detuning --&gt; SpaceModulation;\n  Amplitude --&gt; SpaceModulation;\n  Phase --&gt; SpaceModulation;\n\n  SpaceModulation --&gt; Waveform;\n\n  Waveform --&gt; Coupling;\n  Waveform --&gt; Services;\n  Waveform --&gt; Options;\n  Options --&gt; Services;\n\n  Services --&gt;|quera| QuEraBackends;\n  Services --&gt;|braket| BraketBackends;\n  Services --&gt;|bloqade| BloqadeBackends;\n  QuEraBackends --&gt; Submit;\n  BraketBackends --&gt; Submit;\n  BloqadeBackends --&gt; Submit;</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Below you will find some examples of how to use Bloqade.</p> <ol> <li>Rabi Oscillations</li> </ol>"},{"location":"tutorials/scripts/rabi/","title":"Single Qubit Rabi Oscillations","text":"In\u00a0[1]: Copied! <pre>from bloqade import start, cast\nfrom bloqade.task.json import load_batch, save_batch\nfrom decimal import Decimal\nimport matplotlib.pyplot as plt\n</pre> from bloqade import start, cast from bloqade.task.json import load_batch, save_batch from decimal import Decimal import matplotlib.pyplot as plt <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 4\n      2 from bloqade.task.json import load_batch, save_batch\n      3 from decimal import Decimal\n----&gt; 4 import matplotlib.pyplot as plt\n\nModuleNotFoundError: No module named 'matplotlib'</pre> <p>define program with one atom, with constant detuning but variable Rabi frequency, ramping up to \"rabi_value\" and then returning to 0.0.</p> In\u00a0[2]: Copied! <pre>durations = cast([\"ramp_time\", \"run_time\", \"ramp_time\"])\n\nrabi_oscillations_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=durations, values=[0, \"rabi_value\", \"rabi_value\", 0]\n    )\n    .detuning.uniform.constant(duration=sum(durations), value=0)\n)\n</pre> durations = cast([\"ramp_time\", \"run_time\", \"ramp_time\"])  rabi_oscillations_program = (     start.add_position((0, 0))     .rydberg.rabi.amplitude.uniform.piecewise_linear(         durations=durations, values=[0, \"rabi_value\", \"rabi_value\", 0]     )     .detuning.uniform.constant(duration=sum(durations), value=0) ) <p>Assign values to the variables in the program, allowing the <code>run_time</code> (time the Rabi amplitude stays at the value of \"rabi_frequency\" ) to sweep across a range of values.</p> In\u00a0[3]: Copied! <pre>rabi_oscillation_job = rabi_oscillations_program.assign(\n    ramp_time=0.06, rabi_value=15, detuning_value=0.0\n).batch_assign(run_time=[Decimal(\"0.05\") * i for i in range(21)])\n</pre> rabi_oscillation_job = rabi_oscillations_program.assign(     ramp_time=0.06, rabi_value=15, detuning_value=0.0 ).batch_assign(run_time=[Decimal(\"0.05\") * i for i in range(21)]) <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 rabi_oscillation_job = rabi_oscillations_program.assign(\n      2 ramp_time=0.06, rabi_value=15, detuning_value=0.0\n      3 ).batch_assign(run_time=[Decimal(\"0.05\") * i for i in range(21)])\n\nFile ~/work/bloqade-python/bloqade-python/src/bloqade/builder/pragmas.py:42, in Assignable.assign(self, **assignments)\n     20 \"\"\"\n     21 Assign values to variables declared previously in the program.\n     22 \n   (...)\n     38 \n     39 \"\"\"\n     40 from bloqade.builder.assign import Assign\n---&gt; 42 return Assign(parent=self, **assignments)\n\nFile ~/work/bloqade-python/bloqade-python/src/bloqade/builder/assign.py:76, in Assign.__init__(self, parent, **assignments)\n     74 for name, value in assignments.items():\n     75     if name not in vars.scalar_vars and name not in vars.vector_vars:\n---&gt; 76         raise ValueError(\n     77             f\"batch_assign parameter '{name}' is not found in analog circuit.\"\n     78         )\n     79     if name in vars.vector_vars:\n     80         self._assignments[name] = cast_vector_param(value, name)\n\nValueError: batch_assign parameter 'detuning_value' is not found in analog circuit.</pre> <p>Run the program in emulation, obtaining a report object. For each possible set of variable values to simulate (in this case, centered around the <code>run_time</code> variable), let the task have 10000 shots.</p> In\u00a0[4]: Copied! <pre>emulator_results = rabi_oscillation_job.braket.local_emulator().run(1000)\nsave_batch(\"rabi-emulator-job.json\", emulator_results)\n</pre> emulator_results = rabi_oscillation_job.braket.local_emulator().run(1000) save_batch(\"rabi-emulator-job.json\", emulator_results) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 emulator_results = rabi_oscillation_job.braket.local_emulator().run(1000)\n      2 save_batch(\"rabi-emulator-job.json\", emulator_results)\n\nNameError: name 'rabi_oscillation_job' is not defined</pre> <p>Submit the same program to hardware, this time using <code>.parallelize</code> to make a copy of the original geometry (a single atom) that fills the FOV (Field-of-View Space), with at least 24 micrometers of distance between each atom.</p> <p>Unlike the emulation above, we only let each task run with 100 shots. A collection of tasks is known as a \"Job\" in Bloqade and jobs can be saved in JSON format so you can reload them later (a necessity considering how long it may take for the machine to handle tasks in the queue)</p> In\u00a0[5]: Copied! <pre>\"\"\"\nhardware_result = rabi_oscillation_job.parallelize(24).braket.aquila().submit(1000)\nsave_batch(\"rabi-job.json\", hardware_result)\n\"\"\"\n</pre> \"\"\" hardware_result = rabi_oscillation_job.parallelize(24).braket.aquila().submit(1000) save_batch(\"rabi-job.json\", hardware_result) \"\"\" Out[5]: <pre>'\\nhardware_result = rabi_oscillation_job.parallelize(24).braket.aquila().submit(1000)\\nsave_batch(\"rabi-job.json\", hardware_result)\\n'</pre> <p>Load JSON and pull results from Braket</p> In\u00a0[6]: Copied! <pre>emulator_report = load_batch(\"rabi-emulator-job.json\").report()\n# hardware_report = load_batch(\"rabi-job.json\").fetch().report()\n\ntimes = emulator_report.list_param(\"run_time\")\nbitstrings = emulator_report.bitstrings()\nemu_density = [ele.mean() for ele in bitstrings]\nplt.plot(times, emu_density)\n\n# bitstrings = hardware_report.bitstrings()\n# qpu_density = [ele.mean() for ele in bitstrings]\n\n# plt.plot(times, qpu_density)\nplt.show()\n</pre> emulator_report = load_batch(\"rabi-emulator-job.json\").report() # hardware_report = load_batch(\"rabi-job.json\").fetch().report()  times = emulator_report.list_param(\"run_time\") bitstrings = emulator_report.bitstrings() emu_density = [ele.mean() for ele in bitstrings] plt.plot(times, emu_density)  # bitstrings = hardware_report.bitstrings() # qpu_density = [ele.mean() for ele in bitstrings]  # plt.plot(times, qpu_density) plt.show() <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 emulator_report = load_batch(\"rabi-emulator-job.json\").report()\n      2 # hardware_report = load_batch(\"rabi-job.json\").fetch().report()\n      4 times = emulator_report.list_param(\"run_time\")\n\nFile ~/work/bloqade-python/bloqade-python/src/bloqade/task/json.py:163, in load_batch(filename_or_io, *backend_args, **backend_kwargs)\n    161 deserializer = BatchDeserializer(*backend_args, **backend_kwargs)\n    162 if isinstance(filename_or_io, str):\n--&gt; 163     with open(filename_or_io, \"r\") as f:\n    164         return json.load(f, object_hook=deserializer.object_hook)\n    165 else:\n\nFileNotFoundError: [Errno 2] No such file or directory: 'rabi-emulator-job.json'</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/scripts/rabi/#single-qubit-rabi-oscillations","title":"Single Qubit Rabi Oscillations\u00b6","text":""},{"location":"tutorials/scripts/rabi/#introduction","title":"Introduction\u00b6","text":"<p>In this example we show how to use Bloqade to emulate a Rabi oscillation as well as run it on hardware.</p>"}]}